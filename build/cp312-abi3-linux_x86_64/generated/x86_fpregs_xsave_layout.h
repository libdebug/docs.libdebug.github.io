//
// This file is part of libdebug Python library (https://github.com/libdebug/libdebug).
// It was autogenerated by libdebug/ptrace/native/xsave/autogenerate_xsave_layout.c.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

// This source file contains the layout of the xsave area for the current CPU.
// Along with the necessary nanobind bindings to access it.

#pragma once

#include <nanobind/nanobind.h>

namespace nb = nanobind;


// Detected XSAVE feature max = 519
#pragma pack(push, 1)
struct PtraceFPRegsStruct
{
    unsigned long type;
    bool dirty;
    bool fresh;
    unsigned char bool_padding[6];
    unsigned char padding0[32];
    std::array<Reg128, 8> mmx;
    std::array<Reg128, 16> xmm0;
    unsigned char padding1[96];
    unsigned char padding2[64];
    std::array<Reg128, 16> ymm0;
    unsigned char padding6[1856];
    unsigned int pkru;
    unsigned char padding7[60];
};
#pragma pack(pop)

// Size of struct fp_regs_struct = 2696
// Expected size of struct fp_regs_struct = 2696

#define HAS_XSAVE 1
#define FPREGS_TYPE 1

#ifdef DECLARE_NANOBIND

void init_fpregs_struct(nanobind::module_ &m)
{
    nb::class_<PtraceFPRegsStruct>(m, "PtraceFPRegsStruct")
        .def_ro("type", &PtraceFPRegsStruct::type)
        .def_rw("dirty", &PtraceFPRegsStruct::dirty)
        .def_rw("fresh", &PtraceFPRegsStruct::fresh)
        .def_ro("mmx", &PtraceFPRegsStruct::mmx)
        .def_ro("xmm0", &PtraceFPRegsStruct::xmm0)
        .def_ro("ymm0", &PtraceFPRegsStruct::ymm0);
}

#endif

