{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"","boost":2},{"location":"#quick-start","title":"Quick Start","text":"<p>Welcome to libdebug! This powerful Python library can be used to debug your binary executables programmatically, providing a robust, user-friendly interface. Debugging multithreaded applications can be a nightmare, but libdebug has you covered. Hijack and manage signals and syscalls with a simple API.</p> <p>Supported Systems</p> <p>libdebug currently supports Linux under the x86_64, x86 and ARM64 architectures. Other operating systems and architectures are not supported at this time.</p>","boost":2},{"location":"#dependencies","title":"Dependencies","text":"<p>To install libdebug, you first need to have some dependencies that will not be automatically resolved. These dependencies are libraries, utilities and development headers which are required by libdebug to compile its internals during installation.</p>  Ubuntu Arch Linux Fedora Debian <pre><code>sudo apt install -y python3 python3-dev g++ libdwarf-dev libelf-dev libiberty-dev linux-headers-generic libc6-dbg\n</code></pre> <pre><code>sudo pacman -S python libelf libdwarf gcc make debuginfod\n</code></pre> <pre><code>sudo dnf install -y python3 python3-devel kernel-devel g++ binutils-devel libdwarf-devel\n</code></pre> <pre><code>sudo apt install -y python3 python3-dev g++ libdwarf-dev libelf-dev libiberty-dev linux-headers-generic libc6-dbg\n</code></pre> <p>Is your distro missing?</p> <p>If you are using a Linux distribution that is not included in this section, you can search for equivalent packages for your distro. Chances are the naming convention of your system's repository will only change a prefix or suffix.</p>","boost":2},{"location":"#installation","title":"Installation","text":"<p>Installing libdebug once you have dependencies is as simple as running the following command:</p> stabledevelopment <pre><code>python3 -m pip install libdebug\n</code></pre> <pre><code>python3 -m pip install git+https://github.com/libdebug/libdebug.git@dev\n</code></pre> <p>If you want to test your installation when installing from source, we provide a suite of tests that you can run:</p> Testing your installation<pre><code>cd test\npython run_suite.py\n</code></pre>","boost":2},{"location":"#your-first-script","title":"Your First Script","text":"<p>Now that you have libdebug installed, you can start using it in your scripts. Here is a simple example of how to use libdebug to debug an executable:</p> libdebug's Hello World!<pre><code>from libdebug import debugger\n\nd = debugger(\"./test\") # (1)!\n\n# Start debugging from the entry point\nd.run() # (2)!\n\nmy_breakpoint = d.breakpoint(\"function\") # (3)!\n\n# Continue the execution until the breakpoint is hit\nd.cont() # (4)!\n\n# Print RAX\nprint(f\"RAX is {hex(d.regs.rax)}\") # (5)!\n</code></pre> <ol> <li>A debugger is created for the <code>test</code> executable</li> <li>The process is spawned and the entry point is reached</li> <li>A breakpoint is placed at the symbol <code>&lt;function&gt;</code> in the binary</li> <li>A continuation command is issued, execution resumes</li> <li>The value of the RAX register is read and printed</li> </ol>","boost":2},{"location":"#conflicts-with-other-python-packages","title":"Conflicts with other Python packages","text":"<p>Using pwntools alongside libdebug</p> <p>The current version of libdebug is incompatible with pwntools.</p> <p>While having both installed in your Python environment is not a problem, starting a process with pwntools in a libdebug script will cause unexpected behaviors as a result of some race conditions.</p> <p>Examples of some known issues include:</p> <ul> <li><code>ptrace</code> not intercepting SIGTRAP signals when the process is run with pwntools. This behavior is described in  Issue #48.</li> <li>Attaching libdebug to a process that was started with pwntools with <code>shell=True</code> will cause the process to attach to the shell process instead. This behavior is described in  Issue #57.</li> </ul>","boost":2},{"location":"#older-versions-of-the-documentation","title":"Older versions of the documentation","text":"<p>The documentation for versions of libdebug older that 0.7.0 has to be accessed manually at http://docs.libdebug.org/archive/VERSION, where <code>VERSION</code> is the version number you are looking for.</p>","boost":2},{"location":"#cite-us","title":"Cite Us","text":"<p>Need to cite libdebug as software used in your work? This is the way to cite us:</p> <pre><code>@software{libdebug_2024,\n    title = {libdebug: {Build} {Your} {Own} {Debugger}},\n    copyright = {MIT Licence},\n    url = {https://libdebug.org},\n    publisher = {libdebug.org},\n    author = {Digregorio, Gabriele and Bertolini, Roberto Alessandro and Panebianco, Francesco and Polino, Mario},\n    year = {2024},\n    doi = {10.5281/zenodo.13151549},\n}\n</code></pre> <p>We also have a poster on libdebug. If you use libdebug in your research, you can cite the associated short paper:</p> <pre><code>@inproceedings{10.1145/3658644.3691391,\nauthor = {Digregorio, Gabriele and Bertolini, Roberto Alessandro and Panebianco, Francesco and Polino, Mario},\ntitle = {Poster: libdebug, Build Your Own Debugger for a Better (Hello) World},\nyear = {2024},\nisbn = {9798400706363},\npublisher = {Association for Computing Machinery},\naddress = {New York, NY, USA},\nurl = {https://doi.org/10.1145/3658644.3691391},\ndoi = {10.1145/3658644.3691391},\nbooktitle = {Proceedings of the 2024 on ACM SIGSAC Conference on Computer and Communications Security},\npages = {4976\u20134978},\nnumpages = {3},\nkeywords = {debugging, reverse engineering, software security},\nlocation = {Salt Lake City, UT, USA},\nseries = {CCS '24}\n}\n</code></pre>","boost":2},{"location":"basics/command_queue/","title":"Default VS ASAP Mode","text":"<p>For most commands that can be issued in libdebug, it is necessary that the traced process stops running. When the traced process stops running as a result of a stopping event, libdebug can inspect the state and intervene in its control flow. When one of these commands is used in the script as the process is still running, libdebug will wait for the process to stop before executing the command.</p> <p>In the following example, the content of the <code>RAX</code> register is printed after the program hits the breakpoint or stops for any other reason:</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\nd.run()\n\nd.breakpoint(\"func\", file=\"binary\")\n\nd.cont()\n\nprint(f\"RAX: {hex(d.regs.rax)}\")\n</code></pre> <p>Script execution</p> <p>Please note that, after resuming execution of the tracee process, the script will continue to run. This means that the script will not wait for the process to stop before continuing with the rest of the script. If the next command is a libdebug command that requires the process to be stopped, the script will then wait for a stopping event before executing that command.</p> <p>In the following example, we make a similar scenario, but show how you can inspect the state of the process by arbitrarily stopping it in the default mode.</p> <pre><code>d = debugger(\"program\")\n\nd.run()\n\nd.breakpoint(\"func\", file=\"binary\")\n\nd.cont()\n\nprint(f\"RAX: {hex(d.regs.rax)}\") # (1)!\n\nd.cont()\nd.interrupt() # (2)!\n\nprint(f\"RAX: {hex(d.regs.rax)}\") # (3)!\n\nd.cont()\n\n[...]\n</code></pre> <ol> <li>This is the value of RAX at the breakpoint.</li> <li>Stop the process shortly after the process resumes.</li> <li>This is the value of RAX at the arbitrary stop (shortly after the breakpoint). </li> </ol>","boost":4},{"location":"basics/command_queue/#asap-mode","title":"ASAP Mode","text":"<p>If you want the command to be executed As Soon As Possible (ASAP) instead of waiting for a stopping event, you can specify it when creating the Debugger object. In this mode, the debugger will stop the process and issue the command as it runs your script without waiting. The following script has the same behavior as the previous one, using the corresponding option:</p> <pre><code>d = debugger(\"program\", auto_interrupt_on_command=True)\n\nd.run()\n\nd.breakpoint(\"func\", file=\"binary\")\n\nd.cont()\nd.wait()\n\nprint(f\"RAX: {hex(d.regs.rax)}\") # (1)!\n\nd.cont()\n\nprint(f\"RAX: {hex(d.regs.rax)}\") # (2)!\n\nd.cont()\n\n[...]\n</code></pre> <ol> <li>This is the value of RAX at the breakpoint.</li> <li>This is the value of RAX shortly after the breakpoint. The process is forcibly stopped to read the register.</li> </ol> <p>For the sake of this example the <code>wait()</code> method is used to wait for the stopping event (in this case, a breakpoint). This enforces the syncronization of the execution to the stopping point that we want to reach. Read more about the <code>wait()</code> method in the section dedicated to control flow commands.</p> <p>Pwning with libdebug</p> <p>Respectable pwners in the field find that the ASAP polling mode is particularly useful when writing exploits.</p>","boost":4},{"location":"basics/control_flow_commands/","title":"Control Flow Commands","text":"<p>Control flow commands allow you to set step through the code, stop execution and resume it at your pleasure. </p>","boost":4},{"location":"basics/control_flow_commands/#stepping","title":"Stepping","text":"<p>A basic feature of any debugger is the ability to step through the code. libdebug provides several methods to step, some of which will be familiar to users of other debuggers.</p>","boost":4},{"location":"basics/control_flow_commands/#single-step","title":"Single Step","text":"<p>The <code>step()</code> command executes the instruction at the instruction pointer and stops the process. When possible, it uses the hardware single-step feature of the CPU for better performance.</p> <p>Function Signature</p> <pre><code>d.step()\n</code></pre>","boost":4},{"location":"basics/control_flow_commands/#next","title":"Next","text":"<p>The <code>next()</code> command executes the current instruction at the instruction pointer and stops the process. If the instruction is a function call, it will execute the whole function and stop at the instruction following the call. In other debuggers, this command is known as \"step over\".</p> <p>Please note that the <code>next()</code> command resumes the execution of the program if the instruction is a function call. This means that the debugger can encounter stopping events in the middle of the function, causing the command to return before the function finishes.</p> <p>Function Signature</p> <pre><code>d.next()\n</code></pre> <p>Damn heuristics!</p> <p>The <code>next()</code> command uses heuristics to determine if the instruction is a function call and to find the stopping point. This means that the command may not work as expected in some cases (e.g. functions called with a jump, non-returning calls).</p>","boost":4},{"location":"basics/control_flow_commands/#step-until","title":"Step Until","text":"<p>The <code>step_until()</code> command executes single steps until a specific address is reached. Optionally, you can also limit steps to a maximum count (default value is -1, meaning no limit).</p> <p>Function Signature</p> <pre><code>d.step_until(position, max_steps=-1, file='hybrid') \n</code></pre> <p>The file parameter can be used to specify the choice on relative addressing. Refer to the memory access section for more information on addressing modes.</p>","boost":4},{"location":"basics/control_flow_commands/#continuing","title":"Continuing","text":"<p>The <code>cont()</code> command continues the execution.</p> <p>Function Signature</p> <pre><code>d.cont()\n</code></pre> <p>For example, in the following script, libdebug will not wait for the process to stop before checking d.dead. To change this behavior, you can use the <code>wait()</code> command right after the <code>cont()</code>. <pre><code>from libdebug import debugger\n\nd = debugger(\"program_that_dies_tragically\")\n\nd.run()\n\nd.cont()\n\nif d.dead:\n    print(\"The program is dead!\")\n</code></pre></p>","boost":4},{"location":"basics/control_flow_commands/#the-wait-method","title":"The <code>wait()</code> Method","text":"<p>The <code>wait()</code> command is likely the most important in libdebug. Loved by most and hated by many, it instructs the debugger to wait for a stopping event before continuing with the execution of the script.</p> <p>Example</p> <p>In the following script, libdebug will wait for the process to stop before printing \"provola\". <pre><code>from libdebug import debugger\n\nd = debugger(\"program_that_dies_tragically\")\n\nd.run()\n\nd.cont()\nd.wait()\n\nprint(\"provola\")\n</code></pre></p>","boost":4},{"location":"basics/control_flow_commands/#interrupt","title":"Interrupt","text":"<p>You can manually issue a stopping signal to the program using the <code>interrupt()</code> command. Clearly, this command is issued as soon as it is executed within the script.</p> <p>Function Signature</p> <pre><code>d.interrupt()\n</code></pre>","boost":4},{"location":"basics/control_flow_commands/#finish","title":"Finish","text":"<p>The <code>finish()</code> command continues execution until the current function returns or a breakpoint is hit. In other debuggers, this command is known as \"step out\".</p> <p>Function Signature</p> <pre><code>d.finish(heuristic='backtrace')\n</code></pre> <p>Damn heuristics!</p> <p>The <code>finish()</code> command uses heuristics to determine the end of a function. While libdebug allows to choose the heuristic, it is possible that none of the available options work in some specific cases. (e.g. tail-calls, non-returning calls).</p>","boost":4},{"location":"basics/control_flow_commands/#available-heuristics","title":"Available Heuristics","text":"<p>The <code>finish()</code> command allows you to choose the heuristic to use. If you don't specify any, the <code>\"backtrace\"</code> heuristic will be used. The following heuristics are available:</p> Heuristic Description <code>backtrace</code> The <code>backtrace</code> heuristic uses the return address on the function stack frame to determine the end of the function. This is the default heuristic but may fail in case of broken stack, rare execution flows, and obscure compiler optimizations. <code>step-mode</code> The <code>step-mode</code> heuristic uses repeated single steps to execute instructions until a <code>ret</code> instruction is reached. Nested calls are handled, when the calling convention is respected. This heuristic is slower and may fail in case of rare execution flows and obscure compiler optimizations.","boost":4},{"location":"basics/detach_and_gdb/","title":"Detach and GDB Migration","text":"<p>In libdebug, you can detach from the debugged process and continue execution with the <code>detach()</code> method.</p> <p>Function Signature</p> <pre><code>d.detach()\n</code></pre> <p>Detaching from a running process</p> <p>Remember that detaching from a process is meant to be used when the process is stopped. If the process is running, the command will wait for a stopping event. To forcibly stop the process, you can use the <code>interrupt()</code> method before migrating.</p>","boost":4},{"location":"basics/detach_and_gdb/#gdb-migration","title":"GDB Migration","text":"<p>If at any time during your script you want to take a more traditional approach to debugging, you can seamlessly switch to GDB. This will temporarily detach libdebug from the program and give you control over the program using GDB. Quitting GDB or using the <code>goback</code> command will return control to libdebug. </p> <p>Function Signature</p> <pre><code>d.gdb(\n    migrate_breakpoints: bool = True,\n    open_in_new_process: bool = True,\n    blocking: bool = True,\n) -&gt; GdbResumeEvent:\n</code></pre> Parameter Description <code>migrate_breakpoints</code> If set to <code>True</code>, libdebug will migrate the breakpoints to GDB. <code>open_in_new_process</code> If set to <code>True</code>, libdebug will open GDB in a new process. <code>blocking</code> If set to <code>True</code>, libdebug will wait for the user to terminate the GDB session to continue the script. <p>Setting the <code>blocking</code> to <code>False</code> is useful when you want to continue using the pipe interaction and other parts of your script as you take control of the debugging process.</p> <p>When <code>blocking</code> is set to <code>False</code>, the <code>gdb()</code> method will return a GdbResumeEvent object. This object can be used to wait for the GDB session to finish before continuing the script.</p> <p>Example of using non-blocking GDB migration</p> <pre><code>from libdebug import debugger\nd = debugger(\"program\")\npipe = d.run()\n\n# Reach interesting point in the program\n[...]\n\ngdb_event = d.gdb(blocking = False)\n\npipe.sendline(b\"dump interpret\")\n\nwith open(\"dump.bin\", \"r\") as f:\n    pipe.send(f.read())\n\ngdb_event.join() # (1)!\n</code></pre> <ol> <li>This will wait for the GDB session to finish before continuing the script.</li> </ol> <p>Please consider a few requirements when opening GDB in a new process. For this mode to work, libdebug needs to know which terminal emulator you are using. If not set, libdebug will try to detect this automatically. In some cases, detection may fail. You can manually set the terminal command in libcontext. If instead of opening GDB in a new terminal window you want to use the current terminal, you can simply set the <code>open_in_new_process</code> parameter to <code>False</code>.</p> <p>Example of setting the terminal with tmux</p> <pre><code>from libdebug import libcontext\n\nlibcontext.terminal = ['tmux', 'splitw', '-h']\n</code></pre> <p>Migrating from a running process</p> <p>Remember that GDB Migration is meant to be used when the process is stopped. If the process is running, the command will wait for a stopping event. To forcibly stop the process, you can use the <code>interrupt()</code> method before migrating.</p>","boost":4},{"location":"basics/detach_and_gdb/#graceful-termination","title":"Graceful Termination","text":"<p>If you are finished working with a Debugger object and wish to deallocate it, you can terminate it using the <code>terminate()</code> command.</p> <p>Function Signature</p> <pre><code>d.terminate()\n</code></pre> <p>What happens to the running process?</p> <p>When you terminate a Debugger object, the process is forcibly killed. If you wish to detach from the process and continue the execution before terminating the debugger, you should use the <code>detach()</code> command before.</p>","boost":4},{"location":"basics/kill_and_post_mortem/","title":"Process Death (and afterlife)","text":"<p>The default behavior in libdebug is to kill the debugged process when the script exits. This is done to prevent the process from running indefinitely if the debugging script terminates or you forget to kill it manually. When creating a Debugger object, you can set the <code>kill_on_exit</code> attribute to <code>False</code> to prevent this behavior:</p> <pre><code>from libdebug import Debugger\n\nd = debugger(\"test\", kill_on_exit=False)\n</code></pre> <p>You can also change this attribute in an existing Debugger object at runtime:  </p> <pre><code>d.kill_on_exit = False\n</code></pre> <p>Behavior when attaching to a process</p> <p>When debugging is initiated by attaching to an existing process, the <code>kill_on_exit</code> policy is enforced in the same way as when starting a new process.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#killing-the-process","title":"Killing the Process","text":"<p>You can kill the process any time the process is stopped using the <code>kill()</code> method:</p> <p>Function Signature</p> <pre><code>d.kill()\n</code></pre> <p>The method sends a <code>SIGKILL</code> signal to the process, which terminates it immediately. If the process is already dead, libdebug will throw an exception. When multiple threads are running, the <code>kill()</code> method will kill all threads under the parent process.</p> <p>Process Stop</p> <p>The <code>kill()</code> method will not stop a running process, unless libdebug is operating in ASAP Mode. Just like other commands, in the default mode, the <code>kill()</code> method will wait for the process to stop before executing.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#post-mortem-analysis","title":"Post Mortem Analysis","text":"<p>You can check if the process is dead using the <code>dead</code> property:</p> <pre><code>if not d.dead:\n    print(\"The process is not dead\")\nelse:\n    print(\"The process is dead\")\n</code></pre> <p>The <code>running</code> property</p> <p>The Debugger object also exposes the <code>running</code> property. This is not the opposite of <code>dead</code>. The <code>running</code> property is <code>True</code> when the process is not stopped and <code>False</code> otherwise. If execution was stopped by a stopping event, the <code>running</code> property will be equal to <code>False</code>. However, in this case the process can still be alive.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#cause-of-death","title":"Cause of Death","text":"<p>Has your process passed away unexpectedly? We are sorry to hear that. If your process is indeed defunct, you can access the exit code and signal using <code>exit_code</code> and <code>exit_signal</code>. When there is no valid exit code or signal, these properties will return <code>None</code>.</p> <pre><code>if d.dead:\n    print(f\"The process exited with code {d.exit_code}\")\n\nif d.dead:\n    print(f\"The process exited with signal {d.exit_signal}\")\n</code></pre>","boost":4},{"location":"basics/kill_and_post_mortem/#zombie-processes-and-threads","title":"Zombie Processes and Threads","text":"<p>When a process dies, it becomes a zombie process. This means that the process has terminated, but its parent process has not yet read its exit status. In libdebug, you can check if the process is a zombie using the <code>zombie</code> property of the Debugger object. This is particularly relevant in multi-threaded applications. To read more about this, check the dedicated section on zombie processes.</p> <p>Example Code</p> <pre><code>if d.zombie:\n    print(\"The process is a zombie\")\n</code></pre>","boost":4},{"location":"basics/libdebug101/","title":"libdebug 101","text":"<p>Welcome to libdebug! When writing a script to debug a program, the first step is to create a Debugger object. This object will be your main interface for debugging commands.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(argv=[\"./program\", \"arg1\", \"arg2\"]) # (1)!\n</code></pre> <ol> <li><code>argv</code> can either be a string (the name/path of the executable) or an array corresponding to the argument vector of the execution.</li> </ol> <p>Am I already debugging?</p> <p>Creating a Debugger object will not start the execution automatically. You can reuse the same debugger to iteratively run multiple instances of the program. This is particularly useful for smart bruteforcing or fuzzing scripts.</p> <p>Performing debugger initialization each time is not required and can be expensive.</p> <p>To run the executable, refer to Running an Executable</p>","boost":4},{"location":"basics/libdebug101/#environment","title":"Environment","text":"<p>Just as you would expect, you can also pass environment variables to the program using the <code>env</code> parameter. Here, the variables are passed as a string-string dictionary.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", env = {\"LD_PRELOAD\": \"musl_libc.so\"})\n</code></pre>","boost":4},{"location":"basics/libdebug101/#address-space-layout-randomization-aslr","title":"Address Space Layout Randomization (ASLR)","text":"<p>Modern operating system kernels implement mitigations against predictable addresses in binary exploitation scenarios. One such feature is ASLR, which randomizes the base address of mapped virtual memory pages (e.g., binary, libraries, stack). When debugging, this feature can become a nuisance for the user.</p> <p>By default, libdebug keeps ASLR enabled. The debugger <code>aslr</code> parameter can be used to change this behavior.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", aslr=False)\n</code></pre>","boost":4},{"location":"basics/libdebug101/#binary-entry-point","title":"Binary Entry Point","text":"<p>When a child process is spawned on the Linux kernel through the <code>ptrace</code> system call, it is possible to trace it as soon as the loader has set up your executable. Debugging these first instructions inside the loader library is generally uninteresting.</p> <p>For this reason, the default behavior for libdebug is to continue until the binary entry point (1) is reached. When you need to start debugging from the very beginning, you can simply disable this behavior in the following way:</p> <ol> <li>In Linux, the binary entry point corresponds to the <code>_start</code> / <code>__rt_entry</code> symbol in your binary executable. This function is the initial stub that calls the <code>main()</code> function in your executable, through a call to the standard library of your system (e.g., <code>__libc_start_main</code>, <code>__rt_lib_init</code>)</li> </ol> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", continue_to_binary_entrypoint=False)\n</code></pre> <p>What the hell are you debugging?</p> <p>Please note that this feature assumes the binary is well-formed. If the ELF header is corrupt, the binary entrypoint will not be resolved correctly. As such, setting this parameter to <code>False</code> is a good practice when you don't want libdebug to rely on this information.</p>","boost":4},{"location":"basics/libdebug101/#what-else-can-i-do","title":"What else can I do?","text":"<p>The Debugger object has many more parameters it can take.</p> <p>Function Signature</p> <pre><code>debugger(\n    argv=[],\n    aslr=True,\n    env=None,\n    escape_antidebug=False,\n    continue_to_binary_entrypoint=True,\n    auto_interrupt_on_command=False,\n    fast_memory=False,\n    kill_on_exit=True,\n    follow_children=True\n) -&gt; Debugger\n</code></pre> Parameter Type Description <code>argv</code> <code>str</code> | <code>list[str]</code> Path to the binary or argv list <code>aslr</code> <code>bool</code> Whether to enable ASLR. Defaults to True. <code>env</code> <code>dict[str, str]</code> The environment variables to use. Defaults to the same environment of the parent process. <code>escape_antidebug</code> <code>bool</code> Whether to automatically attempt to patch antidebugger detectors based on <code>ptrace</code>. <code>continue_to_binary_entrypoint</code> <code>bool</code> Whether to automatically continue to the binary entrypoint. <code>auto_interrupt_on_command</code> <code>bool</code> Whether to run libdebug in ASAP Mode. <code>fast_memory</code> <code>bool</code> Whether to use a faster memory reading method. Defaults to False. <code>kill_on_exit</code> <code>bool</code> Whether to kill the debugged process when the debugger exits. Defaults to True. <code>follow_children</code> <code>bool</code> Whether to automatically monitor child processes. Defaults to True. Return Value Debugger <code>Debugger</code> The debugger object","boost":4},{"location":"basics/memory_access/","title":"Memory Access","text":"<p>In libdebug, memory access is performed via the <code>memory</code> attribute of the Debugger object or the Thread Context. When reading from memory, a bytes-like object is returned. The following methods are available:</p> Single byte accessSlice accessBase and lengthSymbol accessSymbol Range <p>Access a single byte of memory by providing the address as an integer. <pre><code>d.memory[0x1000]\n</code></pre></p> <p>Access a range of bytes by providing the start and end addresses as integers. <pre><code>d.memory[0x1000:0x1010]\n</code></pre></p> <p>Access a range of bytes by providing the base address and length as integers. <pre><code>d.memory[0x1000, 0x10]\n</code></pre></p> <p>Access memory using a symbol name. <pre><code>d.memory[\"function\", 0x8]\n</code></pre></p> <p>When specifying a symbol, you can also provide an offset. Contrary to what happens in GDB, the offset is always interpreted as hexadecimal. <pre><code>d.memory[\"function+a8\"]\n</code></pre></p> <p>Access a range of bytes using a symbol name. <pre><code>d.memory[\"function\":\"function+0f\"]\n</code></pre> Please note that contrary to what happens in GDB, the offset is always interpreted as hexadecimal.</p> <p>Accessing memory with symbols</p> <p>Please note that, unless otherwise specified, symbols are resolved in the debugged binary only. To resolve symbols in shared libraries, you need to indicate it in the third parameter of the function.</p> <pre><code>d.memory[\"__libc_start_main\", 0x8, \"libc\"]\n</code></pre> <p>Writing to memory works similarly. You can write a bytes-like object to memory using the same addressing methods:</p> <pre><code>d.memory[d.rsp, 0x10] = b\"AAAAAAABC\"\nd.memory[\"main_arena\", 16, \"libc\"] = b\"12345678\"\n</code></pre> <p>Length/Slice when writing</p> <p>When writing to memory, slices and length are ignored in favor of the length of the specified bytes-like object.</p> <p>In the following example, only 4 bytes are written:</p> <pre><code>d.memory[\"main_arena\", 50] = b\"\\x0a\\xeb\\x12\\xfc\"\n</code></pre>","boost":4},{"location":"basics/memory_access/#absolute-and-relative-addressing","title":"Absolute and Relative Addressing","text":"<p>Just like with symbols, memory addresses can also be accessed relative to a certain file base. libdebug uses <code>\"hybrid\"</code> addressing by default. This means it first attempts to resolve addresses as absolute. If the address does not correspond to an absolute one, it considers it relative to the base of the binary.</p> <p>You can use the third parameter of the memory access method to select the file you want to use as base (e.g., libc, ld, binary). If you want to force libdebug to use absolute addressing, you can specify <code>\"absolute\"</code> instead.</p> <p>Examples of relative and absolute addressing</p> <pre><code># Absolute addressing\nd.memory[0x7ffff7fcb200, 0x10, \"absolute\"]\n\n# Hybrid addressing\nd.memory[0x1000, 0x10, \"hybrid\"]\n\n# Relative addressing\nd.memory[0x1000, 0x10, \"binary\"]\nd.memory[0x1000, 0x10, \"libc\"]\n</code></pre>","boost":4},{"location":"basics/memory_access/#searching-inside-memory","title":"Searching inside Memory","text":"<p>The <code>memory</code> attribute of the Debugger object also allows you to search for specific values in the memory of the process. You can search for integers, strings, or bytes-like objects.</p> <p>Function Signature</p> <pre><code>d.memory.find(\n    value: int | bytes | str,\n    file: str = \"all\",\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; list[int]:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>value</code> <code>int</code> | <code>bytes</code> | <code>str</code> The value to search for. <code>file</code> <code>str</code> The backing file to search in (e.g, binary, libc, stack). <code>start</code> <code>int</code> (optional) The start address of the search (works with both relative and absolute). <code>end</code> <code>int</code> (optional) The end address of the search (works with both relative and absolute). <p>Returns:</p> Return Type Description <code>Addresses</code> <code>list[int]</code> List of memory addresses where the value was found. <p>Usage Example</p> <pre><code>binsh_string_addr = d.memory.find(\"/bin/sh\", file=\"libc\")\n\nvalue_address = d.memory.find(0x1234, file=\"stack\", start=d.regs.rsp)\n</code></pre>","boost":4},{"location":"basics/memory_access/#searching-pointers","title":"Searching Pointers","text":"<p>The <code>memory</code> attribute of the Debugger object also allows you to search for values in a source memory map that are pointers to another memory map. One use case for this would be identifying potential leaks of memory addresses when libdebug is used for exploitation tasks.</p> <p>Function Signature</p> <pre><code>def find_pointers(\n        where: int | str = \"*\",\n        target: int | str = \"*\",\n        step: int = 1,\n    ) -&gt; list[tuple[int, int]]:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>where</code> <code>int</code> | <code>str</code> The memory map where we want to search for references. Defaults to <code>\"*\"</code>, which means all memory maps. <code>target</code> <code>int</code> | <code>str</code> The memory map whose pointers we want to find. Defaults to <code>\"*\"</code>, which means all memory maps. <code>step</code> <code>int</code> The interval step size while iterating over the memory buffer. Defaults to <code>1</code>. <p>Returns:</p> Return Type Description <code>Pointers</code> <code>list[tuple[int, int]]</code> A list of tuples containing the address where the pointer was found and the pointer itself. <p>Usage Example</p> <pre><code>pointers = d.memory.find_pointers(\"stack\", \"heap\")\n\nfor src, dst in pointers:\n    print(f\"Heap leak to {dst} found at {src} points\")\n</code></pre>","boost":4},{"location":"basics/memory_access/#fast-and-slow-memory-access","title":"Fast and Slow Memory Access","text":"<p>libdebug supports two different methods to access memory on Linux, controlled by the <code>fast_memory</code> parameter of the Debugger object. The two methods are:</p> <ul> <li><code>fast_memory=False</code> uses the <code>ptrace</code> system call interface, requiring a context switch from user space to kernel space for each architectural word-size read.</li> <li><code>fast_memory=True</code> reduces the access latency by relying on Linux's procfs, which contains a virtual file as an interface to the process memory.</li> </ul> <p>As of version 0.8 Chutoro Nigiri , <code>fast_memory=True</code> is the default. The following examples show how to change the memory access method when creating the Debugger object or at runtime.</p> When creating the Debugger objectAt runtime <pre><code>d = debugger(\"test\", fast_memory=False)\n</code></pre> <pre><code>d.fast_memory = False\n</code></pre>","boost":4},{"location":"basics/register_access/","title":"Register Access","text":"<p>libdebug offers a simple register access interface for supported architectures. Registers are accessible through the <code>regs</code> attribute of the Debugger object or the Thread Context.</p> <p>Multithreading</p> <p>In multi-threaded debugging, the <code>regs</code> attribute of the Debugger object will return the registers of the main thread.</p> <p>The following is an example of how to interact with the <code>RAX</code> register in a debugger object on AMD64:</p> Operation Code Snippet Reading <code>read_value = d.regs.rax</code> Writing <code>d.regs.rax = read_value + 1</code> <p>Note that the register values are read and written as Python integers. This is true for all registers except for floating point ones, which are coherent with their type. To avoid confusion, we list available registers and their types below. Related registers are available to access as well.</p> AMD64i386AArch64 Register Type Related Description General Purpose RAX Integer EAX, AX, AH, AL Accumulator register RBX Integer EBX, BX, BH, BL Base register RCX Integer ECX, CX, CH, CL Counter register RDX Integer EDX, DX, DH, DL Data register RSI Integer ESI, SI Source index for string operations RDI Integer EDI, DI Destination index for string operations RBP Integer EBP, BP Base pointer (frame pointer) RSP Integer ESP, SP Stack pointer R8 Integer R8D, R8W, R8B General-purpose register R9 Integer R9D, R9W, R9B General-purpose register R10 Integer R10D, R10W, R10B General-purpose register R11 Integer R11D, R11W, R11B General-purpose register R12 Integer R12D, R12W, R12B General-purpose register R13 Integer R13D, R13W, R13B General-purpose register R14 Integer R14D, R14W, R14B General-purpose register R15 Integer R15D, R15W, R15B General-purpose register RIP Integer EIP Instruction pointer Flags EFLAGS Integer Flags register Segment Registers CS Integer Code segment DS Integer Data segment ES Integer Extra segment FS Integer Additional segment GS Integer Additional segment SS Integer Stack segment FS_BASE Integer FS segment base address GS_BASE Integer GS segment base address Vector Registers XMM0 Integer Lower 128 bits of YMM0/ZMM0 XMM1 Integer Lower 128 bits of YMM1/ZMM1 XMM2 Integer Lower 128 bits of YMM2/ZMM2 XMM3 Integer Lower 128 bits of YMM3/ZMM3 XMM4 Integer Lower 128 bits of YMM4/ZMM4 XMM5 Integer Lower 128 bits of YMM5/ZMM5 XMM6 Integer Lower 128 bits of YMM6/ZMM6 XMM7 Integer Lower 128 bits of YMM7/ZMM7 XMM8 Integer Lower 128 bits of YMM8/ZMM8 XMM9 Integer Lower 128 bits of YMM9/ZMM9 XMM10 Integer Lower 128 bits of YMM10/ZMM10 XMM11 Integer Lower 128 bits of YMM11/ZMM11 XMM12 Integer Lower 128 bits of YMM12/ZMM12 XMM13 Integer Lower 128 bits of YMM13/ZMM13 XMM14 Integer Lower 128 bits of YMM14/ZMM14 XMM15 Integer Lower 128 bits of YMM15/ZMM15 YMM0 Integer 256-bit AVX extension of XMM0 YMM1 Integer 256-bit AVX extension of XMM1 YMM2 Integer 256-bit AVX extension of XMM2 YMM3 Integer 256-bit AVX extension of XMM3 YMM4 Integer 256-bit AVX extension of XMM4 YMM5 Integer 256-bit AVX extension of XMM5 YMM6 Integer 256-bit AVX extension of XMM6 YMM7 Integer 256-bit AVX extension of XMM7 YMM8 Integer 256-bit AVX extension of XMM8 YMM9 Integer 256-bit AVX extension of XMM9 YMM10 Integer 256-bit AVX extension of XMM10 YMM11 Integer 256-bit AVX extension of XMM11 YMM12 Integer 256-bit AVX extension of XMM12 YMM13 Integer 256-bit AVX extension of XMM13 YMM14 Integer 256-bit AVX extension of XMM14 YMM15 Integer 256-bit AVX extension of XMM15 ZMM0 Integer 512-bit AVX-512 extension of XMM0 ZMM1 Integer 512-bit AVX-512 extension of XMM1 ZMM2 Integer 512-bit AVX-512 extension of XMM2 ZMM3 Integer 512-bit AVX-512 extension of XMM3 ZMM4 Integer 512-bit AVX-512 extension of XMM4 ZMM5 Integer 512-bit AVX-512 extension of XMM5 ZMM6 Integer 512-bit AVX-512 extension of XMM6 ZMM7 Integer 512-bit AVX-512 extension of XMM7 ZMM8 Integer 512-bit AVX-512 extension of XMM8 ZMM9 Integer 512-bit AVX-512 extension of XMM9 ZMM10 Integer 512-bit AVX-512 extension of XMM10 ZMM11 Integer 512-bit AVX-512 extension of XMM11 ZMM12 Integer 512-bit AVX-512 extension of XMM12 ZMM13 Integer 512-bit AVX-512 extension of XMM13 ZMM14 Integer 512-bit AVX-512 extension of XMM14 ZMM15 Integer 512-bit AVX-512 extension of XMM15 Floating Point (Legacy x87) ST(0)-ST(7) Floating Point x87 FPU data registers MM0-MM7 Integer MMX registers Register Type Related Description General Purpose EAX Integer AX, AH, AL Accumulator register EBX Integer BX, BH, BL Base register ECX Integer CX, CH, CL Counter register EDX Integer DX, DH, DL Data register ESI Integer SI Source index for string operations EDI Integer DI Destination index for string operations EBP Integer BP Base pointer (frame pointer) ESP Integer SP Stack pointer EIP Integer IP Instruction pointer Flags EFLAGS Integer Flags register Segment Registers CS Integer Code segment DS Integer Data segment ES Integer Extra segment FS Integer Additional segment GS Integer Additional segment SS Integer Stack segment Floating Point Registers ST(0)-ST(7) Floating Point x87 FPU data registers Vector Registers XMM0 Integer Lower 128 bits of YMM0/ZMM0 XMM1 Integer Lower 128 bits of YMM1/ZMM1 XMM2 Integer Lower 128 bits of YMM2/ZMM2 XMM3 Integer Lower 128 bits of YMM3/ZMM3 XMM4 Integer Lower 128 bits of YMM4/ZMM4 XMM5 Integer Lower 128 bits of YMM5/ZMM5 XMM6 Integer Lower 128 bits of YMM6/ZMM6 XMM7 Integer Lower 128 bits of YMM7/ZMM7 YMM0 Integer 256-bit AVX extension of XMM0 YMM1 Integer 256-bit AVX extension of XMM1 YMM2 Integer 256-bit AVX extension of XMM2 YMM3 Integer 256-bit AVX extension of XMM3 YMM4 Integer 256-bit AVX extension of XMM4 YMM5 Integer 256-bit AVX extension of XMM5 YMM6 Integer 256-bit AVX extension of XMM6 YMM7 Integer 256-bit AVX extension of XMM7 Register Type Alias(es) Description General Purpose X0 Integer W0 Function result or argument X1 Integer W1 Function result or argument X2 Integer W2 Function result or argument X3 Integer W3 Function result or argument X4 Integer W4 Function result or argument X5 Integer W5 Function result or argument X6 Integer W6 Function result or argument X7 Integer W7 Function result or argument X8 Integer W8 Indirect result location (also called \"IP0\") X9 Integer W9 Temporary register X10 Integer W10 Temporary register X11 Integer W11 Temporary register X12 Integer W12 Temporary register X13 Integer W13 Temporary register X14 Integer W14 Temporary register X15 Integer W15 Temporary register (also called \"IP1\") X16 Integer W16 Platform Register (often used as scratch) X17 Integer W17 Platform Register (often used as scratch) X18 Integer W18 Platform Register X19 Integer W19 Callee-saved register X20 Integer W20 Callee-saved register X21 Integer W21 Callee-saved register X22 Integer W22 Callee-saved register X23 Integer W23 Callee-saved register X24 Integer W24 Callee-saved register X25 Integer W25 Callee-saved register X26 Integer W26 Callee-saved register X27 Integer W27 Callee-saved register X28 Integer W28 Callee-saved register X29 Integer W29, FP Frame pointer X30 Integer W30, LR Link register (return address) XZR Integer WZR, ZR Zero register (always reads as zero) SP Integer Stack pointer PC Integer Program counter Flags PSTATE Integer Processor state in exception handling Vector Registers (SIMD/FP) V0 Integer Vector or scalar register V1 Integer Vector or scalar register V2 Integer Vector or scalar register V3 Integer Vector or scalar register V4 Integer Vector or scalar register V5 Integer Vector or scalar register V6 Integer Vector or scalar register V7 Integer Vector or scalar register V8 Integer Vector or scalar register V9 Integer Vector or scalar register V10 Integer Vector or scalar register V11 Integer Vector or scalar register V12 Integer Vector or scalar register V13 Integer Vector or scalar register V14 Integer Vector or scalar register V15 Integer Vector or scalar register V16 Integer Vector or scalar register V17 Integer Vector or scalar register V18 Integer Vector or scalar register V19 Integer Vector or scalar register V20 Integer Vector or scalar register V21 Integer Vector or scalar register V22 Integer Vector or scalar register V23 Integer Vector or scalar register V24 Integer Vector or scalar register V25 Integer Vector or scalar register V26 Integer Vector or scalar register V27 Integer Vector or scalar register V28 Integer Vector or scalar register V29 Integer Vector or scalar register V30 Integer Vector or scalar register V31 Integer Vector or scalar register Q0 Integer Vector or scalar register Q1 Integer Vector or scalar register Q2 Integer Vector or scalar register Q3 Integer Vector or scalar register Q4 Integer Vector or scalar register Q5 Integer Vector or scalar register Q6 Integer Vector or scalar register Q7 Integer Vector or scalar register Q8 Integer Vector or scalar register Q9 Integer Vector or scalar register Q10 Integer Vector or scalar register Q11 Integer Vector or scalar register Q12 Integer Vector or scalar register Q13 Integer Vector or scalar register Q14 Integer Vector or scalar register Q15 Integer Vector or scalar register Q16 Integer Vector or scalar register Q17 Integer Vector or scalar register Q18 Integer Vector or scalar register Q19 Integer Vector or scalar register Q20 Integer Vector or scalar register Q21 Integer Vector or scalar register Q22 Integer Vector or scalar register Q23 Integer Vector or scalar register Q24 Integer Vector or scalar register Q25 Integer Vector or scalar register Q26 Integer Vector or scalar register Q27 Integer Vector or scalar register Q28 Integer Vector or scalar register Q29 Integer Vector or scalar register Q30 Integer Vector or scalar register Q31 Integer Vector or scalar register D0 Integer Vector or scalar register D1 Integer Vector or scalar register D2 Integer Vector or scalar register D3 Integer Vector or scalar register D4 Integer Vector or scalar register D5 Integer Vector or scalar register D6 Integer Vector or scalar register D7 Integer Vector or scalar register D8 Integer Vector or scalar register D9 Integer Vector or scalar register D10 Integer Vector or scalar register D11 Integer Vector or scalar register D12 Integer Vector or scalar register D13 Integer Vector or scalar register D14 Integer Vector or scalar register D15 Integer Vector or scalar register D16 Integer Vector or scalar register D17 Integer Vector or scalar register D18 Integer Vector or scalar register D19 Integer Vector or scalar register D20 Integer Vector or scalar register D21 Integer Vector or scalar register D22 Integer Vector or scalar register D23 Integer Vector or scalar register D24 Integer Vector or scalar register D25 Integer Vector or scalar register D26 Integer Vector or scalar register D27 Integer Vector or scalar register D28 Integer Vector or scalar register D29 Integer Vector or scalar register D30 Integer Vector or scalar register D31 Integer Vector or scalar register S0 Integer Vector or scalar register S1 Integer Vector or scalar register S2 Integer Vector or scalar register S3 Integer Vector or scalar register S4 Integer Vector or scalar register S5 Integer Vector or scalar register S6 Integer Vector or scalar register S7 Integer Vector or scalar register S8 Integer Vector or scalar register S9 Integer Vector or scalar register S10 Integer Vector or scalar register S11 Integer Vector or scalar register S12 Integer Vector or scalar register S13 Integer Vector or scalar register S14 Integer Vector or scalar register S15 Integer Vector or scalar register S16 Integer Vector or scalar register S17 Integer Vector or scalar register S18 Integer Vector or scalar register S19 Integer Vector or scalar register S20 Integer Vector or scalar register S21 Integer Vector or scalar register S22 Integer Vector or scalar register S23 Integer Vector or scalar register S24 Integer Vector or scalar register S25 Integer Vector or scalar register S26 Integer Vector or scalar register S27 Integer Vector or scalar register S28 Integer Vector or scalar register S29 Integer Vector or scalar register S30 Integer Vector or scalar register S31 Integer Vector or scalar register H0 Integer Vector or scalar register H1 Integer Vector or scalar register H2 Integer Vector or scalar register H3 Integer Vector or scalar register H4 Integer Vector or scalar register H5 Integer Vector or scalar register H6 Integer Vector or scalar register H7 Integer Vector or scalar register H8 Integer Vector or scalar register H9 Integer Vector or scalar register H10 Integer Vector or scalar register H11 Integer Vector or scalar register H12 Integer Vector or scalar register H13 Integer Vector or scalar register H14 Integer Vector or scalar register H15 Integer Vector or scalar register H16 Integer Vector or scalar register H17 Integer Vector or scalar register H18 Integer Vector or scalar register H19 Integer Vector or scalar register H20 Integer Vector or scalar register H21 Integer Vector or scalar register H22 Integer Vector or scalar register H23 Integer Vector or scalar register H24 Integer Vector or scalar register H25 Integer Vector or scalar register H26 Integer Vector or scalar register H27 Integer Vector or scalar register H28 Integer Vector or scalar register H29 Integer Vector or scalar register H30 Integer Vector or scalar register H31 Integer Vector or scalar register B0 Integer Vector or scalar register B1 Integer Vector or scalar register B2 Integer Vector or scalar register B3 Integer Vector or scalar register B4 Integer Vector or scalar register B5 Integer Vector or scalar register B6 Integer Vector or scalar register B7 Integer Vector or scalar register B8 Integer Vector or scalar register B9 Integer Vector or scalar register B10 Integer Vector or scalar register B11 Integer Vector or scalar register B12 Integer Vector or scalar register B13 Integer Vector or scalar register B14 Integer Vector or scalar register B15 Integer Vector or scalar register B16 Integer Vector or scalar register B17 Integer Vector or scalar register B18 Integer Vector or scalar register B19 Integer Vector or scalar register B20 Integer Vector or scalar register B21 Integer Vector or scalar register B22 Integer Vector or scalar register B23 Integer Vector or scalar register B24 Integer Vector or scalar register B25 Integer Vector or scalar register B26 Integer Vector or scalar register B27 Integer Vector or scalar register B28 Integer Vector or scalar register B29 Integer Vector or scalar register B30 Integer Vector or scalar register B31 Integer Vector or scalar register <p>Hardware Support</p> <p>libdebug only exposes registers which are available on your CPU model. For AMD64, the list of available AVX registers is determined by checking the CPU capabilities. If you believe your CPU supports AVX registers but they are not available, we encourage your to open an  Issue with your hardware details.</p>","boost":4},{"location":"basics/register_access/#filtering-registers","title":"Filtering Registers","text":"<p>The <code>regs</code> field of the Debugger object or the Thread Context can also be used to filter registers with specific values.</p> <p>Function Signature</p> <pre><code>d.regs.filter(value: float) -&gt; list[str]:\n</code></pre> <p>The filtering routine will look for the given value in both integer and floating point registers.</p> <p>Example of Filtering Registers</p> <pre><code>d.regs.rax = 0x1337\n\n# Filter the value 0x1337 in the registers\nresults = d.regs.filter(0x1337)\nprint(f\"Found in: {results}\")\n</code></pre>","boost":4},{"location":"basics/running_an_executable/","title":"Running an Executable","text":"<p>You have created your first debugger object, and now you want to run the executable. Calling the <code>run()</code> method will spawn a new child process and prepare it for the execution of your binary.</p> <p><pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\nd.run()\n</code></pre> At this point, the process execution is stopped, waiting for your commands.</p> <p>A few things to keep in mind</p> <ul> <li>Please remember that the process you are debugging (the tracee) and the debugger itself are running in different threads. </li> <li>Also note that breakpoints and other stopping events set by the user are not kept between different runs of the program. If you want to place them again, you should redo so after each call to <code>d.run()</code>. You cannot set breakpoints before calling <code>d.run()</code>.</li> </ul>","boost":4},{"location":"basics/running_an_executable/#process-io","title":"Process I/O","text":"<p>When execution is resumed, chances are that your process will need to take input and produce output. To interact with the standard input and output of the process, you can use the PipeManager returned by the <code>run()</code> function.</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\npipe = d.run()\n\nd.cont()\nprint(pipe.recvline().decode())\nd.wait()\n</code></pre> <p>All pipe receive-like methods have a timeout parameter that you can set. The default value, <code>timeout_default</code>, can be set globally as a parameter of the PipeManager object. By default, this value is set to 2 seconds.</p> <p>Changing the global timeout</p> <pre><code>pipe = d.run()\n\npipe.timeout_default = 10 # (1)!\n</code></pre> <ol> <li>This sets the default timeout for all pipe receive-like methods to 10 seconds.</li> </ol> <p>You can interact with the process's pipe manager using the following methods:</p> Method Description <code>recv</code> Receives at most <code>numb</code> bytes from the target's stdout.Parameters:- <code>numb</code> (int) \u00a0\u00a0\u00a0 [default = 4096]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default] <code>recverr</code> Receives at most <code>numb</code> bytes from the target's stderr.Parameters:- <code>numb</code> (int) \u00a0\u00a0\u00a0 [default = 4096]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default] <code>recvuntil</code> Receives data from stdout until a specified delimiter is encountered for a certain number of occurrences.Parameters:- <code>delims</code> (bytes)- <code>occurrences</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = False]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>recverruntil</code> Receives data from stderr until a specified delimiter is encountered for a certain number of occurrences.Parameters:- <code>delims</code> (bytes)- <code>occurrences</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = False]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>recvline</code> Receives <code>numlines</code> lines from the target's stdout.Parameters:- <code>numlines</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = True]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>recverrline</code> Receives <code>numlines</code> lines from the target's stderr.Parameters:- <code>numlines</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = True]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>send</code> Sends <code>data</code> to the target's stdin.Parameters:- <code>data</code> (bytes) <code>sendafter</code> Sends <code>data</code> after receiving a specified number of occurrences of a delimiter from stdout.Parameters:- <code>delims</code> (bytes)- <code>data</code> (bytes)- <code>occurrences</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = False]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>sendline</code> Sends <code>data</code> followed by a newline to the target's stdin.Parameters:- <code>data</code> (bytes) <code>sendlineafter</code> Sends a line of <code>data</code> after receiving a specified number of occurrences of a delimiter from stdout.Parameters:- <code>delims</code> (bytes)- <code>data</code> (bytes)- <code>occurrences</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = False]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>close</code> Closes the connection to the target. <code>interactive</code> Enters interactive mode, allowing manual send/receive operations with the target. Read more in the dedicated section.Parameters:- <code>prompt</code> (str) \u00a0\u00a0\u00a0 [default = \"$ \"]- <code>auto_quit</code> (bool) \u00a0\u00a0\u00a0 [default = False] <p>When process is stopped</p> <p>When the process is stopped, the PipeManager will not be able to receive new (unbuffered) data from the target. For this reason, the API includes a parameter called <code>optional</code>.</p> <p>When set to <code>True</code>, libdebug will not necessarily expect to receive data from the process when it is stopped. When set to <code>False</code>, any recv-like instruction (including <code>sendafter</code> and <code>sendlineafter</code>) will fail with an exception when the process is not running.</p> <p>Operations on stdin like <code>send</code> and <code>sendline</code> are not affected by this limitation, since the kernel will buffer the data until the process is resumed.</p>","boost":4},{"location":"basics/running_an_executable/#interactive-io","title":"Interactive I/O","text":"<p>The PipeManager contains a method called <code>interactive()</code> that allows you to directly interact with the process's standard I/O. This method will print characters from standard output and error and read your inputs, letting you interact naturally with the process. The <code>interactive()</code> method is blocking, so the execution of the script will wait for the user to terminate the interactive session. To quit an interactive session, you can press <code>Ctrl+C</code> or <code>Ctrl+D</code>.</p> <p>Function Signature</p> <pre><code>pipe.interactive(prompt: str = prompt_default, auto_quit: bool = False):\n</code></pre> <p>The <code>prompt</code> parameter sets the line prefix in the terminal (e.g. <code>\"$ \"</code> and <code>\"&gt; \"</code> will produce <code>$ cat flag</code> and <code>&gt; cat flag</code> respectively). By default, it is set to <code>\"$ \"</code>. The <code>auto_quit</code> parameter, when set to <code>True</code>, will automatically quit the interactive session when the process is stopped.</p> <p>If any of the file descriptors of standard input, output, or error are closed, a warning will be printed.</p>","boost":4},{"location":"basics/running_an_executable/#attaching-to-a-running-process","title":"Attaching to a Running Process","text":"<p>If you want to attach to a running process instead of spawning a child, you can use the <code>attach()</code> method in the Debugger object. This method will attach to the process with the specified PID.</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"test\")\n\npid = 1234\n\nd.attach(pid)\n</code></pre> <p>The process will stop upon attachment, waiting for your commands.</p> <p>Ptrace Scope</p> <p>libdebug uses the <code>ptrace</code> system call to interact with the process. For security reasons, this system call is limited by the kernel according to a <code>ptrace_scope</code> parameter. Different systems have different default values for this parameter. If the <code>ptrace</code> system call is not allowed, the <code>attach()</code> method will raise an exception notifying you of this issue.</p>","boost":4},{"location":"basics/running_an_executable/#disabling-pipe-redirection","title":"Disabling Pipe Redirection","text":"<p>By default, libdebug redirects the standard input, output, and error of the process to pipes. This is how you can interact with these file descriptors using I/O commands. If you want to disable this behavior, you can set the <code>redirect_pipes</code> parameter of the <code>run()</code> method to <code>False</code>.</p> <p>Usage</p> <pre><code>d.run(redirect_pipes=False)\n</code></pre> <p>When set to <code>False</code>, the standard input, output, and error of the process will not be redirected to pipes. This means that you will not be able to interact with the process using the PipeManager object, and libdebug will act as a transparent proxy between the executable and its standard I/O.</p>","boost":4},{"location":"basics/supported_systems/","title":"Supported Systems","text":"","boost":4},{"location":"basics/supported_systems/#operating-systems","title":"Operating Systems","text":"<p>Currently, libdebug only supports the  GNU/Linux Operating System.</p>","boost":4},{"location":"basics/supported_systems/#architectures","title":"Architectures","text":"Architecture Alias Support  x86_64 AMD64  Stable  i386 over AMD64 32-bit compatibility mode  Alpha  i386 IA-32  Alpha  ARM 64-bit AArch64  Beta  ARM 32-bit ARM32  Not Supported <p>Forcing a specific architecture</p> <p>If for any reason you need to force libdebug to use a specific architecture (e.g., corrupted ELF), you can do so by setting the <code>arch</code> parameter in the Debugger object. For example, to force the debugger to use the x86_64 architecture, you can use the following code: <pre><code>from libdebug import debugger\n\nd = debugger(\"program\", ...)\n\nd.arch = \"amd64\"\n</code></pre></p>","boost":4},{"location":"blog/","title":"Blogposts","text":""},{"location":"blog/2024/10/13/a-new-documentation/","title":"A New Documentation","text":"<p>Hello, World! Thank for using libdebug. We are proud to roll out our new documentation along with version 0.7.0. This new documentation is powered by MkDocs and Material for MkDocs. We hope you find it more intuitive and easier to navigate.</p> <p>We have expanded the documentation to cover more topics and provide more examples. We also tried to highlight some common difficulties that have been reported. Also, thanks to the mkdocs search plugin, you can more easily find what you are looking for, both in the documentation and pages generated from Pydoc.</p> <p>We hope you enjoy the new documentation. If you find any mistakes or would like to suggest improvements, please let us know by opening an  issue on our GitHub repository.</p>"},{"location":"blog/2024/10/14/see-you-at-acm-ccs-2024/","title":"See you at ACM CCS 2024!","text":"<p>We are excited to announce that we will be presenting a poster on libdebug at the 2024 ACM Conference on Computer and Communications Security (ACM CCS 2024). The conference will be held in Salt Lake City, Utah. The poster session is October 16th at 16:30. We will be presenting the rationale behind libdebug and demonstrating how it can be used in some cool use cases.</p> <p>If you are attending the conference, please stop by our poster and say hello. We would love to meet you and hear about your ideas. We are also looking forward to hearing about your research and how libdebug can help you in your work. Come by and grab some swag!</p> <p>Link to the conference: ACM CCS 2024 Link to the poster information: libdebug Poster Link to the proceedings: ACM Digital Library</p>"},{"location":"blog/2025/03/26/release-08---chutoro-nigiri/","title":"Release 0.8 - Chutoro Nigiri","text":"<p>Hello, debuggers! It's been a while since our last release, but we are excited to announce libdebug version 0.8, codename  Chutoro Nigiri . This release brings several new features, improvements, and bug fixes. Here is a summary of the changes:</p>"},{"location":"blog/2025/03/26/release-08---chutoro-nigiri/#features","title":"Features","text":"<ul> <li>Process/Thread Snapshots &amp; Diffs: Take snapshots of the execution state of the debuggee and compare them across different points in time.</li> <li>Multiprocessing Support: Automatically manage child processes created via <code>fork()</code>, attaching new debuggers to them. This behavior can be customized with the <code>Debugger</code> parameter <code>follow_children</code>.</li> <li>Find References Between Memory Maps: Introduced <code>d.memory.find_pointers</code> to identify all pointers in a memory region that reference another region, useful for detecting memory leaks in cybersecurity applictions.</li> <li>SIGTRAP Signal Handling: Now it is possible to catch SIGTRAP signals, excluding those directly related to debugging, exposing only unrecognized signals from the process or external sources.</li> <li>Defaulted Fast Memory Access (<code>fast_memory=True</code>): Improves performance of memory access. Can be disabled using the <code>fast_memory</code> parameter in <code>Debugger</code>.</li> <li>New Terminal Autodetection for <code>d.gdb(open_in_new_process=True)</code>: Ensures GDB opens correctly in a newly detected terminal without user-defined commands. </li> <li>Automatic Symbol Resolution for Unspecified Backing Files: When no specific file is set, symbols are resolved for all memory maps, with a warning due to potential performance impact.</li> </ul>"},{"location":"blog/2025/03/26/release-08---chutoro-nigiri/#other-improvements","title":"Other Improvements","text":"<ul> <li>Migration from CFFI to Nanobind.</li> <li>Refined Exception Handling: Standardized across the codebase for improved consistency.</li> <li>Improved IDE Support: Enhancements to improve autocompletion and code suggestions.</li> <li>Exposed <code>zombie</code> attribute in <code>ThreadContext</code>: Allows users to check if a thread is a zombie.</li> </ul>"},{"location":"blog/2025/03/26/release-08---chutoro-nigiri/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed Memory Leaks: Resolved multiple leaks across various libdebug modules.</li> <li>Fixed <code>SymbolList</code> Slicing: Properly supports slice operations.</li> <li>Improved <code>debuginfod</code> Handling: Enhanced caching logic when a file is not available on <code>debuginfod</code>, improving compatibility with other binaries that use <code>debuginfod</code> on your system.</li> <li>Fixed Resource Access Issues After Detach.</li> <li>Resolved Object Collisions in Event Handling: Addressed key-collision issues in event-related objects (e.g., <code>SyscallHandler</code>, <code>SignalCatcher</code>).</li> <li>Fixed Binary Path Resolution: Prevents incorrect binary paths in certain edge cases.</li> <li>Improved <code>d.gdb</code> for Edge Cases: Fixed several inconsistencies in execution.</li> <li>Fixed <code>step</code>, <code>finish</code>, and <code>next</code> Operations in Callbacks: Now executed correctly.</li> <li>Enhanced Stability &amp; Performance Optimizations.</li> </ul>"},{"location":"blog/2025/03/26/release-08---chutoro-nigiri/#testing-ci","title":"Testing &amp; CI","text":"<ul> <li>CI Support for arm64 &amp; Ubuntu 24.04: Improved compatibility and test automation.</li> </ul>"},{"location":"blog/2025/03/26/release-08---chutoro-nigiri/#documentation","title":"Documentation","text":"<ul> <li>Added Documentation for New Features.</li> <li>Updated Contributing Guidelines.</li> <li>Fixed Broken Links &amp; Missing Pydocs.</li> <li>Added Reference to Published Research Poster at a Top Conference.</li> </ul>"},{"location":"blog/2025/03/26/release-08---chutoro-nigiri/#new-contributors","title":"New Contributors","text":"<ul> <li>collodel</li> <li>myasn1k</li> </ul>"},{"location":"code_examples/example_cc24/","title":"CyberChallenge 2024 - Workshop","text":"<p>This script was used to showcase the power of libdebug during the Workshop at the CyberChallenge.IT 2024 Finals. An explanation of the script, along with a brief introduction to libdebug, is available in the official stream of the event, starting from timestamp 2:17:00.</p> <pre><code>from libdebug import debugger\nfrom string import ascii_letters, digits\n\n# Enable the escape_antidebug option to bypass the ptrace call\nd = debugger(\"main\", escape_antidebug=True)\n\ndef callback(_, __):\n    # This will automatically issue a continue when the breakpoint is hit\n    pass\n\ndef on_enter_nanosleep(t, _):\n    # This sets every argument to NULL to make the syscall fail\n    t.syscall_arg0 = 0\n    t.syscall_arg1 = 0\n    t.syscall_arg2 = 0\n    t.syscall_arg3 = 0\n\nalphabet = ascii_letters + digits + \"_{}\"\n\nflag = b\"\"\nbest_hit_count = 0\n\nwhile True:\n    for c in alphabet:\n        r = d.run()\n\n        # Any time we call run() we have to reset the breakpoint and syscall handler\n        bp = d.breakpoint(0x13e1, hardware=True, callback=callback, file=\"binary\")\n        d.handle_syscall(\"clock_nanosleep\", on_enter=on_enter_nanosleep)\n\n        d.cont()\n\n        r.sendline(flag + c.encode())\n\n        # This makes the debugger wait for the process to terminate\n        d.wait()\n\n        response = r.recvline()\n\n        # `run()` will automatically kill any still-running process, but it's good practice to do it manually\n        d.kill()\n\n        if b\"Yeah\" in response:\n            # The flag is correct\n            flag += c.encode()\n            print(flag)\n            break\n\n        if bp.hit_count &gt; best_hit_count:\n            # We have found a new flag character\n            best_hit_count = bp.hit_count\n            flag += c.encode()\n            print(flag)\n            break\n\n    if c == \"}\":\n        break\n\nprint(flag)\n</code></pre>","boost":0.8},{"location":"code_examples/example_nlinks/","title":"DEF CON Quals 2023 - nlinks","text":"<p>This is a script that solves the challenge nlinks from DEF CON Quals 2023. Please find the binary executables here. <pre><code>def get_passsphrase_from_class_1_binaries(previous_flag):\n    flag = b\"\"\n\n    d = debugger(\"CTF/1\")\n    r = d.run()\n\n    bp = d.breakpoint(0x7EF1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.recvuntil(b\"Passphrase:\\n\")\n\n    # We send a fake flag after the valid password\n    r.send(previous_flag + b\"a\" * 8)\n\n    for _ in range(8):\n        # Here we reached the breakpoint\n        if not bp.hit_on(d):\n            print(\"Here we should have hit the breakpoint\")\n\n        offset = ord(\"a\") ^ d.regs.rbp\n        d.regs.rbp = d.regs.r13\n\n        # We calculate the correct character value and append it to the flag\n        flag += (offset ^ d.regs.r13).to_bytes(1, \"little\")\n\n        d.cont()\n\n    r.recvline()\n\n    d.kill()\n\n    # Here the value of flag is b\"\\x00\\x006\\x00\\x00\\x00(\\x00\"\n    return flag\n\ndef get_passsphrase_from_class_2_binaries(previous_flag):\n    bitmap = {}\n    lastpos = 0\n    flag = b\"\"\n\n    d = debugger(\"CTF/2\")\n    r = d.run()\n\n    bp1 = d.breakpoint(0xD8C1, hardware=True, file=\"binary\")\n    bp2 = d.breakpoint(0x1858, hardware=True, file=\"binary\")\n    bp3 = d.breakpoint(0xDBA1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.recvuntil(b\"Passphrase:\\n\")\n    r.send(previous_flag + b\"a\" * 8)\n\n    while True:\n        if d.regs.rip == bp1.address:\n            # Prepare for the next element in the bitmap\n            lastpos = d.regs.rbp\n            d.regs.rbp = d.regs.r13 + 1\n        elif d.regs.rip == bp2.address:\n            # Update the bitmap\n            bitmap[d.regs.r12 &amp; 0xFF] = lastpos &amp; 0xFF\n        elif d.regs.rip == bp3.address:\n            # Use the bitmap to calculate the expected character\n            d.regs.rbp = d.regs.r13\n            wanted = d.regs.rbp\n            needed = 0\n            for i in range(8):\n                if wanted &amp; (2**i):\n                    needed |= bitmap[2**i]\n            flag += chr(needed).encode()\n\n            if bp3.hit_count == 8:\n                # We have found all the characters\n                d.cont()\n                break\n\n        d.cont()\n\n    d.kill()\n\n    # Here the value of flag is b\"\\x00\\x00\\x00\\x01\\x00\\x00a\\x00\"\n    return flag\n\ndef get_passsphrase_from_class_3_binaries():\n    flag = b\"\"\n\n    d = debugger(\"CTF/0\")\n    r = d.run()\n\n    bp = d.breakpoint(0x91A1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.send(b\"a\" * 8)\n\n    for _ in range(8):\n\n        # Here we reached the breakpoint\n        if not bp.hit_on(d):\n            print(\"Here we should have hit the breakpoint\")\n\n        offset = ord(\"a\") - d.regs.rbp\n        d.regs.rbp = d.regs.r13\n\n        # We calculate the correct character value and append it to the flag\n        flag += chr((d.regs.r13 + offset) % 256).encode(\"latin-1\")\n\n        d.cont()\n\n    r.recvline()\n\n    d.kill()\n\n    # Here the value of flag is b\"BM8\\xd3\\x02\\x00\\x00\\x00\"\n    return flag\n\ndef run_nlinks():\n    flag0 = get_passsphrase_from_class_3_binaries()\n    flag1 = get_passsphrase_from_class_1_binaries(flag0)\n    flag2 = get_passsphrase_from_class_2_binaries(flag1)\n\n    print(flag0, flag1, flag2)\n</code></pre></p>","boost":0.8},{"location":"code_examples/examples_index/","title":"Examples Index","text":"<p>This chapter contains a collection of examples showcasing the power of libdebug in various scenarios. Each example is a script that uses the library to solve a specific challenge or demonstrate a particular feature.</p>","boost":1},{"location":"code_examples/examples_sudo_kurl/","title":"Execution Hijacking Example - TRX CTF 2025","text":"<p>This code example shows how to hijack the exection flow of the program to retrieve the state of a Sudoku game and solve it with Z3. This is a challenge from the TRX CTF 2025. The full writeup, written by Luca Padalino (padawan), can be found here.</p>","boost":1},{"location":"code_examples/examples_sudo_kurl/#context-of-the-challenge","title":"Context of the challenge","text":"<p>The attachment is an AMD64 ELF binary that simulates a futuristic scenario where the New Roman Empire faces alien invaders. Upon execution, the program prompts users to deploy legions by specifying row and column indices, along with troop values, within a 25x25 grid. The goal is to determine the correct deployment strategy to secure victory against the alien threat. The constraints for the deployment are actually those of a Sudoku game. The challenge is to solve the Sudoku puzzle to deploy the legions correctly.</p> <p>The following table summarizes the main functions and their roles within the binary:</p> Function Description main() Prints the initial welcome message and then calls the game loop by invoking <code>play()</code>. play() Implements the main game loop: it repeatedly validates the board state via <code>isValid()</code>, collects user input using <code>askInput()</code>, and upon receiving the win-check signal (<code>-1</code>), verifies the board via <code>checkWin()</code>. Depending on the result, it either displays a defeat message or computes and prints the flag via <code>getFlag()</code>. isValid(board) Checks the board\u2019s validity (a 25\u00d725 grid) by verifying that each row, column, and 5\u00d75 sub-grid has correct values without duplicates\u2014akin to a Sudoku verification. askInput(board) Prompts the user to input a row, column, and number of troops (values between 1 and 25). It updates the board if the target cell is empty or shows an error if the cell is already occupied. Using <code>-1</code> for the row index signals that the user wants to check for a win. checkWin(board) Scans the board to ensure that no cell contains a 0 and that the board remains valid. It returns a status indicating whether the win condition has been met. getFlag(board) Processes the board along with an internal vector (named <code>A</code>) by splitting it into segments, performing matrix\u2013vector multiplications (via <code>matrixVectorMultiply()</code>), and converting the resulting numbers into characters to form the flag string. matrixVectorMultiply(matrix, vector) Multiplies a matrix with a vector and returns the result. This operation is used within <code>getFlag()</code> to transform part of the internal vector into a sequence that contributes to the flag. <p>This table provides an at-a-glance reference to the main functions and their roles within the binary.</p>","boost":1},{"location":"code_examples/examples_sudo_kurl/#the-solution","title":"The solution","text":"<p>The following is the initial state of the Sudoku board retrieved by the script:</p> <pre><code>initial_board = [\n    0,0,0,21,0,11,0,0,3,24,9,20,23,0,7,22,0,5,18,0,15,2,16,13,0,\n    24,4,0,20,15,0,0,5,0,16,2,25,22,0,17,6,21,0,14,0,8,10,1,19,18,\n    0,0,10,0,5,0,21,19,22,0,3,13,1,16,0,15,4,7,23,24,12,0,14,0,0,\n    0,0,13,6,12,14,4,1,0,0,24,18,19,5,0,0,17,0,0,0,7,22,0,9,21,\n    0,23,19,7,0,0,6,0,0,20,15,4,0,21,0,0,0,0,16,10,24,3,0,17,5,\n    12,15,21,0,0,0,16,6,18,5,7,0,17,3,9,14,0,4,24,22,13,0,0,0,0,\n    14,10,11,2,24,1,25,22,20,0,0,23,6,19,0,13,5,8,12,0,17,0,7,15,9,\n    0,0,0,0,1,24,0,3,15,10,20,8,5,0,25,9,16,19,21,0,2,6,0,12,14,\n    0,0,5,0,3,0,23,14,8,0,0,2,15,0,12,0,7,1,17,6,22,21,4,0,19,\n    13,0,0,4,20,0,0,0,17,0,11,16,0,0,22,0,10,18,15,23,0,25,8,1,3,\n    20,25,7,22,0,23,0,10,1,0,0,0,0,13,4,21,0,6,19,0,3,9,15,8,0,\n    1,24,0,0,0,4,0,20,13,0,8,0,3,0,19,16,2,12,9,5,0,14,10,25,22,\n    0,0,0,0,0,0,0,9,24,0,25,6,0,2,16,4,8,10,0,17,18,7,21,0,1,\n    0,8,0,10,14,16,3,25,6,0,0,7,18,9,11,0,13,0,20,0,19,24,5,0,17,\n    17,3,0,15,9,5,0,0,11,0,0,21,0,0,23,7,0,22,0,0,20,13,12,4,6,\n    15,0,20,11,21,10,0,0,5,22,16,0,0,8,3,24,0,13,2,19,0,0,0,0,0,\n    0,13,8,0,19,17,0,0,0,0,0,12,7,24,6,0,15,23,22,4,14,5,9,0,0,\n    9,1,23,14,4,0,24,0,7,8,19,0,2,0,13,17,3,20,5,0,0,15,0,16,10,\n    10,0,2,12,0,13,18,15,0,0,17,5,0,20,21,8,1,16,0,7,0,19,0,11,0,\n    7,5,17,24,16,20,2,11,19,3,23,0,4,15,1,18,14,0,10,0,0,8,13,21,12,\n    0,20,9,0,7,15,22,17,10,0,12,19,0,0,24,25,0,14,4,8,16,18,2,0,0,\n    19,2,24,8,0,0,20,7,4,0,0,0,9,0,15,5,0,21,11,16,1,0,0,14,25,\n    0,0,25,1,0,8,5,23,14,6,4,17,16,0,2,0,20,0,13,9,10,12,24,7,15,\n    0,0,14,0,0,0,0,0,0,2,6,10,13,0,5,12,0,24,0,0,9,11,0,3,8,\n    6,0,15,0,13,0,0,24,0,9,1,0,8,25,0,10,18,17,0,2,0,4,19,0,23\n]\n</code></pre> <p>The solution script uses libdebug to force the binary to print the state of the board. This state is then parsed and used to create a Z3 model that solves the Sudoku. The solution is then sent back to the binary to solve the game.</p> <pre><code>from z3 import *\nfrom libdebug import debugger\n\nd = debugger(\"./chall\")\npipe = d.run()\n\n# 0) Hijack the instruction pointer to the displayBoard function\n# Yes...the parenteses are part of the symbol name\nbp = d.breakpoint(\"play()+26\", file=\"binary\", hardware=True)\nwhile not d.dead:\n    d.cont()\n    d.wait()\n\n    if bp.hit_on(d.threads[0]):\n        d.step()\n        print(\"Hit on play()+0x26\")\n        d.regs.rip = d.maps[0].base + 0x2469\n\n# 1) Get information from the board\npipe.recvline(numlines=4)\ninitial_board = pipe.recvline(25).decode().strip().split(\" \")\ninitial_board = [int(x) if x != \".\" else 0 for x in initial_board]\n\nBOARD_SIZE = 25\nBOARD_STEP = 5\n\n# 2) Solve using Z3\ns = Solver()\n\n# 2.1) Create board\nboard = [[Int(f\"board_{i}_{j}\") for i in range(25)] for j in range(25)]\n# 2.2) Add constraints\nfor i in range(BOARD_SIZE):\n    for j in range(25):\n        # 2.2.1) All the numbers must be between 1 and 25\n        s.add(board[i][j] &gt;= 1, board[i][j] &lt;= 25)\n        # 2.2.2) If the number is already given, it must be the same     \n        if initial_board[i*25+j] != 0:\n            s.add(board[i][j] == initial_board[i*25+j])\n    # 2.2.3) All the numbers in the row must be different\n    s.add(Distinct(board[i]))\n    # 2.2.4) All the numbers in the column must be different\n    s.add(Distinct([board[j][i] for j in range(BOARD_SIZE)]))\n\n# 2.2.5) All the numbers in the 5x5 blocks must be different\nfor i in range(0, BOARD_SIZE, BOARD_STEP):\n    for j in range(0, BOARD_SIZE, BOARD_STEP):\n        block = [board[i+k][j+l] for k in range(BOARD_STEP) for l in range(BOARD_STEP)]\n        s.add(Distinct(block))\n\n# 2.3) Check if the board is solvable\nif s.check() == sat:\n    m = s.model()\n\n    # 3) Solve the game\n    pipe = d.run()\n    d.cont()\n    pipe.recvuntil(\"deploy.\\n\")\n\n    # Send found solution\n    for i in range(BOARD_SIZE):\n        for j in range(BOARD_SIZE):\n            if initial_board[i*25+j] == 0:\n                pipe.recvuntil(\": \")\n                pipe.sendline(f\"{i+1}\")\n                pipe.recvuntil(\": \")\n                pipe.sendline(f\"{j+1}\")\n                pipe.recvuntil(\": \")\n                pipe.sendline(str(m[board[i][j]]))\n                print(f\"Row {i+1} - Col {j+1}: {m[board[i][j]]}\")\n\n    pipe.recvuntil(\": \")\n    pipe.sendline(f\"0\")\n\n    # Receive final messages and the flag\n    print(pipe.recvline().decode())\n    print(pipe.recvline().decode())\n    print(pipe.recvline().decode())\n    print(pipe.recvline().decode())\n    print(pipe.recvline().decode())\nelse:\n    print(\"No solution found\")\n\nd.terminate()\n</code></pre>","boost":1},{"location":"from_pydoc/generated/architectures/thread_context_helper/","title":"libdebug.architectures.thread_context_helper","text":""},{"location":"from_pydoc/generated/architectures/thread_context_helper/#libdebug.architectures.thread_context_helper.thread_context_class_provider","title":"<code>thread_context_class_provider(architecture)</code>","text":"<p>Returns the class of the thread context to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/architectures/thread_context_helper.py</code> <pre><code>def thread_context_class_provider(\n    architecture: str,\n) -&gt; type[ThreadContext]:\n    \"\"\"Returns the class of the thread context to be used by the `_InternalDebugger` class.\"\"\"\n    match architecture:\n        case \"amd64\":\n            return Amd64ThreadContext\n        case \"aarch64\":\n            return Aarch64ThreadContext\n        case \"i386\":\n            if libcontext.platform == \"amd64\":\n                return I386OverAMD64ThreadContext\n            else:\n                return I386ThreadContext\n        case _:\n            raise NotImplementedError(f\"Architecture {architecture} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_thread_context/","title":"libdebug.architectures.aarch64.aarch64_thread_context","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_thread_context/#libdebug.architectures.aarch64.aarch64_thread_context.Aarch64ThreadContext","title":"<code>Aarch64ThreadContext</code>","text":"<p>               Bases: <code>ThreadContext</code></p> <p>This object represents a thread in the context of the target aarch64 process. It holds information about the thread's state, registers and stack.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_thread_context.py</code> <pre><code>class Aarch64ThreadContext(ThreadContext):\n    \"\"\"This object represents a thread in the context of the target aarch64 process. It holds information about the thread's state, registers and stack.\"\"\"\n\n    def __init__(self: Aarch64ThreadContext, thread_id: int, registers: Aarch64PtraceRegisterHolder) -&gt; None:\n        \"\"\"Initialize the thread context with the given thread id.\"\"\"\n        super().__init__(thread_id, registers)\n\n        # Register the thread properties\n        self._register_holder.apply_on_thread(self, Aarch64ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_thread_context/#libdebug.architectures.aarch64.aarch64_thread_context.Aarch64ThreadContext.__init__","title":"<code>__init__(thread_id, registers)</code>","text":"<p>Initialize the thread context with the given thread id.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_thread_context.py</code> <pre><code>def __init__(self: Aarch64ThreadContext, thread_id: int, registers: Aarch64PtraceRegisterHolder) -&gt; None:\n    \"\"\"Initialize the thread context with the given thread id.\"\"\"\n    super().__init__(thread_id, registers)\n\n    # Register the thread properties\n    self._register_holder.apply_on_thread(self, Aarch64ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_thread_context/","title":"libdebug.architectures.amd64.amd64_thread_context","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_thread_context/#libdebug.architectures.amd64.amd64_thread_context.Amd64ThreadContext","title":"<code>Amd64ThreadContext</code>","text":"<p>               Bases: <code>ThreadContext</code></p> <p>This object represents a thread in the context of the target amd64 process. It holds information about the thread's state, registers and stack.</p> Source code in <code>libdebug/architectures/amd64/amd64_thread_context.py</code> <pre><code>class Amd64ThreadContext(ThreadContext):\n    \"\"\"This object represents a thread in the context of the target amd64 process. It holds information about the thread's state, registers and stack.\"\"\"\n\n    def __init__(self: Amd64ThreadContext, thread_id: int, registers: Amd64PtraceRegisterHolder) -&gt; None:\n        \"\"\"Initialize the thread context with the given thread id.\"\"\"\n        super().__init__(thread_id, registers)\n\n        # Register the thread properties\n        self._register_holder.apply_on_thread(self, Amd64ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_thread_context/#libdebug.architectures.amd64.amd64_thread_context.Amd64ThreadContext.__init__","title":"<code>__init__(thread_id, registers)</code>","text":"<p>Initialize the thread context with the given thread id.</p> Source code in <code>libdebug/architectures/amd64/amd64_thread_context.py</code> <pre><code>def __init__(self: Amd64ThreadContext, thread_id: int, registers: Amd64PtraceRegisterHolder) -&gt; None:\n    \"\"\"Initialize the thread context with the given thread id.\"\"\"\n    super().__init__(thread_id, registers)\n\n    # Register the thread properties\n    self._register_holder.apply_on_thread(self, Amd64ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_thread_context/","title":"libdebug.architectures.amd64.compat.i386_over_amd64_thread_context","text":""},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_thread_context/#libdebug.architectures.amd64.compat.i386_over_amd64_thread_context.I386OverAMD64ThreadContext","title":"<code>I386OverAMD64ThreadContext</code>","text":"<p>               Bases: <code>ThreadContext</code></p> <p>This object represents a thread in the context of the target i386 process when running on amd64. It holds information about the thread's state, registers and stack.</p> Source code in <code>libdebug/architectures/amd64/compat/i386_over_amd64_thread_context.py</code> <pre><code>class I386OverAMD64ThreadContext(ThreadContext):\n    \"\"\"This object represents a thread in the context of the target i386 process when running on amd64. It holds information about the thread's state, registers and stack.\"\"\"\n\n    def __init__(\n        self: I386OverAMD64ThreadContext,\n        thread_id: int,\n        registers: I386OverAMD64PtraceRegisterHolder,\n    ) -&gt; None:\n        \"\"\"Initialize the thread context with the given thread id.\"\"\"\n        super().__init__(thread_id, registers)\n\n        # Register the thread properties\n        self._register_holder.apply_on_thread(self, I386OverAMD64ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_thread_context/#libdebug.architectures.amd64.compat.i386_over_amd64_thread_context.I386OverAMD64ThreadContext.__init__","title":"<code>__init__(thread_id, registers)</code>","text":"<p>Initialize the thread context with the given thread id.</p> Source code in <code>libdebug/architectures/amd64/compat/i386_over_amd64_thread_context.py</code> <pre><code>def __init__(\n    self: I386OverAMD64ThreadContext,\n    thread_id: int,\n    registers: I386OverAMD64PtraceRegisterHolder,\n) -&gt; None:\n    \"\"\"Initialize the thread context with the given thread id.\"\"\"\n    super().__init__(thread_id, registers)\n\n    # Register the thread properties\n    self._register_holder.apply_on_thread(self, I386OverAMD64ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_thread_context/","title":"libdebug.architectures.i386.i386_thread_context","text":""},{"location":"from_pydoc/generated/architectures/i386/i386_thread_context/#libdebug.architectures.i386.i386_thread_context.I386ThreadContext","title":"<code>I386ThreadContext</code>","text":"<p>               Bases: <code>ThreadContext</code></p> <p>This object represents a thread in the context of the target i386 process. It holds information about the thread's state, registers and stack.</p> Source code in <code>libdebug/architectures/i386/i386_thread_context.py</code> <pre><code>class I386ThreadContext(ThreadContext):\n    \"\"\"This object represents a thread in the context of the target i386 process. It holds information about the thread's state, registers and stack.\"\"\"\n\n    def __init__(self: I386ThreadContext, thread_id: int, registers: I386PtraceRegisterHolder) -&gt; None:\n        \"\"\"Initialize the thread context with the given thread id.\"\"\"\n        super().__init__(thread_id, registers)\n\n        # Register the thread properties\n        self._register_holder.apply_on_thread(self, I386ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_thread_context/#libdebug.architectures.i386.i386_thread_context.I386ThreadContext.__init__","title":"<code>__init__(thread_id, registers)</code>","text":"<p>Initialize the thread context with the given thread id.</p> Source code in <code>libdebug/architectures/i386/i386_thread_context.py</code> <pre><code>def __init__(self: I386ThreadContext, thread_id: int, registers: I386PtraceRegisterHolder) -&gt; None:\n    \"\"\"Initialize the thread context with the given thread id.\"\"\"\n    super().__init__(thread_id, registers)\n\n    # Register the thread properties\n    self._register_holder.apply_on_thread(self, I386ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/","title":"libdebug.snapshots.diff","text":""},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff","title":"<code>Diff</code>","text":"<p>This object represents a diff between two snapshots.</p> Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>class Diff:\n    \"\"\"This object represents a diff between two snapshots.\"\"\"\n\n    def __init__(self: Diff, snapshot1: Snapshot, snapshot2: Snapshot) -&gt; None:\n        \"\"\"Initialize the Diff object with two snapshots.\n\n        Args:\n            snapshot1 (Snapshot): The first snapshot.\n            snapshot2 (Snapshot): The second snapshot.\n        \"\"\"\n        if snapshot1.snapshot_id &lt; snapshot2.snapshot_id:\n            self.snapshot1 = snapshot1\n            self.snapshot2 = snapshot2\n        else:\n            self.snapshot1 = snapshot2\n            self.snapshot2 = snapshot1\n\n        # The level of the diff is the lowest level among the two snapshots\n        if snapshot1.level == \"base\" or snapshot2.level == \"base\":\n            self.level = \"base\"\n        elif snapshot1.level == \"writable\" or snapshot2.level == \"writable\":\n            self.level = \"writable\"\n        else:\n            self.level = \"full\"\n\n        if self.snapshot1.arch != self.snapshot2.arch:\n            raise ValueError(\"Snapshots have different architectures. Automatic diff is not supported.\")\n\n    def _save_reg_diffs(self: Snapshot) -&gt; None:\n        self.regs = RegisterDiffAccessor(\n            self.snapshot1.regs._generic_regs,\n            self.snapshot1.regs._special_regs,\n            self.snapshot1.regs._vec_fp_regs,\n        )\n\n        all_regs = dir(self.snapshot1.regs)\n        all_regs = [reg for reg in all_regs if isinstance(self.snapshot1.regs.__getattribute__(reg), int | float)]\n\n        for reg_name in all_regs:\n            old_value = self.snapshot1.regs.__getattribute__(reg_name)\n            new_value = self.snapshot2.regs.__getattribute__(reg_name)\n            has_changed = old_value != new_value\n\n            diff = RegisterDiff(\n                old_value=old_value,\n                new_value=new_value,\n                has_changed=has_changed,\n            )\n\n            # Create diff object\n            self.regs.__setattr__(reg_name, diff)\n\n    def _resolve_maps_diff(self: Diff) -&gt; None:\n        # Handle memory maps\n        all_maps_diffs = []\n        handled_map2_indices = []\n\n        for map1 in self.snapshot1.maps:\n            # Find the corresponding map in the second snapshot\n            map2 = None\n\n            for map2_index, candidate in enumerate(self.snapshot2.maps):\n                if map1.is_same_identity(candidate):\n                    map2 = candidate\n                    handled_map2_indices.append(map2_index)\n                    break\n\n            if map2 is None:\n                diff = MemoryMapDiff(\n                    old_map_state=map1,\n                    new_map_state=None,\n                    has_changed=True,\n                )\n            else:\n                diff = MemoryMapDiff(\n                    old_map_state=map1,\n                    new_map_state=map2,\n                    has_changed=(map1 != map2),\n                )\n\n            all_maps_diffs.append(diff)\n\n        new_pages = [self.snapshot2.maps[i] for i in range(len(self.snapshot2.maps)) if i not in handled_map2_indices]\n\n        for new_page in new_pages:\n            diff = MemoryMapDiff(\n                old_map_state=None,\n                new_map_state=new_page,\n                has_changed=True,\n            )\n\n            all_maps_diffs.append(diff)\n\n        # Convert the list to a MemoryMapDiffList\n        self.maps = MemoryMapDiffList(\n            all_maps_diffs,\n            self.snapshot1._process_name,\n            self.snapshot1._process_full_path,\n        )\n\n    @property\n    def registers(self: Snapshot) -&gt; SnapshotRegisters:\n        \"\"\"Alias for regs.\"\"\"\n        return self.regs\n\n    def pprint_maps(self: Diff) -&gt; None:\n        \"\"\"Pretty print the memory maps diff.\"\"\"\n        has_prev_changed = False\n\n        for diff in self.maps:\n            ref = diff.old_map_state if diff.old_map_state is not None else diff.new_map_state\n\n            map_state_str = \"\"\n            map_state_str += \"Memory Map:\\n\"\n            map_state_str += f\"    start: {ref.start:#x}\\n\"\n            map_state_str += f\"    end: {ref.end:#x}\\n\"\n            map_state_str += f\"    permissions: {ref.permissions}\\n\"\n            map_state_str += f\"    size: {ref.size:#x}\\n\"\n            map_state_str += f\"    offset: {ref.offset:#x}\\n\"\n            map_state_str += f\"    backing_file: {ref.backing_file}\\n\"\n\n            # If is added\n            if diff.old_map_state is None:\n                pprint_diff_line(map_state_str, is_added=True)\n\n                has_prev_changed = True\n            # If is removed\n            elif diff.new_map_state is None:\n                pprint_diff_line(map_state_str, is_added=False)\n\n                has_prev_changed = True\n            elif diff.old_map_state.end != diff.new_map_state.end:\n                printed_line = map_state_str\n\n                new_map_end = diff.new_map_state.end\n\n                start_strike = printed_line.find(\"end:\") + 4\n                end_strike = printed_line.find(\"\\n\", start_strike)\n\n                pprint_inline_diff(printed_line, start_strike, end_strike, f\"{hex(new_map_end)}\")\n\n                has_prev_changed = True\n            elif diff.old_map_state.permissions != diff.new_map_state.permissions:\n                printed_line = map_state_str\n\n                new_map_permissions = diff.new_map_state.permissions\n\n                start_strike = printed_line.find(\"permissions:\") + 12\n                end_strike = printed_line.find(\"\\n\", start_strike)\n\n                pprint_inline_diff(printed_line, start_strike, end_strike, new_map_permissions)\n\n                has_prev_changed = True\n            elif diff.old_map_state.content != diff.new_map_state.content:\n                printed_line = map_state_str + \"    [content changed]\\n\"\n                color_start = printed_line.find(\"[content changed]\")\n\n                pprint_diff_substring(printed_line, color_start, color_start + len(\"[content changed]\"))\n\n                has_prev_changed = True\n            else:\n                if has_prev_changed:\n                    print(\"\\n[...]\\n\")\n\n                has_prev_changed = False\n\n    def pprint_memory(\n        self: Diff,\n        start: int,\n        end: int,\n        file: str = \"hybrid\",\n        override_word_size: int = None,\n        integer_mode: bool = False,\n    ) -&gt; None:\n        \"\"\"Pretty print the memory diff.\n\n        Args:\n            start (int): The start address of the memory diff.\n            end (int): The end address of the memory diff.\n            file (str, optional): The backing file for relative / absolute addressing. Defaults to \"hybrid\".\n            override_word_size (int, optional): The word size to use for the diff in place of the ISA word size. Defaults to None.\n            integer_mode (bool, optional): If True, the diff will be printed as hex integers (system endianness applies). Defaults to False.\n        \"\"\"\n        if self.level == \"base\":\n            raise ValueError(\"Memory diff is not available at base snapshot level.\")\n\n        if start &gt; end:\n            tmp = start\n            start = end\n            end = tmp\n\n        word_size = (\n            get_platform_gp_register_size(self.snapshot1.arch) if override_word_size is None else override_word_size\n        )\n\n        # Resolve the address\n        if file == \"absolute\":\n            address_start = start\n        elif file == \"hybrid\":\n            try:\n                # Try to resolve the address as absolute\n                self.snapshot1.memory[start, 1, \"absolute\"]\n                address_start = start\n            except ValueError:\n                # If the address is not in the maps, we use the binary file\n                address_start = start + self.snapshot1.maps.filter(\"binary\")[0].start\n                file = \"binary\"\n        else:\n            map_file = self.snapshot1.maps.filter(file)[0]\n            address_start = start + map_file.base\n            file = map_file.backing_file if file != \"binary\" else \"binary\"\n\n        extract_before = self.snapshot1.memory[start:end, file]\n        extract_after = self.snapshot2.memory[start:end, file]\n\n        file_info = f\" (file: {file})\" if file not in (\"absolute\", \"hybrid\") else \"\"\n        print(f\"Memory diff from {start:#x} to {end:#x}{file_info}:\")\n\n        pprint_memory_diff_util(\n            address_start,\n            extract_before,\n            extract_after,\n            word_size,\n            self.snapshot1.maps,\n            integer_mode=integer_mode,\n        )\n\n    def pprint_regs(self: Diff) -&gt; None:\n        \"\"\"Pretty print the general_purpose registers diffs.\"\"\"\n        # Header with column alignment\n        print(\"{:&lt;19} {:&lt;24} {:&lt;20}\\n\".format(\"Register\", \"Old Value\", \"New Value\"))\n        print(\"-\" * 58 + \"\")\n\n        # Log all integer changes\n        for attr_name in self.regs._generic_regs:\n            attr = self.regs.__getattribute__(attr_name)\n\n            if attr.has_changed:\n                pprint_reg_diff_util(\n                    attr_name,\n                    self.snapshot1.maps,\n                    self.snapshot2.maps,\n                    attr.old_value,\n                    attr.new_value,\n                )\n\n    def pprint_regs_all(self: Diff) -&gt; None:\n        \"\"\"Pretty print the registers diffs (including special and vector registers).\"\"\"\n        # Header with column alignment\n        print(\"{:&lt;19} {:&lt;24} {:&lt;20}\\n\".format(\"Register\", \"Old Value\", \"New Value\"))\n        print(\"-\" * 58 + \"\")\n\n        # Log all integer changes\n        for attr_name in self.regs._generic_regs + self.regs._special_regs:\n            attr = self.regs.__getattribute__(attr_name)\n\n            if attr.has_changed:\n                pprint_reg_diff_util(\n                    attr_name,\n                    self.snapshot1.maps,\n                    self.snapshot2.maps,\n                    attr.old_value,\n                    attr.new_value,\n                )\n\n        print()\n\n        # Log all vector changes\n        for attr1_name, attr2_name in self.regs._vec_fp_regs:\n            attr1 = self.regs.__getattribute__(attr1_name)\n            attr2 = self.regs.__getattribute__(attr2_name)\n\n            if attr1.has_changed or attr2.has_changed:\n                pprint_reg_diff_large_util(\n                    (attr1_name, attr2_name),\n                    (attr1.old_value, attr2.old_value),\n                    (attr1.new_value, attr2.new_value),\n                )\n\n    def pprint_registers(self: Diff) -&gt; None:\n        \"\"\"Alias afor pprint_regs.\"\"\"\n        self.pprint_regs()\n\n    def pprint_registers_all(self: Diff) -&gt; None:\n        \"\"\"Alias for pprint_regs_all.\"\"\"\n        self.pprint_regs_all()\n\n    def pprint_backtrace(self: Diff) -&gt; None:\n        \"\"\"Pretty print the backtrace diff.\"\"\"\n        if self.level == \"base\":\n            raise ValueError(\"Backtrace is not available at base level. Stack is not available\")\n\n        prev_log_level = libcontext.general_logger\n        libcontext.general_logger = \"SILENT\"\n        stack_unwinder = stack_unwinding_provider(self.snapshot1.arch)\n        backtrace1 = stack_unwinder.unwind(self.snapshot1)\n        backtrace2 = stack_unwinder.unwind(self.snapshot2)\n\n        maps1 = self.snapshot1.maps\n        maps2 = self.snapshot2.maps\n\n        symbols = self.snapshot1.memory._symbol_ref\n\n        # Columns are Before, Unchanged, After\n        #  __    __\n        # |__|  |__|\n        # |__|  |__|\n        # |__|__|__|\n        # |__|__|__|\n        # |__|__|__|\n        column1 = []\n        column2 = []\n        column3 = []\n\n        for addr1, addr2 in zip_longest(reversed(backtrace1), reversed(backtrace2)):\n            col1 = get_colored_saved_address_util(addr1, maps1, symbols).strip() if addr1 else None\n            col2 = None\n            col3 = None\n\n            if addr2:\n                if addr1 == addr2:\n                    col2 = col1\n                    col1 = None\n                else:\n                    col3 = get_colored_saved_address_util(addr2, maps2, symbols).strip()\n\n            column1.append(col1)\n            column2.append(col2)\n            column3.append(col3)\n\n        max_str_len = max([len(x) if x else 0 for x in column1 + column2 + column3])\n\n        print(\"Backtrace diff:\")\n        print(\"-\" * (max_str_len * 3 + 6))\n        print(f\"{'Before':&lt;{max_str_len}} | {'Unchanged':&lt;{max_str_len}} | {'After':&lt;{max_str_len}}\")\n        for col1_val, col2_val, col3_val in zip(reversed(column1), reversed(column2), reversed(column3), strict=False):\n            col1 = pad_colored_string(col1_val, max_str_len) if col1_val else \" \" * max_str_len\n            col2 = pad_colored_string(col2_val, max_str_len) if col2_val else \" \" * max_str_len\n            col3 = pad_colored_string(col3_val, max_str_len) if col3_val else \" \" * max_str_len\n\n            print(f\"{col1} | {col2} | {col3}\")\n\n        print(\"-\" * (max_str_len * 3 + 6))\n\n        libcontext.general_logger = prev_log_level\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.registers","title":"<code>registers</code>  <code>property</code>","text":"<p>Alias for regs.</p>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.__init__","title":"<code>__init__(snapshot1, snapshot2)</code>","text":"<p>Initialize the Diff object with two snapshots.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot1</code> <code>Snapshot</code> <p>The first snapshot.</p> required <code>snapshot2</code> <code>Snapshot</code> <p>The second snapshot.</p> required Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>def __init__(self: Diff, snapshot1: Snapshot, snapshot2: Snapshot) -&gt; None:\n    \"\"\"Initialize the Diff object with two snapshots.\n\n    Args:\n        snapshot1 (Snapshot): The first snapshot.\n        snapshot2 (Snapshot): The second snapshot.\n    \"\"\"\n    if snapshot1.snapshot_id &lt; snapshot2.snapshot_id:\n        self.snapshot1 = snapshot1\n        self.snapshot2 = snapshot2\n    else:\n        self.snapshot1 = snapshot2\n        self.snapshot2 = snapshot1\n\n    # The level of the diff is the lowest level among the two snapshots\n    if snapshot1.level == \"base\" or snapshot2.level == \"base\":\n        self.level = \"base\"\n    elif snapshot1.level == \"writable\" or snapshot2.level == \"writable\":\n        self.level = \"writable\"\n    else:\n        self.level = \"full\"\n\n    if self.snapshot1.arch != self.snapshot2.arch:\n        raise ValueError(\"Snapshots have different architectures. Automatic diff is not supported.\")\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.pprint_backtrace","title":"<code>pprint_backtrace()</code>","text":"<p>Pretty print the backtrace diff.</p> Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>def pprint_backtrace(self: Diff) -&gt; None:\n    \"\"\"Pretty print the backtrace diff.\"\"\"\n    if self.level == \"base\":\n        raise ValueError(\"Backtrace is not available at base level. Stack is not available\")\n\n    prev_log_level = libcontext.general_logger\n    libcontext.general_logger = \"SILENT\"\n    stack_unwinder = stack_unwinding_provider(self.snapshot1.arch)\n    backtrace1 = stack_unwinder.unwind(self.snapshot1)\n    backtrace2 = stack_unwinder.unwind(self.snapshot2)\n\n    maps1 = self.snapshot1.maps\n    maps2 = self.snapshot2.maps\n\n    symbols = self.snapshot1.memory._symbol_ref\n\n    # Columns are Before, Unchanged, After\n    #  __    __\n    # |__|  |__|\n    # |__|  |__|\n    # |__|__|__|\n    # |__|__|__|\n    # |__|__|__|\n    column1 = []\n    column2 = []\n    column3 = []\n\n    for addr1, addr2 in zip_longest(reversed(backtrace1), reversed(backtrace2)):\n        col1 = get_colored_saved_address_util(addr1, maps1, symbols).strip() if addr1 else None\n        col2 = None\n        col3 = None\n\n        if addr2:\n            if addr1 == addr2:\n                col2 = col1\n                col1 = None\n            else:\n                col3 = get_colored_saved_address_util(addr2, maps2, symbols).strip()\n\n        column1.append(col1)\n        column2.append(col2)\n        column3.append(col3)\n\n    max_str_len = max([len(x) if x else 0 for x in column1 + column2 + column3])\n\n    print(\"Backtrace diff:\")\n    print(\"-\" * (max_str_len * 3 + 6))\n    print(f\"{'Before':&lt;{max_str_len}} | {'Unchanged':&lt;{max_str_len}} | {'After':&lt;{max_str_len}}\")\n    for col1_val, col2_val, col3_val in zip(reversed(column1), reversed(column2), reversed(column3), strict=False):\n        col1 = pad_colored_string(col1_val, max_str_len) if col1_val else \" \" * max_str_len\n        col2 = pad_colored_string(col2_val, max_str_len) if col2_val else \" \" * max_str_len\n        col3 = pad_colored_string(col3_val, max_str_len) if col3_val else \" \" * max_str_len\n\n        print(f\"{col1} | {col2} | {col3}\")\n\n    print(\"-\" * (max_str_len * 3 + 6))\n\n    libcontext.general_logger = prev_log_level\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.pprint_maps","title":"<code>pprint_maps()</code>","text":"<p>Pretty print the memory maps diff.</p> Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>def pprint_maps(self: Diff) -&gt; None:\n    \"\"\"Pretty print the memory maps diff.\"\"\"\n    has_prev_changed = False\n\n    for diff in self.maps:\n        ref = diff.old_map_state if diff.old_map_state is not None else diff.new_map_state\n\n        map_state_str = \"\"\n        map_state_str += \"Memory Map:\\n\"\n        map_state_str += f\"    start: {ref.start:#x}\\n\"\n        map_state_str += f\"    end: {ref.end:#x}\\n\"\n        map_state_str += f\"    permissions: {ref.permissions}\\n\"\n        map_state_str += f\"    size: {ref.size:#x}\\n\"\n        map_state_str += f\"    offset: {ref.offset:#x}\\n\"\n        map_state_str += f\"    backing_file: {ref.backing_file}\\n\"\n\n        # If is added\n        if diff.old_map_state is None:\n            pprint_diff_line(map_state_str, is_added=True)\n\n            has_prev_changed = True\n        # If is removed\n        elif diff.new_map_state is None:\n            pprint_diff_line(map_state_str, is_added=False)\n\n            has_prev_changed = True\n        elif diff.old_map_state.end != diff.new_map_state.end:\n            printed_line = map_state_str\n\n            new_map_end = diff.new_map_state.end\n\n            start_strike = printed_line.find(\"end:\") + 4\n            end_strike = printed_line.find(\"\\n\", start_strike)\n\n            pprint_inline_diff(printed_line, start_strike, end_strike, f\"{hex(new_map_end)}\")\n\n            has_prev_changed = True\n        elif diff.old_map_state.permissions != diff.new_map_state.permissions:\n            printed_line = map_state_str\n\n            new_map_permissions = diff.new_map_state.permissions\n\n            start_strike = printed_line.find(\"permissions:\") + 12\n            end_strike = printed_line.find(\"\\n\", start_strike)\n\n            pprint_inline_diff(printed_line, start_strike, end_strike, new_map_permissions)\n\n            has_prev_changed = True\n        elif diff.old_map_state.content != diff.new_map_state.content:\n            printed_line = map_state_str + \"    [content changed]\\n\"\n            color_start = printed_line.find(\"[content changed]\")\n\n            pprint_diff_substring(printed_line, color_start, color_start + len(\"[content changed]\"))\n\n            has_prev_changed = True\n        else:\n            if has_prev_changed:\n                print(\"\\n[...]\\n\")\n\n            has_prev_changed = False\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.pprint_memory","title":"<code>pprint_memory(start, end, file='hybrid', override_word_size=None, integer_mode=False)</code>","text":"<p>Pretty print the memory diff.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The start address of the memory diff.</p> required <code>end</code> <code>int</code> <p>The end address of the memory diff.</p> required <code>file</code> <code>str</code> <p>The backing file for relative / absolute addressing. Defaults to \"hybrid\".</p> <code>'hybrid'</code> <code>override_word_size</code> <code>int</code> <p>The word size to use for the diff in place of the ISA word size. Defaults to None.</p> <code>None</code> <code>integer_mode</code> <code>bool</code> <p>If True, the diff will be printed as hex integers (system endianness applies). Defaults to False.</p> <code>False</code> Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>def pprint_memory(\n    self: Diff,\n    start: int,\n    end: int,\n    file: str = \"hybrid\",\n    override_word_size: int = None,\n    integer_mode: bool = False,\n) -&gt; None:\n    \"\"\"Pretty print the memory diff.\n\n    Args:\n        start (int): The start address of the memory diff.\n        end (int): The end address of the memory diff.\n        file (str, optional): The backing file for relative / absolute addressing. Defaults to \"hybrid\".\n        override_word_size (int, optional): The word size to use for the diff in place of the ISA word size. Defaults to None.\n        integer_mode (bool, optional): If True, the diff will be printed as hex integers (system endianness applies). Defaults to False.\n    \"\"\"\n    if self.level == \"base\":\n        raise ValueError(\"Memory diff is not available at base snapshot level.\")\n\n    if start &gt; end:\n        tmp = start\n        start = end\n        end = tmp\n\n    word_size = (\n        get_platform_gp_register_size(self.snapshot1.arch) if override_word_size is None else override_word_size\n    )\n\n    # Resolve the address\n    if file == \"absolute\":\n        address_start = start\n    elif file == \"hybrid\":\n        try:\n            # Try to resolve the address as absolute\n            self.snapshot1.memory[start, 1, \"absolute\"]\n            address_start = start\n        except ValueError:\n            # If the address is not in the maps, we use the binary file\n            address_start = start + self.snapshot1.maps.filter(\"binary\")[0].start\n            file = \"binary\"\n    else:\n        map_file = self.snapshot1.maps.filter(file)[0]\n        address_start = start + map_file.base\n        file = map_file.backing_file if file != \"binary\" else \"binary\"\n\n    extract_before = self.snapshot1.memory[start:end, file]\n    extract_after = self.snapshot2.memory[start:end, file]\n\n    file_info = f\" (file: {file})\" if file not in (\"absolute\", \"hybrid\") else \"\"\n    print(f\"Memory diff from {start:#x} to {end:#x}{file_info}:\")\n\n    pprint_memory_diff_util(\n        address_start,\n        extract_before,\n        extract_after,\n        word_size,\n        self.snapshot1.maps,\n        integer_mode=integer_mode,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.pprint_registers","title":"<code>pprint_registers()</code>","text":"<p>Alias afor pprint_regs.</p> Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>def pprint_registers(self: Diff) -&gt; None:\n    \"\"\"Alias afor pprint_regs.\"\"\"\n    self.pprint_regs()\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.pprint_registers_all","title":"<code>pprint_registers_all()</code>","text":"<p>Alias for pprint_regs_all.</p> Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>def pprint_registers_all(self: Diff) -&gt; None:\n    \"\"\"Alias for pprint_regs_all.\"\"\"\n    self.pprint_regs_all()\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.pprint_regs","title":"<code>pprint_regs()</code>","text":"<p>Pretty print the general_purpose registers diffs.</p> Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>def pprint_regs(self: Diff) -&gt; None:\n    \"\"\"Pretty print the general_purpose registers diffs.\"\"\"\n    # Header with column alignment\n    print(\"{:&lt;19} {:&lt;24} {:&lt;20}\\n\".format(\"Register\", \"Old Value\", \"New Value\"))\n    print(\"-\" * 58 + \"\")\n\n    # Log all integer changes\n    for attr_name in self.regs._generic_regs:\n        attr = self.regs.__getattribute__(attr_name)\n\n        if attr.has_changed:\n            pprint_reg_diff_util(\n                attr_name,\n                self.snapshot1.maps,\n                self.snapshot2.maps,\n                attr.old_value,\n                attr.new_value,\n            )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/diff/#libdebug.snapshots.diff.Diff.pprint_regs_all","title":"<code>pprint_regs_all()</code>","text":"<p>Pretty print the registers diffs (including special and vector registers).</p> Source code in <code>libdebug/snapshots/diff.py</code> <pre><code>def pprint_regs_all(self: Diff) -&gt; None:\n    \"\"\"Pretty print the registers diffs (including special and vector registers).\"\"\"\n    # Header with column alignment\n    print(\"{:&lt;19} {:&lt;24} {:&lt;20}\\n\".format(\"Register\", \"Old Value\", \"New Value\"))\n    print(\"-\" * 58 + \"\")\n\n    # Log all integer changes\n    for attr_name in self.regs._generic_regs + self.regs._special_regs:\n        attr = self.regs.__getattribute__(attr_name)\n\n        if attr.has_changed:\n            pprint_reg_diff_util(\n                attr_name,\n                self.snapshot1.maps,\n                self.snapshot2.maps,\n                attr.old_value,\n                attr.new_value,\n            )\n\n    print()\n\n    # Log all vector changes\n    for attr1_name, attr2_name in self.regs._vec_fp_regs:\n        attr1 = self.regs.__getattribute__(attr1_name)\n        attr2 = self.regs.__getattribute__(attr2_name)\n\n        if attr1.has_changed or attr2.has_changed:\n            pprint_reg_diff_large_util(\n                (attr1_name, attr2_name),\n                (attr1.old_value, attr2.old_value),\n                (attr1.new_value, attr2.new_value),\n            )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/","title":"libdebug.snapshots.snapshot","text":""},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot","title":"<code>Snapshot</code>","text":"<p>This object represents a snapshot of a system task.</p> <p>Snapshot levels: - base: Registers - writable: Registers, writable memory contents - full: Registers, all readable memory contents</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>class Snapshot:\n    \"\"\"This object represents a snapshot of a system task.\n\n    Snapshot levels:\n    - base: Registers\n    - writable: Registers, writable memory contents\n    - full: Registers, all readable memory contents\n    \"\"\"\n\n    def _save_regs(self: Snapshot, thread: ThreadContext) -&gt; None:\n        # Create a register field for the snapshot\n        self.regs = SnapshotRegisters(\n            thread.thread_id,\n            thread._register_holder.provide_regs(),\n            thread._register_holder.provide_special_regs(),\n            thread._register_holder.provide_vector_fp_regs(),\n        )\n\n        # Set all registers in the field\n        all_regs = dir(thread.regs)\n        all_regs = [reg for reg in all_regs if isinstance(thread.regs.__getattribute__(reg), int | float)]\n\n        for reg_name in all_regs:\n            reg_value = thread.regs.__getattribute__(reg_name)\n            self.regs.__setattr__(reg_name, reg_value)\n\n    def _save_memory_maps(self: Snapshot, debugger: InternalDebugger, writable_only: bool) -&gt; None:\n        \"\"\"Saves memory maps of the process to the snapshot.\"\"\"\n        process_name = debugger._process_name\n        full_process_path = debugger._process_full_path\n        self.maps = MemoryMapSnapshotList([], process_name, full_process_path)\n\n        for curr_map in debugger.maps:\n            # Skip non-writable maps if requested\n            # Always skip maps that fail on read\n            if not writable_only or \"w\" in curr_map.permissions:\n                try:\n                    contents = debugger.memory[curr_map.start : curr_map.end, \"absolute\"]\n                except (ValueError, OSError, OverflowError):\n                    # There are some memory regions that cannot be read, such as [vvar], [vdso], etc.\n                    contents = None\n            else:\n                contents = None\n\n            saved_map = MemoryMapSnapshot(\n                curr_map.start,\n                curr_map.end,\n                curr_map.permissions,\n                curr_map.size,\n                curr_map.offset,\n                curr_map.backing_file,\n                contents,\n            )\n            self.maps.append(saved_map)\n\n    @property\n    def registers(self: Snapshot) -&gt; SnapshotRegisters:\n        \"\"\"Alias for regs.\"\"\"\n        return self.regs\n\n    @property\n    def memory(self: Snapshot) -&gt; SnapshotMemoryView:\n        \"\"\"Returns a view of the memory of the thread.\"\"\"\n        if self._memory is None:\n            if self.level != \"base\":\n                liblog.error(\"Inconsistent snapshot state: memory snapshot is not available.\")\n\n            raise ValueError(\"Memory snapshot is not available at base level.\")\n\n        return self._memory\n\n    @property\n    def mem(self: Snapshot) -&gt; SnapshotMemoryView:\n        \"\"\"Alias for memory.\"\"\"\n        return self.memory\n\n    @abstractmethod\n    def diff(self: Snapshot, other: Snapshot) -&gt; Diff:\n        \"\"\"Creates a diff object between two snapshots.\"\"\"\n\n    def save(self: Snapshot, file_path: str) -&gt; None:\n        \"\"\"Saves the snapshot object to a file.\"\"\"\n        self._serialization_helper.save(self, file_path)\n\n    def backtrace(self: Snapshot) -&gt; list[int]:\n        \"\"\"Returns the current backtrace of the thread.\"\"\"\n        if self.level == \"base\":\n            raise ValueError(\"Backtrace is not available at base level. Stack is not available.\")\n\n        stack_unwinder = stack_unwinding_provider(self.arch)\n        return stack_unwinder.unwind(self)\n\n    def pprint_registers(self: Snapshot) -&gt; None:\n        \"\"\"Pretty prints the thread's registers.\"\"\"\n        pprint_registers_util(self.regs, self.maps, self.regs._generic_regs)\n\n    def pprint_regs(self: Snapshot) -&gt; None:\n        \"\"\"Alias for the `pprint_registers` method.\n\n        Pretty prints the thread's registers.\n        \"\"\"\n        self.pprint_registers()\n\n    def pprint_registers_all(self: Snapshot) -&gt; None:\n        \"\"\"Pretty prints all the thread's registers.\"\"\"\n        pprint_registers_all_util(\n            self.regs,\n            self.maps,\n            self.regs._generic_regs,\n            self.regs._special_regs,\n            self.regs._vec_fp_regs,\n        )\n\n    def pprint_regs_all(self: Snapshot) -&gt; None:\n        \"\"\"Alias for the `pprint_registers_all` method.\n\n        Pretty prints all the thread's registers.\n        \"\"\"\n        self.pprint_registers_all()\n\n    def pprint_backtrace(self: ThreadContext) -&gt; None:\n        \"\"\"Pretty prints the current backtrace of the thread.\"\"\"\n        if self.level == \"base\":\n            raise ValueError(\"Backtrace is not available at base level. Stack is not available.\")\n\n        stack_unwinder = stack_unwinding_provider(self.arch)\n        backtrace = stack_unwinder.unwind(self)\n        pprint_backtrace_util(backtrace, self.maps, self._memory._symbol_ref)\n\n    def pprint_maps(self: Snapshot) -&gt; None:\n        \"\"\"Prints the memory maps of the process.\"\"\"\n        pprint_maps_util(self.maps)\n\n    def pprint_memory(\n        self: Snapshot,\n        start: int,\n        end: int,\n        file: str = \"hybrid\",\n        override_word_size: int | None = None,\n        integer_mode: bool = False,\n    ) -&gt; None:\n        \"\"\"Pretty print the memory diff.\n\n        Args:\n            start (int): The start address of the memory diff.\n            end (int): The end address of the memory diff.\n            file (str, optional): The backing file for relative / absolute addressing. Defaults to \"hybrid\".\n            override_word_size (int, optional): The word size to use for the diff in place of the ISA word size. Defaults to None.\n            integer_mode (bool, optional): If True, the diff will be printed as hex integers (system endianness applies). Defaults to False.\n        \"\"\"\n        if self.level == \"base\":\n            raise ValueError(\"Memory is not available at base level.\")\n\n        if start &gt; end:\n            tmp = start\n            start = end\n            end = tmp\n\n        word_size = get_platform_gp_register_size(self.arch) if override_word_size is None else override_word_size\n\n        # Resolve the address\n        if file == \"absolute\":\n            address_start = start\n        elif file == \"hybrid\":\n            try:\n                # Try to resolve the address as absolute\n                self.memory[start, 1, \"absolute\"]\n                address_start = start\n            except ValueError:\n                # If the address is not in the maps, we use the binary file\n                address_start = start + self.maps.filter(\"binary\")[0].start\n                file = \"binary\"\n        else:\n            map_file = self.maps.filter(file)[0]\n            address_start = start + map_file.base\n            file = map_file.backing_file if file != \"binary\" else \"binary\"\n\n        extract = self.memory[start:end, file]\n\n        file_info = f\" (file: {file})\" if file not in (\"absolute\", \"hybrid\") else \"\"\n        print(f\"Memory from {start:#x} to {end:#x}{file_info}:\")\n\n        pprint_memory_util(\n            address_start,\n            extract,\n            word_size,\n            self.maps,\n            integer_mode=integer_mode,\n        )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.mem","title":"<code>mem</code>  <code>property</code>","text":"<p>Alias for memory.</p>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.memory","title":"<code>memory</code>  <code>property</code>","text":"<p>Returns a view of the memory of the thread.</p>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.registers","title":"<code>registers</code>  <code>property</code>","text":"<p>Alias for regs.</p>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot._save_memory_maps","title":"<code>_save_memory_maps(debugger, writable_only)</code>","text":"<p>Saves memory maps of the process to the snapshot.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def _save_memory_maps(self: Snapshot, debugger: InternalDebugger, writable_only: bool) -&gt; None:\n    \"\"\"Saves memory maps of the process to the snapshot.\"\"\"\n    process_name = debugger._process_name\n    full_process_path = debugger._process_full_path\n    self.maps = MemoryMapSnapshotList([], process_name, full_process_path)\n\n    for curr_map in debugger.maps:\n        # Skip non-writable maps if requested\n        # Always skip maps that fail on read\n        if not writable_only or \"w\" in curr_map.permissions:\n            try:\n                contents = debugger.memory[curr_map.start : curr_map.end, \"absolute\"]\n            except (ValueError, OSError, OverflowError):\n                # There are some memory regions that cannot be read, such as [vvar], [vdso], etc.\n                contents = None\n        else:\n            contents = None\n\n        saved_map = MemoryMapSnapshot(\n            curr_map.start,\n            curr_map.end,\n            curr_map.permissions,\n            curr_map.size,\n            curr_map.offset,\n            curr_map.backing_file,\n            contents,\n        )\n        self.maps.append(saved_map)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.backtrace","title":"<code>backtrace()</code>","text":"<p>Returns the current backtrace of the thread.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def backtrace(self: Snapshot) -&gt; list[int]:\n    \"\"\"Returns the current backtrace of the thread.\"\"\"\n    if self.level == \"base\":\n        raise ValueError(\"Backtrace is not available at base level. Stack is not available.\")\n\n    stack_unwinder = stack_unwinding_provider(self.arch)\n    return stack_unwinder.unwind(self)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.diff","title":"<code>diff(other)</code>  <code>abstractmethod</code>","text":"<p>Creates a diff object between two snapshots.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>@abstractmethod\ndef diff(self: Snapshot, other: Snapshot) -&gt; Diff:\n    \"\"\"Creates a diff object between two snapshots.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.pprint_backtrace","title":"<code>pprint_backtrace()</code>","text":"<p>Pretty prints the current backtrace of the thread.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def pprint_backtrace(self: ThreadContext) -&gt; None:\n    \"\"\"Pretty prints the current backtrace of the thread.\"\"\"\n    if self.level == \"base\":\n        raise ValueError(\"Backtrace is not available at base level. Stack is not available.\")\n\n    stack_unwinder = stack_unwinding_provider(self.arch)\n    backtrace = stack_unwinder.unwind(self)\n    pprint_backtrace_util(backtrace, self.maps, self._memory._symbol_ref)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.pprint_maps","title":"<code>pprint_maps()</code>","text":"<p>Prints the memory maps of the process.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def pprint_maps(self: Snapshot) -&gt; None:\n    \"\"\"Prints the memory maps of the process.\"\"\"\n    pprint_maps_util(self.maps)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.pprint_memory","title":"<code>pprint_memory(start, end, file='hybrid', override_word_size=None, integer_mode=False)</code>","text":"<p>Pretty print the memory diff.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>int</code> <p>The start address of the memory diff.</p> required <code>end</code> <code>int</code> <p>The end address of the memory diff.</p> required <code>file</code> <code>str</code> <p>The backing file for relative / absolute addressing. Defaults to \"hybrid\".</p> <code>'hybrid'</code> <code>override_word_size</code> <code>int</code> <p>The word size to use for the diff in place of the ISA word size. Defaults to None.</p> <code>None</code> <code>integer_mode</code> <code>bool</code> <p>If True, the diff will be printed as hex integers (system endianness applies). Defaults to False.</p> <code>False</code> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def pprint_memory(\n    self: Snapshot,\n    start: int,\n    end: int,\n    file: str = \"hybrid\",\n    override_word_size: int | None = None,\n    integer_mode: bool = False,\n) -&gt; None:\n    \"\"\"Pretty print the memory diff.\n\n    Args:\n        start (int): The start address of the memory diff.\n        end (int): The end address of the memory diff.\n        file (str, optional): The backing file for relative / absolute addressing. Defaults to \"hybrid\".\n        override_word_size (int, optional): The word size to use for the diff in place of the ISA word size. Defaults to None.\n        integer_mode (bool, optional): If True, the diff will be printed as hex integers (system endianness applies). Defaults to False.\n    \"\"\"\n    if self.level == \"base\":\n        raise ValueError(\"Memory is not available at base level.\")\n\n    if start &gt; end:\n        tmp = start\n        start = end\n        end = tmp\n\n    word_size = get_platform_gp_register_size(self.arch) if override_word_size is None else override_word_size\n\n    # Resolve the address\n    if file == \"absolute\":\n        address_start = start\n    elif file == \"hybrid\":\n        try:\n            # Try to resolve the address as absolute\n            self.memory[start, 1, \"absolute\"]\n            address_start = start\n        except ValueError:\n            # If the address is not in the maps, we use the binary file\n            address_start = start + self.maps.filter(\"binary\")[0].start\n            file = \"binary\"\n    else:\n        map_file = self.maps.filter(file)[0]\n        address_start = start + map_file.base\n        file = map_file.backing_file if file != \"binary\" else \"binary\"\n\n    extract = self.memory[start:end, file]\n\n    file_info = f\" (file: {file})\" if file not in (\"absolute\", \"hybrid\") else \"\"\n    print(f\"Memory from {start:#x} to {end:#x}{file_info}:\")\n\n    pprint_memory_util(\n        address_start,\n        extract,\n        word_size,\n        self.maps,\n        integer_mode=integer_mode,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.pprint_registers","title":"<code>pprint_registers()</code>","text":"<p>Pretty prints the thread's registers.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def pprint_registers(self: Snapshot) -&gt; None:\n    \"\"\"Pretty prints the thread's registers.\"\"\"\n    pprint_registers_util(self.regs, self.maps, self.regs._generic_regs)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.pprint_registers_all","title":"<code>pprint_registers_all()</code>","text":"<p>Pretty prints all the thread's registers.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def pprint_registers_all(self: Snapshot) -&gt; None:\n    \"\"\"Pretty prints all the thread's registers.\"\"\"\n    pprint_registers_all_util(\n        self.regs,\n        self.maps,\n        self.regs._generic_regs,\n        self.regs._special_regs,\n        self.regs._vec_fp_regs,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.pprint_regs","title":"<code>pprint_regs()</code>","text":"<p>Alias for the <code>pprint_registers</code> method.</p> <p>Pretty prints the thread's registers.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def pprint_regs(self: Snapshot) -&gt; None:\n    \"\"\"Alias for the `pprint_registers` method.\n\n    Pretty prints the thread's registers.\n    \"\"\"\n    self.pprint_registers()\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.pprint_regs_all","title":"<code>pprint_regs_all()</code>","text":"<p>Alias for the <code>pprint_registers_all</code> method.</p> <p>Pretty prints all the thread's registers.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def pprint_regs_all(self: Snapshot) -&gt; None:\n    \"\"\"Alias for the `pprint_registers_all` method.\n\n    Pretty prints all the thread's registers.\n    \"\"\"\n    self.pprint_registers_all()\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/snapshot/#libdebug.snapshots.snapshot.Snapshot.save","title":"<code>save(file_path)</code>","text":"<p>Saves the snapshot object to a file.</p> Source code in <code>libdebug/snapshots/snapshot.py</code> <pre><code>def save(self: Snapshot, file_path: str) -&gt; None:\n    \"\"\"Saves the snapshot object to a file.\"\"\"\n    self._serialization_helper.save(self, file_path)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff/","title":"libdebug.snapshots.memory.memory_map_diff","text":""},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff/#libdebug.snapshots.memory.memory_map_diff.MemoryMapDiff","title":"<code>MemoryMapDiff</code>  <code>dataclass</code>","text":"<p>This object represents a diff between memory contents in a memory map.</p> Source code in <code>libdebug/snapshots/memory/memory_map_diff.py</code> <pre><code>@dataclass\nclass MemoryMapDiff:\n    \"\"\"This object represents a diff between memory contents in a memory map.\"\"\"\n\n    old_map_state: MemoryMapSnapshot\n    \"\"\"The old state of the memory map.\"\"\"\n\n    new_map_state: MemoryMapSnapshot\n    \"\"\"The new state of the memory map.\"\"\"\n\n    has_changed: bool\n    \"\"\"Whether the memory map has changed.\"\"\"\n\n    _cached_diffs: list[slice] = None\n    \"\"\"Cached diff slices.\"\"\"\n\n    @property\n    def content_diff(self: MemoryMapDiff) -&gt; list[slice]:\n        \"\"\"Resolve the content diffs of a memory map between two snapshots.\n\n        Returns:\n            list[slice]: The list of slices representing the relative positions of diverging content.\n        \"\"\"\n        # If the diff has already been computed, return it\n        if self._cached_diffs is not None:\n            return self._cached_diffs\n\n        if self.old_map_state is None:\n            raise ValueError(\"Cannot resolve content diff for a new memory map.\")\n        if self.new_map_state is None:\n            raise ValueError(\"Cannot resolve content diff for a removed memory map.\")\n\n        if self.old_map_state.content is None or self.new_map_state.content is None:\n            raise ValueError(\"Memory contents not available for this memory page.\")\n\n        old_content = self.old_map_state.content\n        new_content = self.new_map_state.content\n\n        work_len = min(len(old_content), len(new_content))\n\n        found_slices = []\n\n        # Find all the slices\n        cursor = 0\n        while cursor &lt; work_len:\n            # Find the first differing byte of the sequence\n            if old_content[cursor] == new_content[cursor]:\n                cursor += 1\n                continue\n\n            start = cursor\n            # Find the last non-zero byte of the sequence\n            while cursor &lt; work_len and old_content[cursor] != new_content[cursor]:\n                cursor += 1\n\n            end = cursor\n\n            found_slices.append(slice(start, end))\n\n        # Cache the diff slices\n        self._cached_diffs = found_slices\n\n        return found_slices\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff/#libdebug.snapshots.memory.memory_map_diff.MemoryMapDiff._cached_diffs","title":"<code>_cached_diffs = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Cached diff slices.</p>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff/#libdebug.snapshots.memory.memory_map_diff.MemoryMapDiff.content_diff","title":"<code>content_diff</code>  <code>property</code>","text":"<p>Resolve the content diffs of a memory map between two snapshots.</p> <p>Returns:</p> Type Description <code>list[slice]</code> <p>list[slice]: The list of slices representing the relative positions of diverging content.</p>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff/#libdebug.snapshots.memory.memory_map_diff.MemoryMapDiff.has_changed","title":"<code>has_changed</code>  <code>instance-attribute</code>","text":"<p>Whether the memory map has changed.</p>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff/#libdebug.snapshots.memory.memory_map_diff.MemoryMapDiff.new_map_state","title":"<code>new_map_state</code>  <code>instance-attribute</code>","text":"<p>The new state of the memory map.</p>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff/#libdebug.snapshots.memory.memory_map_diff.MemoryMapDiff.old_map_state","title":"<code>old_map_state</code>  <code>instance-attribute</code>","text":"<p>The old state of the memory map.</p>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff_list/","title":"libdebug.snapshots.memory.memory_map_diff_list","text":""},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff_list/#libdebug.snapshots.memory.memory_map_diff_list.MemoryMapDiffList","title":"<code>MemoryMapDiffList</code>","text":"<p>               Bases: <code>list</code></p> <p>A list of memory map snapshot diffs from the target process.</p> Source code in <code>libdebug/snapshots/memory/memory_map_diff_list.py</code> <pre><code>class MemoryMapDiffList(list):\n    \"\"\"A list of memory map snapshot diffs from the target process.\"\"\"\n\n    def __init__(\n        self: MemoryMapDiffList,\n        memory_maps: list[MemoryMapDiff],\n        process_name: str,\n        full_process_path: str,\n    ) -&gt; None:\n        \"\"\"Initializes the MemoryMapSnapshotList.\"\"\"\n        super().__init__(memory_maps)\n        self._process_full_path = full_process_path\n        self._process_name = process_name\n\n    def _search_by_address(self: MemoryMapDiffList, address: int) -&gt; list[MemoryMapDiff]:\n        \"\"\"Searches for a memory map diff by address.\n\n        Args:\n            address (int): The address to search for.\n\n        Returns:\n            list[MemoryMapDiff]: The memory map diff matching the specified address.\n        \"\"\"\n        for vmap_diff in self:\n            if vmap_diff.old_map_state.start &lt;= address &lt; vmap_diff.new_map_state.end:\n                return [vmap_diff]\n        return []\n\n    def _search_by_backing_file(self: MemoryMapDiffList, backing_file: str) -&gt; list[MemoryMapDiff]:\n        \"\"\"Searches for a memory map diff by backing file.\n\n        Args:\n            backing_file (str): The backing file to search for.\n\n        Returns:\n            list[MemoryMapDiff]: The memory map diff matching the specified backing file.\n        \"\"\"\n        if backing_file in [\"binary\", self._process_name]:\n            backing_file = self._process_full_path\n\n        filtered_maps = []\n        unique_files = set()\n\n        for vmap_diff in self:\n            compare_with_old = vmap_diff.old_map_state is not None\n            compare_with_new = vmap_diff.new_map_state is not None\n\n            if compare_with_old and backing_file in vmap_diff.old_map_state.backing_file:\n                filtered_maps.append(vmap_diff)\n                unique_files.add(vmap_diff.old_map_state.backing_file)\n            elif compare_with_new and backing_file in vmap_diff.new_map_state.backing_file:\n                filtered_maps.append(vmap_diff)\n                unique_files.add(vmap_diff.new_map_state.backing_file)\n\n        if len(unique_files) &gt; 1:\n            liblog.warning(\n                f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n            )\n\n        return filtered_maps\n\n    def filter(self: MemoryMapDiffList, value: int | str) -&gt; MemoryMapDiffList[MemoryMapDiff]:\n        \"\"\"Filters the memory maps according to the specified value.\n\n        If the value is an integer, it is treated as an address.\n        If the value is a string, it is treated as a backing file.\n\n        Args:\n            value (int | str): The value to search for.\n\n        Returns:\n            MemoryMapDiffList[MemoryMapDiff]: The memory maps matching the specified value.\n        \"\"\"\n        if isinstance(value, int):\n            filtered_maps = self._search_by_address(value)\n        elif isinstance(value, str):\n            filtered_maps = self._search_by_backing_file(value)\n        else:\n            raise TypeError(\"The value must be an integer or a string.\")\n\n        return MemoryMapDiffList(filtered_maps, self._process_name, self._process_full_path)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff_list/#libdebug.snapshots.memory.memory_map_diff_list.MemoryMapDiffList.__init__","title":"<code>__init__(memory_maps, process_name, full_process_path)</code>","text":"<p>Initializes the MemoryMapSnapshotList.</p> Source code in <code>libdebug/snapshots/memory/memory_map_diff_list.py</code> <pre><code>def __init__(\n    self: MemoryMapDiffList,\n    memory_maps: list[MemoryMapDiff],\n    process_name: str,\n    full_process_path: str,\n) -&gt; None:\n    \"\"\"Initializes the MemoryMapSnapshotList.\"\"\"\n    super().__init__(memory_maps)\n    self._process_full_path = full_process_path\n    self._process_name = process_name\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff_list/#libdebug.snapshots.memory.memory_map_diff_list.MemoryMapDiffList._search_by_address","title":"<code>_search_by_address(address)</code>","text":"<p>Searches for a memory map diff by address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to search for.</p> required <p>Returns:</p> Type Description <code>list[MemoryMapDiff]</code> <p>list[MemoryMapDiff]: The memory map diff matching the specified address.</p> Source code in <code>libdebug/snapshots/memory/memory_map_diff_list.py</code> <pre><code>def _search_by_address(self: MemoryMapDiffList, address: int) -&gt; list[MemoryMapDiff]:\n    \"\"\"Searches for a memory map diff by address.\n\n    Args:\n        address (int): The address to search for.\n\n    Returns:\n        list[MemoryMapDiff]: The memory map diff matching the specified address.\n    \"\"\"\n    for vmap_diff in self:\n        if vmap_diff.old_map_state.start &lt;= address &lt; vmap_diff.new_map_state.end:\n            return [vmap_diff]\n    return []\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff_list/#libdebug.snapshots.memory.memory_map_diff_list.MemoryMapDiffList._search_by_backing_file","title":"<code>_search_by_backing_file(backing_file)</code>","text":"<p>Searches for a memory map diff by backing file.</p> <p>Parameters:</p> Name Type Description Default <code>backing_file</code> <code>str</code> <p>The backing file to search for.</p> required <p>Returns:</p> Type Description <code>list[MemoryMapDiff]</code> <p>list[MemoryMapDiff]: The memory map diff matching the specified backing file.</p> Source code in <code>libdebug/snapshots/memory/memory_map_diff_list.py</code> <pre><code>def _search_by_backing_file(self: MemoryMapDiffList, backing_file: str) -&gt; list[MemoryMapDiff]:\n    \"\"\"Searches for a memory map diff by backing file.\n\n    Args:\n        backing_file (str): The backing file to search for.\n\n    Returns:\n        list[MemoryMapDiff]: The memory map diff matching the specified backing file.\n    \"\"\"\n    if backing_file in [\"binary\", self._process_name]:\n        backing_file = self._process_full_path\n\n    filtered_maps = []\n    unique_files = set()\n\n    for vmap_diff in self:\n        compare_with_old = vmap_diff.old_map_state is not None\n        compare_with_new = vmap_diff.new_map_state is not None\n\n        if compare_with_old and backing_file in vmap_diff.old_map_state.backing_file:\n            filtered_maps.append(vmap_diff)\n            unique_files.add(vmap_diff.old_map_state.backing_file)\n        elif compare_with_new and backing_file in vmap_diff.new_map_state.backing_file:\n            filtered_maps.append(vmap_diff)\n            unique_files.add(vmap_diff.new_map_state.backing_file)\n\n    if len(unique_files) &gt; 1:\n        liblog.warning(\n            f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n        )\n\n    return filtered_maps\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_diff_list/#libdebug.snapshots.memory.memory_map_diff_list.MemoryMapDiffList.filter","title":"<code>filter(value)</code>","text":"<p>Filters the memory maps according to the specified value.</p> <p>If the value is an integer, it is treated as an address. If the value is a string, it is treated as a backing file.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int | str</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>MemoryMapDiffList[MemoryMapDiff]</code> <p>MemoryMapDiffList[MemoryMapDiff]: The memory maps matching the specified value.</p> Source code in <code>libdebug/snapshots/memory/memory_map_diff_list.py</code> <pre><code>def filter(self: MemoryMapDiffList, value: int | str) -&gt; MemoryMapDiffList[MemoryMapDiff]:\n    \"\"\"Filters the memory maps according to the specified value.\n\n    If the value is an integer, it is treated as an address.\n    If the value is a string, it is treated as a backing file.\n\n    Args:\n        value (int | str): The value to search for.\n\n    Returns:\n        MemoryMapDiffList[MemoryMapDiff]: The memory maps matching the specified value.\n    \"\"\"\n    if isinstance(value, int):\n        filtered_maps = self._search_by_address(value)\n    elif isinstance(value, str):\n        filtered_maps = self._search_by_backing_file(value)\n    else:\n        raise TypeError(\"The value must be an integer or a string.\")\n\n    return MemoryMapDiffList(filtered_maps, self._process_name, self._process_full_path)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot/","title":"libdebug.snapshots.memory.memory_map_snapshot","text":""},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot/#libdebug.snapshots.memory.memory_map_snapshot.MemoryMapSnapshot","title":"<code>MemoryMapSnapshot</code>  <code>dataclass</code>","text":"<p>               Bases: <code>MemoryMap</code></p> <p>A snapshot of the memory map of the target process.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>int</code> <p>The start address of the memory map. You can access it also with the 'base' attribute.</p> <code>end</code> <code>int</code> <p>The end address of the memory map.</p> <code>permissions</code> <code>str</code> <p>The permissions of the memory map.</p> <code>size</code> <code>int</code> <p>The size of the memory map.</p> <code>offset</code> <code>int</code> <p>The relative offset of the memory map.</p> <code>backing_file</code> <code>str</code> <p>The backing file of the memory map, or the symbolic name of the memory map.</p> <code>content</code> <code>bytes</code> <p>The content of the memory map, used for snapshotted pages.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot.py</code> <pre><code>@dataclass\nclass MemoryMapSnapshot(MemoryMap):\n    \"\"\"A snapshot of the memory map of the target process.\n\n    Attributes:\n        start (int): The start address of the memory map. You can access it also with the 'base' attribute.\n        end (int): The end address of the memory map.\n        permissions (str): The permissions of the memory map.\n        size (int): The size of the memory map.\n        offset (int): The relative offset of the memory map.\n        backing_file (str): The backing file of the memory map, or the symbolic name of the memory map.\n        content (bytes): The content of the memory map, used for snapshotted pages.\n    \"\"\"\n\n    content: bytes = None\n    \"\"\"The content of the memory map, used for snapshotted pages.\"\"\"\n\n    def is_same_identity(self: MemoryMapSnapshot, other: MemoryMap) -&gt; bool:\n        \"\"\"Check if the memory map corresponds to another memory map.\"\"\"\n        return self.start == other.start and self.backing_file == other.backing_file\n\n    def __repr__(self: MemoryMapSnapshot) -&gt; str:\n        \"\"\"Return the string representation of the memory map.\"\"\"\n        str_repr = super().__repr__()\n\n        if self.content is not None:\n            str_repr = str_repr[:-1] + \", content=...)\"\n\n        return str_repr\n\n    def __eq__(self, value: object) -&gt; bool:\n        \"\"\"Check if this MemoryMap is equal to another object.\n\n        Args:\n            value (object): The object to compare to.\n\n        Returns:\n            bool: True if the objects are equal, False otherwise.\n        \"\"\"\n        if not isinstance(value, MemoryMap):\n            return False\n\n        is_snapshot_map = isinstance(value, MemoryMapSnapshot)\n\n        is_content_map_1 = self.content is not None\n        is_content_map_2 = is_snapshot_map and value.content is not None\n\n        if is_content_map_1 != is_content_map_2:\n            liblog.warning(\"Comparing a memory map snapshot with content with a memory map without content. Equality will not take into account the content.\") \n\n        # Check if the content is available and if it is the same\n        should_compare_content = is_snapshot_map and is_content_map_1 and is_content_map_2\n        same_content = not should_compare_content or self.content == value.content\n\n        return (\n            self.start == value.start\n            and self.end == value.end\n            and self.permissions == value.permissions\n            and self.size == value.size\n            and self.offset == value.offset\n            and self.backing_file == value.backing_file\n            and same_content\n        )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot/#libdebug.snapshots.memory.memory_map_snapshot.MemoryMapSnapshot.content","title":"<code>content = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The content of the memory map, used for snapshotted pages.</p>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot/#libdebug.snapshots.memory.memory_map_snapshot.MemoryMapSnapshot.__eq__","title":"<code>__eq__(value)</code>","text":"<p>Check if this MemoryMap is equal to another object.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>object</code> <p>The object to compare to.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the objects are equal, False otherwise.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot.py</code> <pre><code>def __eq__(self, value: object) -&gt; bool:\n    \"\"\"Check if this MemoryMap is equal to another object.\n\n    Args:\n        value (object): The object to compare to.\n\n    Returns:\n        bool: True if the objects are equal, False otherwise.\n    \"\"\"\n    if not isinstance(value, MemoryMap):\n        return False\n\n    is_snapshot_map = isinstance(value, MemoryMapSnapshot)\n\n    is_content_map_1 = self.content is not None\n    is_content_map_2 = is_snapshot_map and value.content is not None\n\n    if is_content_map_1 != is_content_map_2:\n        liblog.warning(\"Comparing a memory map snapshot with content with a memory map without content. Equality will not take into account the content.\") \n\n    # Check if the content is available and if it is the same\n    should_compare_content = is_snapshot_map and is_content_map_1 and is_content_map_2\n    same_content = not should_compare_content or self.content == value.content\n\n    return (\n        self.start == value.start\n        and self.end == value.end\n        and self.permissions == value.permissions\n        and self.size == value.size\n        and self.offset == value.offset\n        and self.backing_file == value.backing_file\n        and same_content\n    )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot/#libdebug.snapshots.memory.memory_map_snapshot.MemoryMapSnapshot.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the string representation of the memory map.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot.py</code> <pre><code>def __repr__(self: MemoryMapSnapshot) -&gt; str:\n    \"\"\"Return the string representation of the memory map.\"\"\"\n    str_repr = super().__repr__()\n\n    if self.content is not None:\n        str_repr = str_repr[:-1] + \", content=...)\"\n\n    return str_repr\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot/#libdebug.snapshots.memory.memory_map_snapshot.MemoryMapSnapshot.is_same_identity","title":"<code>is_same_identity(other)</code>","text":"<p>Check if the memory map corresponds to another memory map.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot.py</code> <pre><code>def is_same_identity(self: MemoryMapSnapshot, other: MemoryMap) -&gt; bool:\n    \"\"\"Check if the memory map corresponds to another memory map.\"\"\"\n    return self.start == other.start and self.backing_file == other.backing_file\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot_list/","title":"libdebug.snapshots.memory.memory_map_snapshot_list","text":""},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot_list/#libdebug.snapshots.memory.memory_map_snapshot_list.MemoryMapSnapshotList","title":"<code>MemoryMapSnapshotList</code>","text":"<p>               Bases: <code>list[MemoryMapSnapshot]</code></p> <p>A list of memory map snapshot from the target process.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot_list.py</code> <pre><code>class MemoryMapSnapshotList(list[MemoryMapSnapshot]):\n    \"\"\"A list of memory map snapshot from the target process.\"\"\"\n\n    def __init__(\n        self: MemoryMapSnapshotList,\n        memory_maps: list[MemoryMapSnapshot],\n        process_name: str,\n        full_process_path: str,\n    ) -&gt; None:\n        \"\"\"Initializes the MemoryMapSnapshotList.\"\"\"\n        super().__init__(memory_maps)\n        self._process_full_path = full_process_path\n        self._process_name = process_name\n\n    def _search_by_address(self: MemoryMapSnapshotList, address: int) -&gt; list[MemoryMapSnapshot]:\n        \"\"\"Searches for a memory map by address.\n\n        Args:\n            address (int): The address to search for.\n\n        Returns:\n            list[MemoryMapSnapshot]: The memory map matching the specified address.\n        \"\"\"\n        for vmap in self:\n            if vmap.start &lt;= address &lt; vmap.end:\n                return [vmap]\n        return []\n\n    def _search_by_backing_file(self: MemoryMapSnapshotList, backing_file: str) -&gt; list[MemoryMapSnapshot]:\n        \"\"\"Searches for a memory map by backing file.\n\n        Args:\n            backing_file (str): The backing file to search for.\n\n        Returns:\n            list[MemoryMapSnapshot]: The memory map matching the specified backing file.\n        \"\"\"\n        if backing_file in [\"binary\", self._process_name]:\n            backing_file = self._process_full_path\n\n        filtered_maps = []\n        unique_files = set()\n\n        for vmap in self:\n            if backing_file in vmap.backing_file:\n                filtered_maps.append(vmap)\n                unique_files.add(vmap.backing_file)\n\n        if len(unique_files) &gt; 1:\n            liblog.warning(\n                f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n            )\n\n        return filtered_maps\n\n    def filter(self: MemoryMapSnapshotList, value: int | str) -&gt; MemoryMapSnapshotList[MemoryMapSnapshot]:\n        \"\"\"Filters the memory maps according to the specified value.\n\n        If the value is an integer, it is treated as an address.\n        If the value is a string, it is treated as a backing file.\n\n        Args:\n            value (int | str): The value to search for.\n\n        Returns:\n            MemoryMapSnapshotList[MemoryMapSnapshot]: The memory map snapshots matching the specified value.\n        \"\"\"\n        if isinstance(value, int):\n            filtered_maps = self._search_by_address(value)\n        elif isinstance(value, str):\n            filtered_maps = self._search_by_backing_file(value)\n        else:\n            raise TypeError(\"The value must be an integer or a string.\")\n\n        return MemoryMapSnapshotList(filtered_maps, self._process_name, self._process_full_path)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot_list/#libdebug.snapshots.memory.memory_map_snapshot_list.MemoryMapSnapshotList.__init__","title":"<code>__init__(memory_maps, process_name, full_process_path)</code>","text":"<p>Initializes the MemoryMapSnapshotList.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot_list.py</code> <pre><code>def __init__(\n    self: MemoryMapSnapshotList,\n    memory_maps: list[MemoryMapSnapshot],\n    process_name: str,\n    full_process_path: str,\n) -&gt; None:\n    \"\"\"Initializes the MemoryMapSnapshotList.\"\"\"\n    super().__init__(memory_maps)\n    self._process_full_path = full_process_path\n    self._process_name = process_name\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot_list/#libdebug.snapshots.memory.memory_map_snapshot_list.MemoryMapSnapshotList._search_by_address","title":"<code>_search_by_address(address)</code>","text":"<p>Searches for a memory map by address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to search for.</p> required <p>Returns:</p> Type Description <code>list[MemoryMapSnapshot]</code> <p>list[MemoryMapSnapshot]: The memory map matching the specified address.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot_list.py</code> <pre><code>def _search_by_address(self: MemoryMapSnapshotList, address: int) -&gt; list[MemoryMapSnapshot]:\n    \"\"\"Searches for a memory map by address.\n\n    Args:\n        address (int): The address to search for.\n\n    Returns:\n        list[MemoryMapSnapshot]: The memory map matching the specified address.\n    \"\"\"\n    for vmap in self:\n        if vmap.start &lt;= address &lt; vmap.end:\n            return [vmap]\n    return []\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot_list/#libdebug.snapshots.memory.memory_map_snapshot_list.MemoryMapSnapshotList._search_by_backing_file","title":"<code>_search_by_backing_file(backing_file)</code>","text":"<p>Searches for a memory map by backing file.</p> <p>Parameters:</p> Name Type Description Default <code>backing_file</code> <code>str</code> <p>The backing file to search for.</p> required <p>Returns:</p> Type Description <code>list[MemoryMapSnapshot]</code> <p>list[MemoryMapSnapshot]: The memory map matching the specified backing file.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot_list.py</code> <pre><code>def _search_by_backing_file(self: MemoryMapSnapshotList, backing_file: str) -&gt; list[MemoryMapSnapshot]:\n    \"\"\"Searches for a memory map by backing file.\n\n    Args:\n        backing_file (str): The backing file to search for.\n\n    Returns:\n        list[MemoryMapSnapshot]: The memory map matching the specified backing file.\n    \"\"\"\n    if backing_file in [\"binary\", self._process_name]:\n        backing_file = self._process_full_path\n\n    filtered_maps = []\n    unique_files = set()\n\n    for vmap in self:\n        if backing_file in vmap.backing_file:\n            filtered_maps.append(vmap)\n            unique_files.add(vmap.backing_file)\n\n    if len(unique_files) &gt; 1:\n        liblog.warning(\n            f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n        )\n\n    return filtered_maps\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/memory_map_snapshot_list/#libdebug.snapshots.memory.memory_map_snapshot_list.MemoryMapSnapshotList.filter","title":"<code>filter(value)</code>","text":"<p>Filters the memory maps according to the specified value.</p> <p>If the value is an integer, it is treated as an address. If the value is a string, it is treated as a backing file.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int | str</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>MemoryMapSnapshotList[MemoryMapSnapshot]</code> <p>MemoryMapSnapshotList[MemoryMapSnapshot]: The memory map snapshots matching the specified value.</p> Source code in <code>libdebug/snapshots/memory/memory_map_snapshot_list.py</code> <pre><code>def filter(self: MemoryMapSnapshotList, value: int | str) -&gt; MemoryMapSnapshotList[MemoryMapSnapshot]:\n    \"\"\"Filters the memory maps according to the specified value.\n\n    If the value is an integer, it is treated as an address.\n    If the value is a string, it is treated as a backing file.\n\n    Args:\n        value (int | str): The value to search for.\n\n    Returns:\n        MemoryMapSnapshotList[MemoryMapSnapshot]: The memory map snapshots matching the specified value.\n    \"\"\"\n    if isinstance(value, int):\n        filtered_maps = self._search_by_address(value)\n    elif isinstance(value, str):\n        filtered_maps = self._search_by_backing_file(value)\n    else:\n        raise TypeError(\"The value must be an integer or a string.\")\n\n    return MemoryMapSnapshotList(filtered_maps, self._process_name, self._process_full_path)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/","title":"libdebug.snapshots.memory.snapshot_memory_view","text":""},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/#libdebug.snapshots.memory.snapshot_memory_view.SnapshotMemoryView","title":"<code>SnapshotMemoryView</code>","text":"<p>               Bases: <code>AbstractMemoryView</code></p> <p>Memory view for a thread / process snapshot.</p> Source code in <code>libdebug/snapshots/memory/snapshot_memory_view.py</code> <pre><code>class SnapshotMemoryView(AbstractMemoryView):\n    \"\"\"Memory view for a thread / process snapshot.\"\"\"\n\n    def __init__(self: SnapshotMemoryView, snapshot: ThreadSnapshot | ProcessSnapshot, symbols: SymbolList) -&gt; None:\n        \"\"\"Initializes the MemoryView.\"\"\"\n        self._snap_ref = snapshot\n        self._symbol_ref = symbols\n\n    def read(self: SnapshotMemoryView, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target snapshot.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n        snapshot_maps = self._snap_ref.maps\n\n        start_index = 0\n        start_map = None\n        has_failed = True\n\n        # Find the start map index\n        while start_index &lt; len(snapshot_maps):\n            start_map = snapshot_maps[start_index]\n\n            if address &lt; start_map.start:\n                break\n            elif start_map.start &lt;= address &lt; start_map.end:\n                has_failed = False\n                break\n            start_index += 1\n\n        if has_failed:\n            raise ValueError(\"No mapped memory at the specified start address.\")\n\n        end_index = start_index\n        end_address = address + size - 1\n        end_map = None\n        has_failed = True\n\n        # Find the end map index\n        while end_index &lt; len(snapshot_maps):\n            end_map = snapshot_maps[end_index]\n\n            if end_address &lt; end_map.start:\n                break\n            elif end_map.start &lt;= end_address &lt; end_map.end:\n                has_failed = False\n                break\n            end_index += 1\n\n        if has_failed:\n            raise ValueError(\"No mapped memory at the specified address.\")\n\n        target_maps = self._snap_ref.maps[start_index:end_index + 1]\n\n        if not target_maps:\n            raise ValueError(\"No mapped memory at the specified address.\")\n\n        for target_map in target_maps:\n            # The memory of the target map cannot be retrieved\n            if target_map.content is None:\n                error = \"One or more of the memory maps involved was not snapshotted\"\n\n                if self._snap_ref.level == \"base\":\n                    error += \", snapshot level is base, no memory contents were saved.\"\n                elif self._snap_ref.level == \"writable\" and \"w\" not in target_map.permissions:\n                    error += \", snapshot level is writable but the target page corresponds to non-writable memory.\"\n                else:\n                    error += \" (it could be a priviledged memory map e.g. [vvar]).\"\n\n                raise ValueError(error)\n\n        start_offset = address - target_maps[0].start\n\n        if len(target_maps) == 1:\n            end_offset = start_offset + size\n            return target_maps[0].content[start_offset:end_offset]\n        else:\n            data = target_maps[0].content[start_offset:]\n\n            for target_map in target_maps[1:-1]:\n                data += target_map.content\n\n            end_offset = size - len(data)\n            data += target_maps[-1].content[:end_offset]\n\n            return data\n\n    def write(self: SnapshotMemoryView, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target snapshot.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n        raise NotImplementedError(\"Snapshot memory is read-only, duh.\")\n\n    def find(\n        self: SnapshotMemoryView,\n        value: bytes | str | int,\n        file: str = \"all\",\n        start: int | None = None,\n        end: int | None = None,\n    ) -&gt; list[int]:\n        \"\"\"Searches for the given value in the saved memory maps of the snapshot.\n\n        The start and end addresses can be used to limit the search to a specific range.\n        If not specified, the search will be performed on the whole memory map.\n\n        Args:\n            value (bytes | str | int): The value to search for.\n            file (str): The backing file to search the value in. Defaults to \"all\", which means all memory.\n            start (int | None): The start address of the search. Defaults to None.\n            end (int | None): The end address of the search. Defaults to None.\n\n        Returns:\n            list[int]: A list of offset where the value was found.\n        \"\"\"\n        if self._snap_ref.level == \"base\":\n            raise ValueError(\"Memory snapshot is not available at base level.\")\n\n        return super().find(value, file, start, end)\n\n    def resolve_symbol(self: SnapshotMemoryView, symbol: str, file: str) -&gt; Symbol:\n        \"\"\"Resolve a symbol from the symbol list.\n\n        Args:\n            symbol (str): The symbol to resolve.\n            file (str): The backing file to resolve the address in.\n\n        Returns:\n            Symbol: The resolved address.\n        \"\"\"\n        offset = 0\n\n        if \"+\" in symbol:\n            symbol, offset = symbol.split(\"+\")\n            offset = int(offset, 16)\n\n        results = self._symbol_ref.filter(symbol)\n\n        # Get the first result that matches the backing file\n        results = [result for result in results if file in result.backing_file]\n\n        if len(results) == 0:\n            raise ValueError(f\"Symbol {symbol} not found in snaphot memory.\")\n\n        page_base = self._snap_ref.maps.filter(results[0].backing_file)[0].start\n\n        return page_base + results[0].start + offset\n\n    def resolve_address(\n        self: SnapshotMemoryView,\n        address: int,\n        backing_file: str,\n        skip_absolute_address_validation: bool = False,\n    ) -&gt; int:\n        \"\"\"Normalizes and validates the specified address.\n\n        Args:\n            address (int): The address to normalize and validate.\n            backing_file (str): The backing file to resolve the address in.\n            skip_absolute_address_validation (bool, optional): Whether to skip bounds checking for absolute addresses. Defaults to False.\n\n        Returns:\n            int: The normalized and validated address.\n\n        Raises:\n            ValueError: If the substring `backing_file` is present in multiple backing files.\n        \"\"\"\n        if skip_absolute_address_validation and backing_file == \"absolute\":\n            return address\n\n        maps = self._snap_ref.maps\n\n        if backing_file in [\"hybrid\", \"absolute\"]:\n            if maps.filter(address):\n                # If the address is absolute, we can return it directly\n                return address\n            elif backing_file == \"absolute\":\n                # The address is explicitly an absolute address but we did not find it\n                raise ValueError(\n                    \"The specified absolute address does not exist. Check the address or specify a backing file.\",\n                )\n            else:\n                # If the address was not found and the backing file is not \"absolute\",\n                # we have to assume it is in the main map\n                backing_file = self._snap_ref._process_full_path\n                liblog.warning(\n                    f\"No backing file specified and no corresponding absolute address found for {hex(address)}. Assuming {backing_file}.\",\n                )\n\n        filtered_maps = maps.filter(backing_file)\n\n        return normalize_and_validate_address(address, filtered_maps)\n\n    @property\n    def maps(self: SnapshotMemoryView) -&gt; MemoryMapSnapshotList:\n        \"\"\"Returns a list of memory maps in the target process.\n\n        Returns:\n            MemoryMapList: The memory maps.\n        \"\"\"\n        return self._snap_ref.maps\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/#libdebug.snapshots.memory.snapshot_memory_view.SnapshotMemoryView.maps","title":"<code>maps</code>  <code>property</code>","text":"<p>Returns a list of memory maps in the target process.</p> <p>Returns:</p> Name Type Description <code>MemoryMapList</code> <code>MemoryMapSnapshotList</code> <p>The memory maps.</p>"},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/#libdebug.snapshots.memory.snapshot_memory_view.SnapshotMemoryView.__init__","title":"<code>__init__(snapshot, symbols)</code>","text":"<p>Initializes the MemoryView.</p> Source code in <code>libdebug/snapshots/memory/snapshot_memory_view.py</code> <pre><code>def __init__(self: SnapshotMemoryView, snapshot: ThreadSnapshot | ProcessSnapshot, symbols: SymbolList) -&gt; None:\n    \"\"\"Initializes the MemoryView.\"\"\"\n    self._snap_ref = snapshot\n    self._symbol_ref = symbols\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/#libdebug.snapshots.memory.snapshot_memory_view.SnapshotMemoryView.find","title":"<code>find(value, file='all', start=None, end=None)</code>","text":"<p>Searches for the given value in the saved memory maps of the snapshot.</p> <p>The start and end addresses can be used to limit the search to a specific range. If not specified, the search will be performed on the whole memory map.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes | str | int</code> <p>The value to search for.</p> required <code>file</code> <code>str</code> <p>The backing file to search the value in. Defaults to \"all\", which means all memory.</p> <code>'all'</code> <code>start</code> <code>int | None</code> <p>The start address of the search. Defaults to None.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>The end address of the search. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of offset where the value was found.</p> Source code in <code>libdebug/snapshots/memory/snapshot_memory_view.py</code> <pre><code>def find(\n    self: SnapshotMemoryView,\n    value: bytes | str | int,\n    file: str = \"all\",\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; list[int]:\n    \"\"\"Searches for the given value in the saved memory maps of the snapshot.\n\n    The start and end addresses can be used to limit the search to a specific range.\n    If not specified, the search will be performed on the whole memory map.\n\n    Args:\n        value (bytes | str | int): The value to search for.\n        file (str): The backing file to search the value in. Defaults to \"all\", which means all memory.\n        start (int | None): The start address of the search. Defaults to None.\n        end (int | None): The end address of the search. Defaults to None.\n\n    Returns:\n        list[int]: A list of offset where the value was found.\n    \"\"\"\n    if self._snap_ref.level == \"base\":\n        raise ValueError(\"Memory snapshot is not available at base level.\")\n\n    return super().find(value, file, start, end)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/#libdebug.snapshots.memory.snapshot_memory_view.SnapshotMemoryView.read","title":"<code>read(address, size)</code>","text":"<p>Reads memory from the target snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/snapshots/memory/snapshot_memory_view.py</code> <pre><code>def read(self: SnapshotMemoryView, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target snapshot.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n    snapshot_maps = self._snap_ref.maps\n\n    start_index = 0\n    start_map = None\n    has_failed = True\n\n    # Find the start map index\n    while start_index &lt; len(snapshot_maps):\n        start_map = snapshot_maps[start_index]\n\n        if address &lt; start_map.start:\n            break\n        elif start_map.start &lt;= address &lt; start_map.end:\n            has_failed = False\n            break\n        start_index += 1\n\n    if has_failed:\n        raise ValueError(\"No mapped memory at the specified start address.\")\n\n    end_index = start_index\n    end_address = address + size - 1\n    end_map = None\n    has_failed = True\n\n    # Find the end map index\n    while end_index &lt; len(snapshot_maps):\n        end_map = snapshot_maps[end_index]\n\n        if end_address &lt; end_map.start:\n            break\n        elif end_map.start &lt;= end_address &lt; end_map.end:\n            has_failed = False\n            break\n        end_index += 1\n\n    if has_failed:\n        raise ValueError(\"No mapped memory at the specified address.\")\n\n    target_maps = self._snap_ref.maps[start_index:end_index + 1]\n\n    if not target_maps:\n        raise ValueError(\"No mapped memory at the specified address.\")\n\n    for target_map in target_maps:\n        # The memory of the target map cannot be retrieved\n        if target_map.content is None:\n            error = \"One or more of the memory maps involved was not snapshotted\"\n\n            if self._snap_ref.level == \"base\":\n                error += \", snapshot level is base, no memory contents were saved.\"\n            elif self._snap_ref.level == \"writable\" and \"w\" not in target_map.permissions:\n                error += \", snapshot level is writable but the target page corresponds to non-writable memory.\"\n            else:\n                error += \" (it could be a priviledged memory map e.g. [vvar]).\"\n\n            raise ValueError(error)\n\n    start_offset = address - target_maps[0].start\n\n    if len(target_maps) == 1:\n        end_offset = start_offset + size\n        return target_maps[0].content[start_offset:end_offset]\n    else:\n        data = target_maps[0].content[start_offset:]\n\n        for target_map in target_maps[1:-1]:\n            data += target_map.content\n\n        end_offset = size - len(data)\n        data += target_maps[-1].content[:end_offset]\n\n        return data\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/#libdebug.snapshots.memory.snapshot_memory_view.SnapshotMemoryView.resolve_address","title":"<code>resolve_address(address, backing_file, skip_absolute_address_validation=False)</code>","text":"<p>Normalizes and validates the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to normalize and validate.</p> required <code>backing_file</code> <code>str</code> <p>The backing file to resolve the address in.</p> required <code>skip_absolute_address_validation</code> <code>bool</code> <p>Whether to skip bounds checking for absolute addresses. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The normalized and validated address.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the substring <code>backing_file</code> is present in multiple backing files.</p> Source code in <code>libdebug/snapshots/memory/snapshot_memory_view.py</code> <pre><code>def resolve_address(\n    self: SnapshotMemoryView,\n    address: int,\n    backing_file: str,\n    skip_absolute_address_validation: bool = False,\n) -&gt; int:\n    \"\"\"Normalizes and validates the specified address.\n\n    Args:\n        address (int): The address to normalize and validate.\n        backing_file (str): The backing file to resolve the address in.\n        skip_absolute_address_validation (bool, optional): Whether to skip bounds checking for absolute addresses. Defaults to False.\n\n    Returns:\n        int: The normalized and validated address.\n\n    Raises:\n        ValueError: If the substring `backing_file` is present in multiple backing files.\n    \"\"\"\n    if skip_absolute_address_validation and backing_file == \"absolute\":\n        return address\n\n    maps = self._snap_ref.maps\n\n    if backing_file in [\"hybrid\", \"absolute\"]:\n        if maps.filter(address):\n            # If the address is absolute, we can return it directly\n            return address\n        elif backing_file == \"absolute\":\n            # The address is explicitly an absolute address but we did not find it\n            raise ValueError(\n                \"The specified absolute address does not exist. Check the address or specify a backing file.\",\n            )\n        else:\n            # If the address was not found and the backing file is not \"absolute\",\n            # we have to assume it is in the main map\n            backing_file = self._snap_ref._process_full_path\n            liblog.warning(\n                f\"No backing file specified and no corresponding absolute address found for {hex(address)}. Assuming {backing_file}.\",\n            )\n\n    filtered_maps = maps.filter(backing_file)\n\n    return normalize_and_validate_address(address, filtered_maps)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/#libdebug.snapshots.memory.snapshot_memory_view.SnapshotMemoryView.resolve_symbol","title":"<code>resolve_symbol(symbol, file)</code>","text":"<p>Resolve a symbol from the symbol list.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to resolve.</p> required <code>file</code> <code>str</code> <p>The backing file to resolve the address in.</p> required <p>Returns:</p> Name Type Description <code>Symbol</code> <code>Symbol</code> <p>The resolved address.</p> Source code in <code>libdebug/snapshots/memory/snapshot_memory_view.py</code> <pre><code>def resolve_symbol(self: SnapshotMemoryView, symbol: str, file: str) -&gt; Symbol:\n    \"\"\"Resolve a symbol from the symbol list.\n\n    Args:\n        symbol (str): The symbol to resolve.\n        file (str): The backing file to resolve the address in.\n\n    Returns:\n        Symbol: The resolved address.\n    \"\"\"\n    offset = 0\n\n    if \"+\" in symbol:\n        symbol, offset = symbol.split(\"+\")\n        offset = int(offset, 16)\n\n    results = self._symbol_ref.filter(symbol)\n\n    # Get the first result that matches the backing file\n    results = [result for result in results if file in result.backing_file]\n\n    if len(results) == 0:\n        raise ValueError(f\"Symbol {symbol} not found in snaphot memory.\")\n\n    page_base = self._snap_ref.maps.filter(results[0].backing_file)[0].start\n\n    return page_base + results[0].start + offset\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/memory/snapshot_memory_view/#libdebug.snapshots.memory.snapshot_memory_view.SnapshotMemoryView.write","title":"<code>write(address, data)</code>","text":"<p>Writes memory to the target snapshot.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/snapshots/memory/snapshot_memory_view.py</code> <pre><code>def write(self: SnapshotMemoryView, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target snapshot.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n    raise NotImplementedError(\"Snapshot memory is read-only, duh.\")\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/process/process_shapshot_diff/","title":"libdebug.snapshots.process.process_shapshot_diff","text":""},{"location":"from_pydoc/generated/snapshots/process/process_shapshot_diff/#libdebug.snapshots.process.process_shapshot_diff.ProcessSnapshotDiff","title":"<code>ProcessSnapshotDiff</code>","text":"<p>               Bases: <code>Diff</code></p> <p>This object represents a diff between process snapshots.</p> Source code in <code>libdebug/snapshots/process/process_shapshot_diff.py</code> <pre><code>class ProcessSnapshotDiff(Diff):\n    \"\"\"This object represents a diff between process snapshots.\"\"\"\n\n    def __init__(self: ProcessSnapshotDiff, snapshot1: ProcessSnapshot, snapshot2: ProcessSnapshot) -&gt; None:\n        \"\"\"Returns a diff between given snapshots of the same process.\n\n        Args:\n            snapshot1 (ProcessSnapshot): A process snapshot.\n            snapshot2 (ProcessSnapshot): A process snapshot.\n        \"\"\"\n        super().__init__(snapshot1, snapshot2)\n\n        # Register diffs\n        self._save_reg_diffs()\n\n        # Memory map diffs\n        self._resolve_maps_diff()\n\n        # Thread diffs\n        self._generate_thread_diffs()\n\n        if (self.snapshot1._process_name == self.snapshot2._process_name) and (\n            self.snapshot1.aslr_enabled or self.snapshot2.aslr_enabled\n        ):\n            liblog.warning(\"ASLR is enabled in either or both snapshots. Diff may be messy.\")\n\n    def _generate_thread_diffs(self: ProcessSnapshotDiff) -&gt; None:\n        \"\"\"Generates diffs between threads in the two compared snapshots.\n\n        Thread differences:\n         - Born threads and dead threads are stored directly in separate lists (no state diff exists between the two).\n         - Threads that exist in both snapshots are stored as diffs and can be accessed through the threads_diff property.\n        \"\"\"\n        self.born_threads = []\n        self.dead_threads = []\n        self.threads_diff = []\n\n        snapshot1_by_tid = {thread.tid: thread for thread in self.snapshot1.threads}\n        snapshot2_by_tid = {thread.tid: thread for thread in self.snapshot2.threads}\n\n        for tid, t1 in snapshot1_by_tid.items():\n            t2 = snapshot2_by_tid.get(tid)\n            if t2 is None:\n                self.dead_threads.append(t1)\n            else:\n                diff = LightweightThreadSnapshotDiff(t1, t2, self)\n                self.threads_diff.append(diff)\n\n        for tid, t2 in snapshot2_by_tid.items():\n            if tid not in snapshot1_by_tid:\n                self.born_threads.append(t2)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/process/process_shapshot_diff/#libdebug.snapshots.process.process_shapshot_diff.ProcessSnapshotDiff.__init__","title":"<code>__init__(snapshot1, snapshot2)</code>","text":"<p>Returns a diff between given snapshots of the same process.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot1</code> <code>ProcessSnapshot</code> <p>A process snapshot.</p> required <code>snapshot2</code> <code>ProcessSnapshot</code> <p>A process snapshot.</p> required Source code in <code>libdebug/snapshots/process/process_shapshot_diff.py</code> <pre><code>def __init__(self: ProcessSnapshotDiff, snapshot1: ProcessSnapshot, snapshot2: ProcessSnapshot) -&gt; None:\n    \"\"\"Returns a diff between given snapshots of the same process.\n\n    Args:\n        snapshot1 (ProcessSnapshot): A process snapshot.\n        snapshot2 (ProcessSnapshot): A process snapshot.\n    \"\"\"\n    super().__init__(snapshot1, snapshot2)\n\n    # Register diffs\n    self._save_reg_diffs()\n\n    # Memory map diffs\n    self._resolve_maps_diff()\n\n    # Thread diffs\n    self._generate_thread_diffs()\n\n    if (self.snapshot1._process_name == self.snapshot2._process_name) and (\n        self.snapshot1.aslr_enabled or self.snapshot2.aslr_enabled\n    ):\n        liblog.warning(\"ASLR is enabled in either or both snapshots. Diff may be messy.\")\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/process/process_shapshot_diff/#libdebug.snapshots.process.process_shapshot_diff.ProcessSnapshotDiff._generate_thread_diffs","title":"<code>_generate_thread_diffs()</code>","text":"<p>Generates diffs between threads in the two compared snapshots.</p> Thread differences <ul> <li>Born threads and dead threads are stored directly in separate lists (no state diff exists between the two).</li> <li>Threads that exist in both snapshots are stored as diffs and can be accessed through the threads_diff property.</li> </ul> Source code in <code>libdebug/snapshots/process/process_shapshot_diff.py</code> <pre><code>def _generate_thread_diffs(self: ProcessSnapshotDiff) -&gt; None:\n    \"\"\"Generates diffs between threads in the two compared snapshots.\n\n    Thread differences:\n     - Born threads and dead threads are stored directly in separate lists (no state diff exists between the two).\n     - Threads that exist in both snapshots are stored as diffs and can be accessed through the threads_diff property.\n    \"\"\"\n    self.born_threads = []\n    self.dead_threads = []\n    self.threads_diff = []\n\n    snapshot1_by_tid = {thread.tid: thread for thread in self.snapshot1.threads}\n    snapshot2_by_tid = {thread.tid: thread for thread in self.snapshot2.threads}\n\n    for tid, t1 in snapshot1_by_tid.items():\n        t2 = snapshot2_by_tid.get(tid)\n        if t2 is None:\n            self.dead_threads.append(t1)\n        else:\n            diff = LightweightThreadSnapshotDiff(t1, t2, self)\n            self.threads_diff.append(diff)\n\n    for tid, t2 in snapshot2_by_tid.items():\n        if tid not in snapshot1_by_tid:\n            self.born_threads.append(t2)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/process/process_snapshot/","title":"libdebug.snapshots.process.process_snapshot","text":""},{"location":"from_pydoc/generated/snapshots/process/process_snapshot/#libdebug.snapshots.process.process_snapshot.ProcessSnapshot","title":"<code>ProcessSnapshot</code>","text":"<p>               Bases: <code>Snapshot</code></p> <p>This object represents a snapshot of the target process. It holds information about the process's state.</p> <p>Snapshot levels: - base: Registers - writable: Registers, writable memory contents - full: Registers, stack, all readable memory contents</p> Source code in <code>libdebug/snapshots/process/process_snapshot.py</code> <pre><code>class ProcessSnapshot(Snapshot):\n    \"\"\"This object represents a snapshot of the target process. It holds information about the process's state.\n\n    Snapshot levels:\n    - base: Registers\n    - writable: Registers, writable memory contents\n    - full: Registers, stack, all readable memory contents\n    \"\"\"\n\n    def __init__(\n        self: ProcessSnapshot, debugger: InternalDebugger, level: str = \"base\", name: str | None = None\n    ) -&gt; None:\n        \"\"\"Creates a new snapshot object for the given process.\n\n        Args:\n            debugger (Debugger): The thread to take a snapshot of.\n            level (str, optional): The level of the snapshot. Defaults to \"base\".\n            name (str, optional): A name associated to the snapshot. Defaults to None.\n        \"\"\"\n        # Set id of the snapshot and increment the counter\n        self.snapshot_id = debugger._snapshot_count\n        debugger.notify_snaphot_taken()\n\n        # Basic snapshot info\n        self.process_id = debugger.process_id\n        self.pid = self.process_id\n        self.name = name\n        self.level = level\n        self.arch = debugger.arch\n        self.aslr_enabled = debugger.aslr_enabled\n        self._process_full_path = debugger._process_full_path\n        self._process_name = debugger._process_name\n        self._serialization_helper = debugger.serialization_helper\n\n        # Memory maps\n        match level:\n            case \"base\":\n                self.maps = MemoryMapSnapshotList([], self._process_name, self._process_full_path)\n\n                for curr_map in debugger.maps:\n                    saved_map = MemoryMapSnapshot(\n                        start=curr_map.start,\n                        end=curr_map.end,\n                        permissions=curr_map.permissions,\n                        size=curr_map.size,\n                        offset=curr_map.offset,\n                        backing_file=curr_map.backing_file,\n                        content=None,\n                    )\n                    self.maps.append(saved_map)\n\n                self._memory = None\n            case \"writable\":\n                if not debugger.fast_memory:\n                    liblog.warning(\n                        \"Memory snapshot requested but fast memory is not enabled. This will take a long time.\",\n                    )\n\n                # Save all memory pages\n                self._save_memory_maps(debugger, writable_only=True)\n\n                self._memory = SnapshotMemoryView(self, debugger.symbols)\n            case \"full\":\n                if not debugger.fast_memory:\n                    liblog.warning(\n                        \"Memory snapshot requested but fast memory is not enabled. This will take a long time.\",\n                    )\n\n                # Save all memory pages\n                self._save_memory_maps(debugger, writable_only=False)\n\n                self._memory = SnapshotMemoryView(self, debugger.symbols)\n            case _:\n                raise ValueError(f\"Invalid snapshot level {level}\")\n\n        # Snapshot the threads\n        self._save_threads(debugger)\n\n        # Log the creation of the snapshot\n        named_addition = \" named \" + self.name if name is not None else \"\"\n        liblog.debugger(\n            f\"Created snapshot {self.snapshot_id} of level {self.level} for process {self.pid}{named_addition}\"\n        )\n\n    def _save_threads(self: ProcessSnapshot, debugger: InternalDebugger) -&gt; None:\n        self.threads = []\n\n        for thread in debugger.threads:\n            # Create a lightweight snapshot for the thread\n            lw_snapshot = LightweightThreadSnapshot(thread, self)\n\n            self.threads.append(lw_snapshot)\n\n    @property\n    def regs(self: ProcessSnapshot) -&gt; SnapshotRegisters:\n        \"\"\"Returns the registers of the process snapshot.\"\"\"\n        return self.threads[0].regs\n\n    def diff(self: ProcessSnapshot, other: ProcessSnapshot) -&gt; Diff:\n        \"\"\"Returns the diff between two process snapshots.\"\"\"\n        if not isinstance(other, ProcessSnapshot):\n            raise TypeError(\"Both arguments must be ProcessSnapshot objects.\")\n\n        return ProcessSnapshotDiff(self, other)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/process/process_snapshot/#libdebug.snapshots.process.process_snapshot.ProcessSnapshot.regs","title":"<code>regs</code>  <code>property</code>","text":"<p>Returns the registers of the process snapshot.</p>"},{"location":"from_pydoc/generated/snapshots/process/process_snapshot/#libdebug.snapshots.process.process_snapshot.ProcessSnapshot.__init__","title":"<code>__init__(debugger, level='base', name=None)</code>","text":"<p>Creates a new snapshot object for the given process.</p> <p>Parameters:</p> Name Type Description Default <code>debugger</code> <code>Debugger</code> <p>The thread to take a snapshot of.</p> required <code>level</code> <code>str</code> <p>The level of the snapshot. Defaults to \"base\".</p> <code>'base'</code> <code>name</code> <code>str</code> <p>A name associated to the snapshot. Defaults to None.</p> <code>None</code> Source code in <code>libdebug/snapshots/process/process_snapshot.py</code> <pre><code>def __init__(\n    self: ProcessSnapshot, debugger: InternalDebugger, level: str = \"base\", name: str | None = None\n) -&gt; None:\n    \"\"\"Creates a new snapshot object for the given process.\n\n    Args:\n        debugger (Debugger): The thread to take a snapshot of.\n        level (str, optional): The level of the snapshot. Defaults to \"base\".\n        name (str, optional): A name associated to the snapshot. Defaults to None.\n    \"\"\"\n    # Set id of the snapshot and increment the counter\n    self.snapshot_id = debugger._snapshot_count\n    debugger.notify_snaphot_taken()\n\n    # Basic snapshot info\n    self.process_id = debugger.process_id\n    self.pid = self.process_id\n    self.name = name\n    self.level = level\n    self.arch = debugger.arch\n    self.aslr_enabled = debugger.aslr_enabled\n    self._process_full_path = debugger._process_full_path\n    self._process_name = debugger._process_name\n    self._serialization_helper = debugger.serialization_helper\n\n    # Memory maps\n    match level:\n        case \"base\":\n            self.maps = MemoryMapSnapshotList([], self._process_name, self._process_full_path)\n\n            for curr_map in debugger.maps:\n                saved_map = MemoryMapSnapshot(\n                    start=curr_map.start,\n                    end=curr_map.end,\n                    permissions=curr_map.permissions,\n                    size=curr_map.size,\n                    offset=curr_map.offset,\n                    backing_file=curr_map.backing_file,\n                    content=None,\n                )\n                self.maps.append(saved_map)\n\n            self._memory = None\n        case \"writable\":\n            if not debugger.fast_memory:\n                liblog.warning(\n                    \"Memory snapshot requested but fast memory is not enabled. This will take a long time.\",\n                )\n\n            # Save all memory pages\n            self._save_memory_maps(debugger, writable_only=True)\n\n            self._memory = SnapshotMemoryView(self, debugger.symbols)\n        case \"full\":\n            if not debugger.fast_memory:\n                liblog.warning(\n                    \"Memory snapshot requested but fast memory is not enabled. This will take a long time.\",\n                )\n\n            # Save all memory pages\n            self._save_memory_maps(debugger, writable_only=False)\n\n            self._memory = SnapshotMemoryView(self, debugger.symbols)\n        case _:\n            raise ValueError(f\"Invalid snapshot level {level}\")\n\n    # Snapshot the threads\n    self._save_threads(debugger)\n\n    # Log the creation of the snapshot\n    named_addition = \" named \" + self.name if name is not None else \"\"\n    liblog.debugger(\n        f\"Created snapshot {self.snapshot_id} of level {self.level} for process {self.pid}{named_addition}\"\n    )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/process/process_snapshot/#libdebug.snapshots.process.process_snapshot.ProcessSnapshot.diff","title":"<code>diff(other)</code>","text":"<p>Returns the diff between two process snapshots.</p> Source code in <code>libdebug/snapshots/process/process_snapshot.py</code> <pre><code>def diff(self: ProcessSnapshot, other: ProcessSnapshot) -&gt; Diff:\n    \"\"\"Returns the diff between two process snapshots.\"\"\"\n    if not isinstance(other, ProcessSnapshot):\n        raise TypeError(\"Both arguments must be ProcessSnapshot objects.\")\n\n    return ProcessSnapshotDiff(self, other)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/registers/register_diff/","title":"libdebug.snapshots.registers.register_diff","text":""},{"location":"from_pydoc/generated/snapshots/registers/register_diff/#libdebug.snapshots.registers.register_diff.RegisterDiff","title":"<code>RegisterDiff</code>  <code>dataclass</code>","text":"<p>This object represents a diff between registers in a thread snapshot.</p> Source code in <code>libdebug/snapshots/registers/register_diff.py</code> <pre><code>@dataclass\nclass RegisterDiff:\n    \"\"\"This object represents a diff between registers in a thread snapshot.\"\"\"\n\n    old_value: int | float\n    \"\"\"The old value of the register.\"\"\"\n\n    new_value: int | float\n    \"\"\"The new value of the register.\"\"\"\n\n    has_changed: bool\n    \"\"\"Whether the register has changed.\"\"\"\n\n    def __repr__(self: RegisterDiff) -&gt; str:\n        \"\"\"Return a string representation of the RegisterDiff object.\"\"\"\n        old_value_str = hex(self.old_value) if isinstance(self.old_value, int) else str(self.old_value)\n        new_value_str = hex(self.new_value) if isinstance(self.new_value, int) else str(self.new_value)\n        return f\"RegisterDiff(old_value={old_value_str}, new_value={new_value_str}, has_changed={self.has_changed})\"\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/registers/register_diff/#libdebug.snapshots.registers.register_diff.RegisterDiff.has_changed","title":"<code>has_changed</code>  <code>instance-attribute</code>","text":"<p>Whether the register has changed.</p>"},{"location":"from_pydoc/generated/snapshots/registers/register_diff/#libdebug.snapshots.registers.register_diff.RegisterDiff.new_value","title":"<code>new_value</code>  <code>instance-attribute</code>","text":"<p>The new value of the register.</p>"},{"location":"from_pydoc/generated/snapshots/registers/register_diff/#libdebug.snapshots.registers.register_diff.RegisterDiff.old_value","title":"<code>old_value</code>  <code>instance-attribute</code>","text":"<p>The old value of the register.</p>"},{"location":"from_pydoc/generated/snapshots/registers/register_diff/#libdebug.snapshots.registers.register_diff.RegisterDiff.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the RegisterDiff object.</p> Source code in <code>libdebug/snapshots/registers/register_diff.py</code> <pre><code>def __repr__(self: RegisterDiff) -&gt; str:\n    \"\"\"Return a string representation of the RegisterDiff object.\"\"\"\n    old_value_str = hex(self.old_value) if isinstance(self.old_value, int) else str(self.old_value)\n    new_value_str = hex(self.new_value) if isinstance(self.new_value, int) else str(self.new_value)\n    return f\"RegisterDiff(old_value={old_value_str}, new_value={new_value_str}, has_changed={self.has_changed})\"\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/registers/register_diff_accessor/","title":"libdebug.snapshots.registers.register_diff_accessor","text":""},{"location":"from_pydoc/generated/snapshots/registers/register_diff_accessor/#libdebug.snapshots.registers.register_diff_accessor.RegisterDiffAccessor","title":"<code>RegisterDiffAccessor</code>","text":"<p>Class used to access RegisterDiff objects for a thread snapshot.</p> Source code in <code>libdebug/snapshots/registers/register_diff_accessor.py</code> <pre><code>class RegisterDiffAccessor:\n    \"\"\"Class used to access RegisterDiff objects for a thread snapshot.\"\"\"\n\n    def __init__(\n        self: RegisterDiffAccessor,\n        generic_regs: list[str],\n        special_regs: list[str],\n        vec_fp_regs: list[str],\n    ) -&gt; None:\n        \"\"\"Initializes the RegisterDiffAccessor object.\n\n        Args:\n            generic_regs (list[str]): The list of generic registers to include in the repr.\n            special_regs (list[str]): The list of special registers to include in the repr.\n            vec_fp_regs (list[str]): The list of vector and floating point registers to include in the repr.\n        \"\"\"\n        self._generic_regs = generic_regs\n        self._special_regs = special_regs\n        self._vec_fp_regs = vec_fp_regs\n\n    def __repr__(self: RegisterDiffAccessor) -&gt; str:\n        \"\"\"Return a string representation of the RegisterDiffAccessor object.\"\"\"\n        str_repr = \"RegisterDiffAccessor(\\n\\n\"\n\n        # Header with column alignment\n        str_repr += \"{:&lt;15} {:&lt;20} {:&lt;20}\\n\".format(\"Register\", \"Old Value\", \"New Value\")\n        str_repr += \"-\" * 60 + \"\\n\"\n\n        # Log all integer changes\n        for attr_name in self._generic_regs:\n            attr = self.__getattribute__(attr_name)\n\n            if attr.has_changed:\n                # Format integer values in hexadecimal without zero-padding\n                old_value = f\"{attr.old_value:&lt;18}\" if isinstance(attr.old_value, float) else f\"{attr.old_value:&lt;#16x}\"\n                new_value = f\"{attr.new_value:&lt;18}\" if isinstance(attr.new_value, float) else f\"{attr.new_value:&lt;#16x}\"\n                # Align output for consistent spacing between old and new values\n                str_repr += f\"{attr_name:&lt;15} {old_value} {new_value}\\n\"\n\n        return str_repr\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/registers/register_diff_accessor/#libdebug.snapshots.registers.register_diff_accessor.RegisterDiffAccessor.__init__","title":"<code>__init__(generic_regs, special_regs, vec_fp_regs)</code>","text":"<p>Initializes the RegisterDiffAccessor object.</p> <p>Parameters:</p> Name Type Description Default <code>generic_regs</code> <code>list[str]</code> <p>The list of generic registers to include in the repr.</p> required <code>special_regs</code> <code>list[str]</code> <p>The list of special registers to include in the repr.</p> required <code>vec_fp_regs</code> <code>list[str]</code> <p>The list of vector and floating point registers to include in the repr.</p> required Source code in <code>libdebug/snapshots/registers/register_diff_accessor.py</code> <pre><code>def __init__(\n    self: RegisterDiffAccessor,\n    generic_regs: list[str],\n    special_regs: list[str],\n    vec_fp_regs: list[str],\n) -&gt; None:\n    \"\"\"Initializes the RegisterDiffAccessor object.\n\n    Args:\n        generic_regs (list[str]): The list of generic registers to include in the repr.\n        special_regs (list[str]): The list of special registers to include in the repr.\n        vec_fp_regs (list[str]): The list of vector and floating point registers to include in the repr.\n    \"\"\"\n    self._generic_regs = generic_regs\n    self._special_regs = special_regs\n    self._vec_fp_regs = vec_fp_regs\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/registers/register_diff_accessor/#libdebug.snapshots.registers.register_diff_accessor.RegisterDiffAccessor.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the RegisterDiffAccessor object.</p> Source code in <code>libdebug/snapshots/registers/register_diff_accessor.py</code> <pre><code>def __repr__(self: RegisterDiffAccessor) -&gt; str:\n    \"\"\"Return a string representation of the RegisterDiffAccessor object.\"\"\"\n    str_repr = \"RegisterDiffAccessor(\\n\\n\"\n\n    # Header with column alignment\n    str_repr += \"{:&lt;15} {:&lt;20} {:&lt;20}\\n\".format(\"Register\", \"Old Value\", \"New Value\")\n    str_repr += \"-\" * 60 + \"\\n\"\n\n    # Log all integer changes\n    for attr_name in self._generic_regs:\n        attr = self.__getattribute__(attr_name)\n\n        if attr.has_changed:\n            # Format integer values in hexadecimal without zero-padding\n            old_value = f\"{attr.old_value:&lt;18}\" if isinstance(attr.old_value, float) else f\"{attr.old_value:&lt;#16x}\"\n            new_value = f\"{attr.new_value:&lt;18}\" if isinstance(attr.new_value, float) else f\"{attr.new_value:&lt;#16x}\"\n            # Align output for consistent spacing between old and new values\n            str_repr += f\"{attr_name:&lt;15} {old_value} {new_value}\\n\"\n\n    return str_repr\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/registers/snapshot_registers/","title":"libdebug.snapshots.registers.snapshot_registers","text":""},{"location":"from_pydoc/generated/snapshots/registers/snapshot_registers/#libdebug.snapshots.registers.snapshot_registers.SnapshotRegisters","title":"<code>SnapshotRegisters</code>","text":"<p>               Bases: <code>Registers</code></p> <p>Class that holds the state of the architectural-dependent registers of a snapshot.</p> Source code in <code>libdebug/snapshots/registers/snapshot_registers.py</code> <pre><code>class SnapshotRegisters(Registers):\n    \"\"\"Class that holds the state of the architectural-dependent registers of a snapshot.\"\"\"\n\n    def __init__(\n        self: SnapshotRegisters,\n        thread_id: int,\n        generic_regs: list[str],\n        special_regs: list[str],\n        vec_fp_regs: list[str],\n    ) -&gt; None:\n        \"\"\"Initializes the Registers object.\n\n        Args:\n            thread_id (int): The thread ID.\n            generic_regs (list[str]): The list of registers to include in the repr.\n            special_regs (list[str]): The list of special registers to include in the repr.\n            vec_fp_regs (list[str]): The list of vector and floating point registers to include in the repr\n        \"\"\"\n        self._thread_id = thread_id\n        self._generic_regs = generic_regs\n        self._special_regs = special_regs\n        self._vec_fp_regs = vec_fp_regs\n\n    def filter(self: SnapshotRegisters, value: float) -&gt; list[str]:\n        \"\"\"Filters the registers by value.\n\n        Args:\n            value (float): The value to search for.\n\n        Returns:\n            list[str]: A list of names of the registers containing the value.\n        \"\"\"\n        attributes = self.__dict__\n\n        return [attr for attr in attributes if getattr(self, attr) == value]\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/registers/snapshot_registers/#libdebug.snapshots.registers.snapshot_registers.SnapshotRegisters.__init__","title":"<code>__init__(thread_id, generic_regs, special_regs, vec_fp_regs)</code>","text":"<p>Initializes the Registers object.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>The thread ID.</p> required <code>generic_regs</code> <code>list[str]</code> <p>The list of registers to include in the repr.</p> required <code>special_regs</code> <code>list[str]</code> <p>The list of special registers to include in the repr.</p> required <code>vec_fp_regs</code> <code>list[str]</code> <p>The list of vector and floating point registers to include in the repr</p> required Source code in <code>libdebug/snapshots/registers/snapshot_registers.py</code> <pre><code>def __init__(\n    self: SnapshotRegisters,\n    thread_id: int,\n    generic_regs: list[str],\n    special_regs: list[str],\n    vec_fp_regs: list[str],\n) -&gt; None:\n    \"\"\"Initializes the Registers object.\n\n    Args:\n        thread_id (int): The thread ID.\n        generic_regs (list[str]): The list of registers to include in the repr.\n        special_regs (list[str]): The list of special registers to include in the repr.\n        vec_fp_regs (list[str]): The list of vector and floating point registers to include in the repr\n    \"\"\"\n    self._thread_id = thread_id\n    self._generic_regs = generic_regs\n    self._special_regs = special_regs\n    self._vec_fp_regs = vec_fp_regs\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/registers/snapshot_registers/#libdebug.snapshots.registers.snapshot_registers.SnapshotRegisters.filter","title":"<code>filter(value)</code>","text":"<p>Filters the registers by value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of names of the registers containing the value.</p> Source code in <code>libdebug/snapshots/registers/snapshot_registers.py</code> <pre><code>def filter(self: SnapshotRegisters, value: float) -&gt; list[str]:\n    \"\"\"Filters the registers by value.\n\n    Args:\n        value (float): The value to search for.\n\n    Returns:\n        list[str]: A list of names of the registers containing the value.\n    \"\"\"\n    attributes = self.__dict__\n\n    return [attr for attr in attributes if getattr(self, attr) == value]\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/json_serializer/","title":"libdebug.snapshots.serialization.json_serializer","text":""},{"location":"from_pydoc/generated/snapshots/serialization/json_serializer/#libdebug.snapshots.serialization.json_serializer.JSONSerializer","title":"<code>JSONSerializer</code>","text":"<p>Helper class to serialize and deserialize snapshots using JSON format.</p> Source code in <code>libdebug/snapshots/serialization/json_serializer.py</code> <pre><code>class JSONSerializer:\n    \"\"\"Helper class to serialize and deserialize snapshots using JSON format.\"\"\"\n\n    def load(self: JSONSerializer, file_path: str) -&gt; Snapshot:\n        \"\"\"Load a snapshot from a JSON file.\n\n        Args:\n            file_path (str): The path to the JSON file containing the snapshot.\n\n        Returns:\n            Snapshot: The loaded snapshot object.\n        \"\"\"\n        with Path(file_path).open() as file:\n            snapshot_dict = json.load(file)\n\n        # Determine the type of snapshot\n        is_process_snapshot = \"process_id\" in snapshot_dict\n\n        # Create a new instance of the appropriate class\n        if is_process_snapshot:\n            loaded_snap = ProcessSnapshot.__new__(ProcessSnapshot)\n            loaded_snap.process_id = snapshot_dict[\"process_id\"]\n            loaded_snap.pid = loaded_snap.process_id\n        else:\n            loaded_snap = ThreadSnapshot.__new__(ThreadSnapshot)\n            loaded_snap.thread_id = snapshot_dict[\"thread_id\"]\n            loaded_snap.tid = loaded_snap.thread_id\n\n        # Basic snapshot info\n        loaded_snap.snapshot_id = snapshot_dict[\"snapshot_id\"]\n        loaded_snap.arch = snapshot_dict[\"arch\"]\n        loaded_snap.name = snapshot_dict[\"name\"]\n        loaded_snap.level = snapshot_dict[\"level\"]\n        loaded_snap.aslr_enabled = snapshot_dict.get(\"aslr_enabled\")\n        loaded_snap._process_full_path = snapshot_dict.get(\"_process_full_path\", None)\n        loaded_snap._process_name = snapshot_dict.get(\"_process_name\", None)\n\n        # Create a register field for the snapshot\n        if not is_process_snapshot:\n            loaded_snap.regs = SnapshotRegisters(\n                loaded_snap.thread_id,\n                snapshot_dict[\"architectural_registers\"][\"generic\"],\n                snapshot_dict[\"architectural_registers\"][\"special\"],\n                snapshot_dict[\"architectural_registers\"][\"vector_fp\"],\n            )\n\n            # Load registers\n            for reg_name, reg_value in snapshot_dict[\"regs\"].items():\n                loaded_snap.regs.__setattr__(reg_name, reg_value)\n\n        # Recreate memory maps\n        loaded_maps = snapshot_dict[\"maps\"]\n        raw_map_list = []\n\n        for saved_map in loaded_maps:\n            new_map = MemoryMapSnapshot(\n                saved_map[\"start\"],\n                saved_map[\"end\"],\n                saved_map[\"permissions\"],\n                saved_map[\"size\"],\n                saved_map[\"offset\"],\n                saved_map[\"backing_file\"],\n                b64decode(saved_map[\"content\"]) if saved_map[\"content\"] is not None else None,\n            )\n            raw_map_list.append(new_map)\n\n        loaded_snap.maps = MemoryMapSnapshotList(\n            raw_map_list,\n            loaded_snap._process_name,\n            loaded_snap._process_full_path,\n        )\n\n        # Handle threads for ProcessSnapshot\n        if is_process_snapshot:\n            loaded_snap.threads = []\n            for thread_dict in snapshot_dict[\"threads\"]:\n                thread_snap = LightweightThreadSnapshot.__new__(LightweightThreadSnapshot)\n                thread_snap.snapshot_id = thread_dict[\"snapshot_id\"]\n                thread_snap.thread_id = thread_dict[\"thread_id\"]\n                thread_snap.tid = thread_snap.thread_id\n                thread_snap._proc_snapshot = loaded_snap\n\n                thread_snap.regs = SnapshotRegisters(\n                    thread_snap.thread_id,\n                    snapshot_dict[\"architectural_registers\"][\"generic\"],\n                    snapshot_dict[\"architectural_registers\"][\"special\"],\n                    snapshot_dict[\"architectural_registers\"][\"vector_fp\"],\n                )\n\n                for reg_name, reg_value in thread_dict[\"regs\"].items():\n                    thread_snap.regs.__setattr__(reg_name, reg_value)\n\n                loaded_snap.threads.append(thread_snap)\n\n        # Handle symbols\n        raw_loaded_symbols = snapshot_dict.get(\"symbols\", None)\n        if raw_loaded_symbols is not None:\n            sym_list = [\n                Symbol(\n                    saved_symbol[\"start\"],\n                    saved_symbol[\"end\"],\n                    saved_symbol[\"name\"],\n                    saved_symbol[\"backing_file\"],\n                )\n                for saved_symbol in raw_loaded_symbols\n            ]\n            sym_list = SymbolList(sym_list, loaded_snap)\n            loaded_snap._memory = SnapshotMemoryView(loaded_snap, sym_list)\n        elif loaded_snap.level != \"base\":\n            raise ValueError(\"Memory snapshot loading requested but no symbols were saved.\")\n        else:\n            loaded_snap._memory = None\n\n        return loaded_snap\n\n    def dump(self: JSONSerializer, snapshot: Snapshot, out_path: str) -&gt; None:\n        \"\"\"Dump a snapshot to a JSON file.\n\n        Args:\n            snapshot (Snapshot): The snapshot to be dumped.\n            out_path (str): The path to the output JSON file.\n        \"\"\"\n\n        def get_register_names(regs: SnapshotRegisters) -&gt; list[str]:\n            return [reg_name for reg_name in dir(regs) if isinstance(getattr(regs, reg_name), int | float)]\n\n        def save_memory_maps(maps: MemoryMapSnapshotList) -&gt; list[dict]:\n            return [\n                {\n                    \"start\": memory_map.start,\n                    \"end\": memory_map.end,\n                    \"permissions\": memory_map.permissions,\n                    \"size\": memory_map.size,\n                    \"offset\": memory_map.offset,\n                    \"backing_file\": memory_map.backing_file,\n                    \"content\": b64encode(memory_map.content).decode(\"utf-8\")\n                    if memory_map.content is not None\n                    else None,\n                }\n                for memory_map in maps\n            ]\n\n        def save_symbols(memory: SnapshotMemoryView) -&gt; list[dict] | None:\n            if memory is None:\n                return None\n            return [\n                {\n                    \"start\": symbol.start,\n                    \"end\": symbol.end,\n                    \"name\": symbol.name,\n                    \"backing_file\": symbol.backing_file,\n                }\n                for symbol in memory._symbol_ref\n            ]\n\n        all_reg_names = get_register_names(snapshot.regs)\n\n        serializable_dict = {\n            \"type\": \"process\" if hasattr(snapshot, \"threads\") else \"thread\",\n            \"arch\": snapshot.arch,\n            \"snapshot_id\": snapshot.snapshot_id,\n            \"level\": snapshot.level,\n            \"name\": snapshot.name,\n            \"aslr_enabled\": snapshot.aslr_enabled,\n            \"architectural_registers\": {\n                \"generic\": snapshot.regs._generic_regs,\n                \"special\": snapshot.regs._special_regs,\n                \"vector_fp\": snapshot.regs._vec_fp_regs,\n            },\n            \"maps\": save_memory_maps(snapshot.maps),\n            \"symbols\": save_symbols(snapshot._memory),\n        }\n\n        if hasattr(snapshot, \"threads\"):\n            # ProcessSnapshot-specific data\n            thread_snapshots = [\n                {\n                    \"snapshot_id\": thread.snapshot_id,\n                    \"thread_id\": thread.thread_id,\n                    \"regs\": {reg_name: getattr(thread.regs, reg_name) for reg_name in all_reg_names},\n                }\n                for thread in snapshot.threads\n            ]\n            serializable_dict.update(\n                {\n                    \"process_id\": snapshot.process_id,\n                    \"threads\": thread_snapshots,\n                    \"_process_full_path\": snapshot._process_full_path,\n                    \"_process_name\": snapshot._process_name,\n                }\n            )\n        else:\n            # ThreadSnapshot-specific data\n            serializable_dict.update(\n                {\n                    \"thread_id\": snapshot.thread_id,\n                    \"regs\": {reg_name: getattr(snapshot.regs, reg_name) for reg_name in all_reg_names},\n                    \"_process_full_path\": snapshot._process_full_path,\n                    \"_process_name\": snapshot._process_name,\n                }\n            )\n\n        with Path(out_path).open(\"w\") as file:\n            json.dump(serializable_dict, file)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/json_serializer/#libdebug.snapshots.serialization.json_serializer.JSONSerializer.dump","title":"<code>dump(snapshot, out_path)</code>","text":"<p>Dump a snapshot to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot</code> <code>Snapshot</code> <p>The snapshot to be dumped.</p> required <code>out_path</code> <code>str</code> <p>The path to the output JSON file.</p> required Source code in <code>libdebug/snapshots/serialization/json_serializer.py</code> <pre><code>def dump(self: JSONSerializer, snapshot: Snapshot, out_path: str) -&gt; None:\n    \"\"\"Dump a snapshot to a JSON file.\n\n    Args:\n        snapshot (Snapshot): The snapshot to be dumped.\n        out_path (str): The path to the output JSON file.\n    \"\"\"\n\n    def get_register_names(regs: SnapshotRegisters) -&gt; list[str]:\n        return [reg_name for reg_name in dir(regs) if isinstance(getattr(regs, reg_name), int | float)]\n\n    def save_memory_maps(maps: MemoryMapSnapshotList) -&gt; list[dict]:\n        return [\n            {\n                \"start\": memory_map.start,\n                \"end\": memory_map.end,\n                \"permissions\": memory_map.permissions,\n                \"size\": memory_map.size,\n                \"offset\": memory_map.offset,\n                \"backing_file\": memory_map.backing_file,\n                \"content\": b64encode(memory_map.content).decode(\"utf-8\")\n                if memory_map.content is not None\n                else None,\n            }\n            for memory_map in maps\n        ]\n\n    def save_symbols(memory: SnapshotMemoryView) -&gt; list[dict] | None:\n        if memory is None:\n            return None\n        return [\n            {\n                \"start\": symbol.start,\n                \"end\": symbol.end,\n                \"name\": symbol.name,\n                \"backing_file\": symbol.backing_file,\n            }\n            for symbol in memory._symbol_ref\n        ]\n\n    all_reg_names = get_register_names(snapshot.regs)\n\n    serializable_dict = {\n        \"type\": \"process\" if hasattr(snapshot, \"threads\") else \"thread\",\n        \"arch\": snapshot.arch,\n        \"snapshot_id\": snapshot.snapshot_id,\n        \"level\": snapshot.level,\n        \"name\": snapshot.name,\n        \"aslr_enabled\": snapshot.aslr_enabled,\n        \"architectural_registers\": {\n            \"generic\": snapshot.regs._generic_regs,\n            \"special\": snapshot.regs._special_regs,\n            \"vector_fp\": snapshot.regs._vec_fp_regs,\n        },\n        \"maps\": save_memory_maps(snapshot.maps),\n        \"symbols\": save_symbols(snapshot._memory),\n    }\n\n    if hasattr(snapshot, \"threads\"):\n        # ProcessSnapshot-specific data\n        thread_snapshots = [\n            {\n                \"snapshot_id\": thread.snapshot_id,\n                \"thread_id\": thread.thread_id,\n                \"regs\": {reg_name: getattr(thread.regs, reg_name) for reg_name in all_reg_names},\n            }\n            for thread in snapshot.threads\n        ]\n        serializable_dict.update(\n            {\n                \"process_id\": snapshot.process_id,\n                \"threads\": thread_snapshots,\n                \"_process_full_path\": snapshot._process_full_path,\n                \"_process_name\": snapshot._process_name,\n            }\n        )\n    else:\n        # ThreadSnapshot-specific data\n        serializable_dict.update(\n            {\n                \"thread_id\": snapshot.thread_id,\n                \"regs\": {reg_name: getattr(snapshot.regs, reg_name) for reg_name in all_reg_names},\n                \"_process_full_path\": snapshot._process_full_path,\n                \"_process_name\": snapshot._process_name,\n            }\n        )\n\n    with Path(out_path).open(\"w\") as file:\n        json.dump(serializable_dict, file)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/json_serializer/#libdebug.snapshots.serialization.json_serializer.JSONSerializer.load","title":"<code>load(file_path)</code>","text":"<p>Load a snapshot from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the JSON file containing the snapshot.</p> required <p>Returns:</p> Name Type Description <code>Snapshot</code> <code>Snapshot</code> <p>The loaded snapshot object.</p> Source code in <code>libdebug/snapshots/serialization/json_serializer.py</code> <pre><code>def load(self: JSONSerializer, file_path: str) -&gt; Snapshot:\n    \"\"\"Load a snapshot from a JSON file.\n\n    Args:\n        file_path (str): The path to the JSON file containing the snapshot.\n\n    Returns:\n        Snapshot: The loaded snapshot object.\n    \"\"\"\n    with Path(file_path).open() as file:\n        snapshot_dict = json.load(file)\n\n    # Determine the type of snapshot\n    is_process_snapshot = \"process_id\" in snapshot_dict\n\n    # Create a new instance of the appropriate class\n    if is_process_snapshot:\n        loaded_snap = ProcessSnapshot.__new__(ProcessSnapshot)\n        loaded_snap.process_id = snapshot_dict[\"process_id\"]\n        loaded_snap.pid = loaded_snap.process_id\n    else:\n        loaded_snap = ThreadSnapshot.__new__(ThreadSnapshot)\n        loaded_snap.thread_id = snapshot_dict[\"thread_id\"]\n        loaded_snap.tid = loaded_snap.thread_id\n\n    # Basic snapshot info\n    loaded_snap.snapshot_id = snapshot_dict[\"snapshot_id\"]\n    loaded_snap.arch = snapshot_dict[\"arch\"]\n    loaded_snap.name = snapshot_dict[\"name\"]\n    loaded_snap.level = snapshot_dict[\"level\"]\n    loaded_snap.aslr_enabled = snapshot_dict.get(\"aslr_enabled\")\n    loaded_snap._process_full_path = snapshot_dict.get(\"_process_full_path\", None)\n    loaded_snap._process_name = snapshot_dict.get(\"_process_name\", None)\n\n    # Create a register field for the snapshot\n    if not is_process_snapshot:\n        loaded_snap.regs = SnapshotRegisters(\n            loaded_snap.thread_id,\n            snapshot_dict[\"architectural_registers\"][\"generic\"],\n            snapshot_dict[\"architectural_registers\"][\"special\"],\n            snapshot_dict[\"architectural_registers\"][\"vector_fp\"],\n        )\n\n        # Load registers\n        for reg_name, reg_value in snapshot_dict[\"regs\"].items():\n            loaded_snap.regs.__setattr__(reg_name, reg_value)\n\n    # Recreate memory maps\n    loaded_maps = snapshot_dict[\"maps\"]\n    raw_map_list = []\n\n    for saved_map in loaded_maps:\n        new_map = MemoryMapSnapshot(\n            saved_map[\"start\"],\n            saved_map[\"end\"],\n            saved_map[\"permissions\"],\n            saved_map[\"size\"],\n            saved_map[\"offset\"],\n            saved_map[\"backing_file\"],\n            b64decode(saved_map[\"content\"]) if saved_map[\"content\"] is not None else None,\n        )\n        raw_map_list.append(new_map)\n\n    loaded_snap.maps = MemoryMapSnapshotList(\n        raw_map_list,\n        loaded_snap._process_name,\n        loaded_snap._process_full_path,\n    )\n\n    # Handle threads for ProcessSnapshot\n    if is_process_snapshot:\n        loaded_snap.threads = []\n        for thread_dict in snapshot_dict[\"threads\"]:\n            thread_snap = LightweightThreadSnapshot.__new__(LightweightThreadSnapshot)\n            thread_snap.snapshot_id = thread_dict[\"snapshot_id\"]\n            thread_snap.thread_id = thread_dict[\"thread_id\"]\n            thread_snap.tid = thread_snap.thread_id\n            thread_snap._proc_snapshot = loaded_snap\n\n            thread_snap.regs = SnapshotRegisters(\n                thread_snap.thread_id,\n                snapshot_dict[\"architectural_registers\"][\"generic\"],\n                snapshot_dict[\"architectural_registers\"][\"special\"],\n                snapshot_dict[\"architectural_registers\"][\"vector_fp\"],\n            )\n\n            for reg_name, reg_value in thread_dict[\"regs\"].items():\n                thread_snap.regs.__setattr__(reg_name, reg_value)\n\n            loaded_snap.threads.append(thread_snap)\n\n    # Handle symbols\n    raw_loaded_symbols = snapshot_dict.get(\"symbols\", None)\n    if raw_loaded_symbols is not None:\n        sym_list = [\n            Symbol(\n                saved_symbol[\"start\"],\n                saved_symbol[\"end\"],\n                saved_symbol[\"name\"],\n                saved_symbol[\"backing_file\"],\n            )\n            for saved_symbol in raw_loaded_symbols\n        ]\n        sym_list = SymbolList(sym_list, loaded_snap)\n        loaded_snap._memory = SnapshotMemoryView(loaded_snap, sym_list)\n    elif loaded_snap.level != \"base\":\n        raise ValueError(\"Memory snapshot loading requested but no symbols were saved.\")\n    else:\n        loaded_snap._memory = None\n\n    return loaded_snap\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/serialization_helper/","title":"libdebug.snapshots.serialization.serialization_helper","text":""},{"location":"from_pydoc/generated/snapshots/serialization/serialization_helper/#libdebug.snapshots.serialization.serialization_helper.SerializationHelper","title":"<code>SerializationHelper</code>","text":"<p>Helper class to serialize and deserialize snapshots.</p> Source code in <code>libdebug/snapshots/serialization/serialization_helper.py</code> <pre><code>class SerializationHelper:\n    \"\"\"Helper class to serialize and deserialize snapshots.\"\"\"\n\n    def load(self: SerializationHelper, file_path: str) -&gt; Snapshot:\n        \"\"\"Load a snapshot from a file.\n\n        Args:\n            file_path (str): The path to the file containing the snapshot.\n\n        Returns:\n            Snapshot: The loaded snapshot object.\n        \"\"\"\n        if not file_path.endswith(\".json\"):\n            liblog.warning(\"The target file doesn't have a JSON extension. The output will be assumed JSON.\")\n\n        # Future code can select the serializer\n        # Currently, only JSON is supported\n        serializer_type = SupportedSerializers.JSON\n\n        serializer = serializer_type.serializer_class()\n\n        return serializer.load(file_path)\n\n    def save(self: SerializationHelper, snapshot: Snapshot, out_path: str) -&gt; None:\n        \"\"\"Dump a snapshot to a file.\n\n        Args:\n            snapshot (Snapshot): The snapshot to be dumped.\n            out_path (str): The path to the output file.\n        \"\"\"\n        if not out_path.endswith(\".json\"):\n            liblog.warning(\"The target file doesn't have a JSON extension. The output will be assumed JSON.\")\n\n        # Future code can select the serializer\n        # Currently, only JSON is supported\n        serializer_type = SupportedSerializers.JSON\n\n        serializer = serializer_type.serializer_class()\n\n        serializer.dump(snapshot, out_path)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/serialization_helper/#libdebug.snapshots.serialization.serialization_helper.SerializationHelper.load","title":"<code>load(file_path)</code>","text":"<p>Load a snapshot from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file containing the snapshot.</p> required <p>Returns:</p> Name Type Description <code>Snapshot</code> <code>Snapshot</code> <p>The loaded snapshot object.</p> Source code in <code>libdebug/snapshots/serialization/serialization_helper.py</code> <pre><code>def load(self: SerializationHelper, file_path: str) -&gt; Snapshot:\n    \"\"\"Load a snapshot from a file.\n\n    Args:\n        file_path (str): The path to the file containing the snapshot.\n\n    Returns:\n        Snapshot: The loaded snapshot object.\n    \"\"\"\n    if not file_path.endswith(\".json\"):\n        liblog.warning(\"The target file doesn't have a JSON extension. The output will be assumed JSON.\")\n\n    # Future code can select the serializer\n    # Currently, only JSON is supported\n    serializer_type = SupportedSerializers.JSON\n\n    serializer = serializer_type.serializer_class()\n\n    return serializer.load(file_path)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/serialization_helper/#libdebug.snapshots.serialization.serialization_helper.SerializationHelper.save","title":"<code>save(snapshot, out_path)</code>","text":"<p>Dump a snapshot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot</code> <code>Snapshot</code> <p>The snapshot to be dumped.</p> required <code>out_path</code> <code>str</code> <p>The path to the output file.</p> required Source code in <code>libdebug/snapshots/serialization/serialization_helper.py</code> <pre><code>def save(self: SerializationHelper, snapshot: Snapshot, out_path: str) -&gt; None:\n    \"\"\"Dump a snapshot to a file.\n\n    Args:\n        snapshot (Snapshot): The snapshot to be dumped.\n        out_path (str): The path to the output file.\n    \"\"\"\n    if not out_path.endswith(\".json\"):\n        liblog.warning(\"The target file doesn't have a JSON extension. The output will be assumed JSON.\")\n\n    # Future code can select the serializer\n    # Currently, only JSON is supported\n    serializer_type = SupportedSerializers.JSON\n\n    serializer = serializer_type.serializer_class()\n\n    serializer.dump(snapshot, out_path)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/serializer/","title":"libdebug.snapshots.serialization.serializer","text":""},{"location":"from_pydoc/generated/snapshots/serialization/serializer/#libdebug.snapshots.serialization.serializer.AbstractSerializer","title":"<code>AbstractSerializer</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Helper class to serialize and deserialize snapshots.</p> Source code in <code>libdebug/snapshots/serialization/serializer.py</code> <pre><code>class AbstractSerializer(ABC):\n    \"\"\"Helper class to serialize and deserialize snapshots.\"\"\"\n\n    @abstractmethod\n    def load(self: AbstractSerializer, file_path: str) -&gt; Snapshot:\n        \"\"\"Load a snapshot from a file.\n\n        Args:\n            file_path (str): The path to the file containing the snapshot.\n\n        Returns:\n            Snapshot: The loaded snapshot object.\n        \"\"\"\n\n    @abstractmethod\n    def dump(self: AbstractSerializer, snapshot: Snapshot, out_path: str) -&gt; None:\n        \"\"\"Dump a snapshot to a file.\n\n        Args:\n            snapshot (Snapshot): The snapshot to be dumped.\n            out_path (str): The path to the output file.\n        \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/serializer/#libdebug.snapshots.serialization.serializer.AbstractSerializer.dump","title":"<code>dump(snapshot, out_path)</code>  <code>abstractmethod</code>","text":"<p>Dump a snapshot to a file.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot</code> <code>Snapshot</code> <p>The snapshot to be dumped.</p> required <code>out_path</code> <code>str</code> <p>The path to the output file.</p> required Source code in <code>libdebug/snapshots/serialization/serializer.py</code> <pre><code>@abstractmethod\ndef dump(self: AbstractSerializer, snapshot: Snapshot, out_path: str) -&gt; None:\n    \"\"\"Dump a snapshot to a file.\n\n    Args:\n        snapshot (Snapshot): The snapshot to be dumped.\n        out_path (str): The path to the output file.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/serializer/#libdebug.snapshots.serialization.serializer.AbstractSerializer.load","title":"<code>load(file_path)</code>  <code>abstractmethod</code>","text":"<p>Load a snapshot from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file containing the snapshot.</p> required <p>Returns:</p> Name Type Description <code>Snapshot</code> <code>Snapshot</code> <p>The loaded snapshot object.</p> Source code in <code>libdebug/snapshots/serialization/serializer.py</code> <pre><code>@abstractmethod\ndef load(self: AbstractSerializer, file_path: str) -&gt; Snapshot:\n    \"\"\"Load a snapshot from a file.\n\n    Args:\n        file_path (str): The path to the file containing the snapshot.\n\n    Returns:\n        Snapshot: The loaded snapshot object.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/supported_serializers/","title":"libdebug.snapshots.serialization.supported_serializers","text":""},{"location":"from_pydoc/generated/snapshots/serialization/supported_serializers/#libdebug.snapshots.serialization.supported_serializers.SupportedSerializers","title":"<code>SupportedSerializers</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration of supported serializers for snapshots.</p> Source code in <code>libdebug/snapshots/serialization/supported_serializers.py</code> <pre><code>class SupportedSerializers(Enum):\n    \"\"\"Enumeration of supported serializers for snapshots.\"\"\"\n    JSON = JSONSerializer\n\n    @property\n    def serializer_class(self: SupportedSerializers) -&gt; AbstractSerializer:\n        \"\"\"Return the serializer class.\"\"\"\n        return self.value\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/serialization/supported_serializers/#libdebug.snapshots.serialization.supported_serializers.SupportedSerializers.serializer_class","title":"<code>serializer_class</code>  <code>property</code>","text":"<p>Return the serializer class.</p>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot/","title":"libdebug.snapshots.thread.lw_thread_snapshot","text":""},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot/#libdebug.snapshots.thread.lw_thread_snapshot.LightweightThreadSnapshot","title":"<code>LightweightThreadSnapshot</code>","text":"<p>               Bases: <code>ThreadSnapshot</code></p> <p>This object represents a snapshot of the target thread. It has to be initialized by a ProcessSnapshot, since it initializes its properties with shared process state. It holds information about a thread's state.</p> <p>Snapshot levels: - base: Registers - writable: Registers, writable memory contents - full: Registers, all readable memory contents</p> Source code in <code>libdebug/snapshots/thread/lw_thread_snapshot.py</code> <pre><code>class LightweightThreadSnapshot(ThreadSnapshot):\n    \"\"\"This object represents a snapshot of the target thread. It has to be initialized by a ProcessSnapshot, since it initializes its properties with shared process state. It holds information about a thread's state.\n\n    Snapshot levels:\n    - base: Registers\n    - writable: Registers, writable memory contents\n    - full: Registers, all readable memory contents\n    \"\"\"\n\n    def __init__(\n        self: LightweightThreadSnapshot,\n        thread: ThreadContext,\n        process_snapshot: ProcessSnapshot,\n    ) -&gt; None:\n        \"\"\"Creates a new snapshot object for the given thread.\n\n        Args:\n            thread (ThreadContext): The thread to take a snapshot of.\n            process_snapshot (ProcessSnapshot): The process snapshot to which the thread belongs.\n        \"\"\"\n        # Set id of the snapshot and increment the counter\n        self.snapshot_id = thread._snapshot_count\n        thread.notify_snapshot_taken()\n\n        # Basic snapshot info\n        self.thread_id = thread.thread_id\n        self.tid = thread.tid\n\n        # If there is a name, append the thread id\n        if process_snapshot.name is None:\n            self.name = None\n        else:\n            self.name = f\"{process_snapshot.name} - Thread {self.tid}\"\n\n        # Get thread registers\n        self._save_regs(thread)\n\n        self._proc_snapshot = process_snapshot\n\n    @property\n    def level(self: LightweightThreadSnapshot) -&gt; str:\n        \"\"\"Returns the snapshot level.\"\"\"\n        return self._proc_snapshot.level\n\n    @property\n    def arch(self: LightweightThreadSnapshot) -&gt; str:\n        \"\"\"Returns the architecture of the thread snapshot.\"\"\"\n        return self._proc_snapshot.arch\n\n    @property\n    def maps(self: LightweightThreadSnapshot) -&gt; MemoryMapSnapshotList:\n        \"\"\"Returns the memory map snapshot list associated with the process snapshot.\"\"\"\n        return self._proc_snapshot.maps\n\n    @property\n    def _memory(self: LightweightThreadSnapshot) -&gt; SnapshotMemoryView:\n        \"\"\"Returns the memory view associated with the process snapshot.\"\"\"\n        return self._proc_snapshot._memory\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot/#libdebug.snapshots.thread.lw_thread_snapshot.LightweightThreadSnapshot._memory","title":"<code>_memory</code>  <code>property</code>","text":"<p>Returns the memory view associated with the process snapshot.</p>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot/#libdebug.snapshots.thread.lw_thread_snapshot.LightweightThreadSnapshot.arch","title":"<code>arch</code>  <code>property</code>","text":"<p>Returns the architecture of the thread snapshot.</p>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot/#libdebug.snapshots.thread.lw_thread_snapshot.LightweightThreadSnapshot.level","title":"<code>level</code>  <code>property</code>","text":"<p>Returns the snapshot level.</p>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot/#libdebug.snapshots.thread.lw_thread_snapshot.LightweightThreadSnapshot.maps","title":"<code>maps</code>  <code>property</code>","text":"<p>Returns the memory map snapshot list associated with the process snapshot.</p>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot/#libdebug.snapshots.thread.lw_thread_snapshot.LightweightThreadSnapshot.__init__","title":"<code>__init__(thread, process_snapshot)</code>","text":"<p>Creates a new snapshot object for the given thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to take a snapshot of.</p> required <code>process_snapshot</code> <code>ProcessSnapshot</code> <p>The process snapshot to which the thread belongs.</p> required Source code in <code>libdebug/snapshots/thread/lw_thread_snapshot.py</code> <pre><code>def __init__(\n    self: LightweightThreadSnapshot,\n    thread: ThreadContext,\n    process_snapshot: ProcessSnapshot,\n) -&gt; None:\n    \"\"\"Creates a new snapshot object for the given thread.\n\n    Args:\n        thread (ThreadContext): The thread to take a snapshot of.\n        process_snapshot (ProcessSnapshot): The process snapshot to which the thread belongs.\n    \"\"\"\n    # Set id of the snapshot and increment the counter\n    self.snapshot_id = thread._snapshot_count\n    thread.notify_snapshot_taken()\n\n    # Basic snapshot info\n    self.thread_id = thread.thread_id\n    self.tid = thread.tid\n\n    # If there is a name, append the thread id\n    if process_snapshot.name is None:\n        self.name = None\n    else:\n        self.name = f\"{process_snapshot.name} - Thread {self.tid}\"\n\n    # Get thread registers\n    self._save_regs(thread)\n\n    self._proc_snapshot = process_snapshot\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot_diff/","title":"libdebug.snapshots.thread.lw_thread_snapshot_diff","text":""},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot_diff/#libdebug.snapshots.thread.lw_thread_snapshot_diff.LightweightThreadSnapshotDiff","title":"<code>LightweightThreadSnapshotDiff</code>","text":"<p>               Bases: <code>ThreadSnapshotDiff</code></p> <p>This object represents a diff between thread snapshots.</p> Source code in <code>libdebug/snapshots/thread/lw_thread_snapshot_diff.py</code> <pre><code>class LightweightThreadSnapshotDiff(ThreadSnapshotDiff):\n    \"\"\"This object represents a diff between thread snapshots.\"\"\"\n\n    def __init__(\n        self: LightweightThreadSnapshotDiff,\n        snapshot1: ThreadSnapshot,\n        snapshot2: ThreadSnapshot,\n        process_diff: ProcessSnapshotDiff,\n    ) -&gt; ThreadSnapshotDiff:\n        \"\"\"Returns a diff between given snapshots of the same thread.\n\n        Args:\n            snapshot1 (ThreadSnapshot): A thread snapshot.\n            snapshot2 (ThreadSnapshot): A thread snapshot.\n            process_diff (ProcessSnapshotDiff): The diff of the process to which the thread belongs.\n        \"\"\"\n        # Generic diff initialization\n        Diff.__init__(self, snapshot1, snapshot2)\n\n        # Register diffs\n        self._save_reg_diffs()\n\n        self._proc_diff = process_diff\n\n    @property\n    def maps(self: LightweightThreadSnapshotDiff) -&gt; list[MemoryMapDiff]:\n        \"\"\"Return the memory map diff.\"\"\"\n        return self._proc_diff.maps\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot_diff/#libdebug.snapshots.thread.lw_thread_snapshot_diff.LightweightThreadSnapshotDiff.maps","title":"<code>maps</code>  <code>property</code>","text":"<p>Return the memory map diff.</p>"},{"location":"from_pydoc/generated/snapshots/thread/lw_thread_snapshot_diff/#libdebug.snapshots.thread.lw_thread_snapshot_diff.LightweightThreadSnapshotDiff.__init__","title":"<code>__init__(snapshot1, snapshot2, process_diff)</code>","text":"<p>Returns a diff between given snapshots of the same thread.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot1</code> <code>ThreadSnapshot</code> <p>A thread snapshot.</p> required <code>snapshot2</code> <code>ThreadSnapshot</code> <p>A thread snapshot.</p> required <code>process_diff</code> <code>ProcessSnapshotDiff</code> <p>The diff of the process to which the thread belongs.</p> required Source code in <code>libdebug/snapshots/thread/lw_thread_snapshot_diff.py</code> <pre><code>def __init__(\n    self: LightweightThreadSnapshotDiff,\n    snapshot1: ThreadSnapshot,\n    snapshot2: ThreadSnapshot,\n    process_diff: ProcessSnapshotDiff,\n) -&gt; ThreadSnapshotDiff:\n    \"\"\"Returns a diff between given snapshots of the same thread.\n\n    Args:\n        snapshot1 (ThreadSnapshot): A thread snapshot.\n        snapshot2 (ThreadSnapshot): A thread snapshot.\n        process_diff (ProcessSnapshotDiff): The diff of the process to which the thread belongs.\n    \"\"\"\n    # Generic diff initialization\n    Diff.__init__(self, snapshot1, snapshot2)\n\n    # Register diffs\n    self._save_reg_diffs()\n\n    self._proc_diff = process_diff\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/thread/thread_snapshot/","title":"libdebug.snapshots.thread.thread_snapshot","text":""},{"location":"from_pydoc/generated/snapshots/thread/thread_snapshot/#libdebug.snapshots.thread.thread_snapshot.ThreadSnapshot","title":"<code>ThreadSnapshot</code>","text":"<p>               Bases: <code>Snapshot</code></p> <p>This object represents a snapshot of the target thread. It holds information about a thread's state.</p> <p>Snapshot levels: - base: Registers - writable: Registers, writable memory contents - full: Registers, all readable memory contents</p> Source code in <code>libdebug/snapshots/thread/thread_snapshot.py</code> <pre><code>class ThreadSnapshot(Snapshot):\n    \"\"\"This object represents a snapshot of the target thread. It holds information about a thread's state.\n\n    Snapshot levels:\n    - base: Registers\n    - writable: Registers, writable memory contents\n    - full: Registers, all readable memory contents\n    \"\"\"\n\n    def __init__(self: ThreadSnapshot, thread: ThreadContext, level: str = \"base\", name: str | None = None) -&gt; None:\n        \"\"\"Creates a new snapshot object for the given thread.\n\n        Args:\n            thread (ThreadContext): The thread to take a snapshot of.\n            level (str, optional): The level of the snapshot. Defaults to \"base\".\n            name (str, optional): A name associated to the snapshot. Defaults to None.\n        \"\"\"\n        # Set id of the snapshot and increment the counter\n        self.snapshot_id = thread._snapshot_count\n        thread.notify_snapshot_taken()\n\n        # Basic snapshot info\n        self.thread_id = thread.thread_id\n        self.tid = thread.tid\n        self.name = name\n        self.level = level\n        self.arch = thread._internal_debugger.arch\n        self.aslr_enabled = thread._internal_debugger.aslr_enabled\n        self._process_full_path = thread.debugger._internal_debugger._process_full_path\n        self._process_name = thread.debugger._internal_debugger._process_name\n        self._serialization_helper = thread._internal_debugger.serialization_helper\n\n        # Get thread registers\n        self._save_regs(thread)\n\n        # Memory maps\n        match level:\n            case \"base\":\n                map_list = []\n\n                for curr_map in thread.debugger.maps:\n                    saved_map = MemoryMapSnapshot(\n                        start=curr_map.start,\n                        end=curr_map.end,\n                        permissions=curr_map.permissions,\n                        size=curr_map.size,\n                        offset=curr_map.offset,\n                        backing_file=curr_map.backing_file,\n                        content=None,\n                    )\n                    map_list.append(saved_map)\n\n                self.maps = MemoryMapSnapshotList(map_list, self._process_name, self._process_full_path)\n\n                self._memory = None\n            case \"writable\":\n                if not thread.debugger.fast_memory:\n                    liblog.warning(\n                        \"Memory snapshot requested but fast memory is not enabled. This will take a long time.\",\n                    )\n\n                # Save all writable memory pages\n                self._save_memory_maps(thread.debugger._internal_debugger, writable_only=True)\n\n                self._memory = SnapshotMemoryView(self, thread.debugger.symbols)\n            case \"full\":\n                if not thread.debugger.fast_memory:\n                    liblog.warning(\n                        \"Memory snapshot requested but fast memory is not enabled. This will take a long time.\",\n                    )\n\n                # Save all memory pages\n                self._save_memory_maps(thread._internal_debugger, writable_only=False)\n\n                self._memory = SnapshotMemoryView(self, thread.debugger.symbols)\n            case _:\n                raise ValueError(f\"Invalid snapshot level {level}\")\n\n        # Log the creation of the snapshot\n        named_addition = \" named \" + self.name if name is not None else \"\"\n        liblog.debugger(\n            f\"Created snapshot {self.snapshot_id} of level {self.level} for thread {self.tid}{named_addition}\",\n        )\n\n    def diff(self: ThreadSnapshot, other: ThreadSnapshot) -&gt; Diff:\n        \"\"\"Creates a diff object between two snapshots.\"\"\"\n        if not isinstance(other, ThreadSnapshot):\n            raise TypeError(\"Both arguments must be ThreadSnapshot objects.\")\n\n        return ThreadSnapshotDiff(self, other)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/thread/thread_snapshot/#libdebug.snapshots.thread.thread_snapshot.ThreadSnapshot.__init__","title":"<code>__init__(thread, level='base', name=None)</code>","text":"<p>Creates a new snapshot object for the given thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to take a snapshot of.</p> required <code>level</code> <code>str</code> <p>The level of the snapshot. Defaults to \"base\".</p> <code>'base'</code> <code>name</code> <code>str</code> <p>A name associated to the snapshot. Defaults to None.</p> <code>None</code> Source code in <code>libdebug/snapshots/thread/thread_snapshot.py</code> <pre><code>def __init__(self: ThreadSnapshot, thread: ThreadContext, level: str = \"base\", name: str | None = None) -&gt; None:\n    \"\"\"Creates a new snapshot object for the given thread.\n\n    Args:\n        thread (ThreadContext): The thread to take a snapshot of.\n        level (str, optional): The level of the snapshot. Defaults to \"base\".\n        name (str, optional): A name associated to the snapshot. Defaults to None.\n    \"\"\"\n    # Set id of the snapshot and increment the counter\n    self.snapshot_id = thread._snapshot_count\n    thread.notify_snapshot_taken()\n\n    # Basic snapshot info\n    self.thread_id = thread.thread_id\n    self.tid = thread.tid\n    self.name = name\n    self.level = level\n    self.arch = thread._internal_debugger.arch\n    self.aslr_enabled = thread._internal_debugger.aslr_enabled\n    self._process_full_path = thread.debugger._internal_debugger._process_full_path\n    self._process_name = thread.debugger._internal_debugger._process_name\n    self._serialization_helper = thread._internal_debugger.serialization_helper\n\n    # Get thread registers\n    self._save_regs(thread)\n\n    # Memory maps\n    match level:\n        case \"base\":\n            map_list = []\n\n            for curr_map in thread.debugger.maps:\n                saved_map = MemoryMapSnapshot(\n                    start=curr_map.start,\n                    end=curr_map.end,\n                    permissions=curr_map.permissions,\n                    size=curr_map.size,\n                    offset=curr_map.offset,\n                    backing_file=curr_map.backing_file,\n                    content=None,\n                )\n                map_list.append(saved_map)\n\n            self.maps = MemoryMapSnapshotList(map_list, self._process_name, self._process_full_path)\n\n            self._memory = None\n        case \"writable\":\n            if not thread.debugger.fast_memory:\n                liblog.warning(\n                    \"Memory snapshot requested but fast memory is not enabled. This will take a long time.\",\n                )\n\n            # Save all writable memory pages\n            self._save_memory_maps(thread.debugger._internal_debugger, writable_only=True)\n\n            self._memory = SnapshotMemoryView(self, thread.debugger.symbols)\n        case \"full\":\n            if not thread.debugger.fast_memory:\n                liblog.warning(\n                    \"Memory snapshot requested but fast memory is not enabled. This will take a long time.\",\n                )\n\n            # Save all memory pages\n            self._save_memory_maps(thread._internal_debugger, writable_only=False)\n\n            self._memory = SnapshotMemoryView(self, thread.debugger.symbols)\n        case _:\n            raise ValueError(f\"Invalid snapshot level {level}\")\n\n    # Log the creation of the snapshot\n    named_addition = \" named \" + self.name if name is not None else \"\"\n    liblog.debugger(\n        f\"Created snapshot {self.snapshot_id} of level {self.level} for thread {self.tid}{named_addition}\",\n    )\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/thread/thread_snapshot/#libdebug.snapshots.thread.thread_snapshot.ThreadSnapshot.diff","title":"<code>diff(other)</code>","text":"<p>Creates a diff object between two snapshots.</p> Source code in <code>libdebug/snapshots/thread/thread_snapshot.py</code> <pre><code>def diff(self: ThreadSnapshot, other: ThreadSnapshot) -&gt; Diff:\n    \"\"\"Creates a diff object between two snapshots.\"\"\"\n    if not isinstance(other, ThreadSnapshot):\n        raise TypeError(\"Both arguments must be ThreadSnapshot objects.\")\n\n    return ThreadSnapshotDiff(self, other)\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/thread/thread_snapshot_diff/","title":"libdebug.snapshots.thread.thread_snapshot_diff","text":""},{"location":"from_pydoc/generated/snapshots/thread/thread_snapshot_diff/#libdebug.snapshots.thread.thread_snapshot_diff.ThreadSnapshotDiff","title":"<code>ThreadSnapshotDiff</code>","text":"<p>               Bases: <code>Diff</code></p> <p>This object represents a diff between thread snapshots.</p> Source code in <code>libdebug/snapshots/thread/thread_snapshot_diff.py</code> <pre><code>class ThreadSnapshotDiff(Diff):\n    \"\"\"This object represents a diff between thread snapshots.\"\"\"\n\n    def __init__(self: ThreadSnapshotDiff, snapshot1: ThreadSnapshot, snapshot2: ThreadSnapshot) -&gt; ThreadSnapshotDiff:\n        \"\"\"Returns a diff between given snapshots of the same thread.\n\n        Args:\n            snapshot1 (ThreadSnapshot): A thread snapshot.\n            snapshot2 (ThreadSnapshot): A thread snapshot.\n        \"\"\"\n        super().__init__(snapshot1, snapshot2)\n\n        # Register diffs\n        self._save_reg_diffs()\n\n        # Memory map diffs\n        self._resolve_maps_diff()\n\n        if (self.snapshot1._process_name == self.snapshot2._process_name) and (\n            self.snapshot1.aslr_enabled or self.snapshot2.aslr_enabled\n        ):\n            liblog.warning(\"ASLR is enabled in either or both snapshots. Diff may be messy.\")\n</code></pre>"},{"location":"from_pydoc/generated/snapshots/thread/thread_snapshot_diff/#libdebug.snapshots.thread.thread_snapshot_diff.ThreadSnapshotDiff.__init__","title":"<code>__init__(snapshot1, snapshot2)</code>","text":"<p>Returns a diff between given snapshots of the same thread.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot1</code> <code>ThreadSnapshot</code> <p>A thread snapshot.</p> required <code>snapshot2</code> <code>ThreadSnapshot</code> <p>A thread snapshot.</p> required Source code in <code>libdebug/snapshots/thread/thread_snapshot_diff.py</code> <pre><code>def __init__(self: ThreadSnapshotDiff, snapshot1: ThreadSnapshot, snapshot2: ThreadSnapshot) -&gt; ThreadSnapshotDiff:\n    \"\"\"Returns a diff between given snapshots of the same thread.\n\n    Args:\n        snapshot1 (ThreadSnapshot): A thread snapshot.\n        snapshot2 (ThreadSnapshot): A thread snapshot.\n    \"\"\"\n    super().__init__(snapshot1, snapshot2)\n\n    # Register diffs\n    self._save_reg_diffs()\n\n    # Memory map diffs\n    self._resolve_maps_diff()\n\n    if (self.snapshot1._process_name == self.snapshot2._process_name) and (\n        self.snapshot1.aslr_enabled or self.snapshot2.aslr_enabled\n    ):\n        liblog.warning(\"ASLR is enabled in either or both snapshots. Diff may be messy.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/file_utils/","title":"libdebug.utils.file_utils","text":""},{"location":"from_pydoc/generated/utils/file_utils/#libdebug.utils.file_utils.ensure_file_executable","title":"<code>ensure_file_executable(path)</code>  <code>cached</code>","text":"<p>Ensures that a file exists and is executable.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the file.</p> required Throws <p>FileNotFoundError: If the file does not exist. PermissionError: If the file is not executable.</p> Source code in <code>libdebug/utils/file_utils.py</code> <pre><code>@functools.cache\ndef ensure_file_executable(path: str) -&gt; None:\n    \"\"\"Ensures that a file exists and is executable.\n\n    Args:\n        path (str): The path to the file.\n\n    Throws:\n        FileNotFoundError: If the file does not exist.\n        PermissionError: If the file is not executable.\n    \"\"\"\n    file = Path(path)\n\n    if not file.exists():\n        raise FileNotFoundError(f\"File '{path}' does not exist.\")\n\n    if not file.is_file():\n        raise FileNotFoundError(f\"Path '{path}' is not a file.\")\n\n    if not os.access(file, os.X_OK):\n        raise PermissionError(f\"File '{path}' is not executable.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/","title":"libdebug.utils.pprint_primitives","text":""},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.get_colored_saved_address_util","title":"<code>get_colored_saved_address_util(return_address, maps, external_symbols=None)</code>","text":"<p>Pretty prints a return address for backtrace pprint.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def get_colored_saved_address_util(\n    return_address: int,\n    maps: MemoryMapList | MemoryMapSnapshotList,\n    external_symbols: SymbolList = None,\n) -&gt; str:\n    \"\"\"Pretty prints a return address for backtrace pprint.\"\"\"\n    filtered_maps = maps.filter(return_address)\n\n    return_address_symbol = resolve_symbol_name_in_maps_util(return_address, external_symbols)\n\n    permissions = filtered_maps[0].permissions\n    if \"rwx\" in permissions:\n        style = f\"{ANSIColors.UNDERLINE}{ANSIColors.RED}\"\n    elif \"x\" in permissions:\n        style = f\"{ANSIColors.RED}\"\n    elif \"w\" in permissions:\n        # This should not happen, but it's here for completeness\n        style = f\"{ANSIColors.YELLOW}\"\n    elif \"r\" in permissions:\n        # This should not happen, but it's here for completeness\n        style = f\"{ANSIColors.GREEN}\"\n    if return_address_symbol[:2] == \"0x\":\n        return f\"{style}{return_address:#x} {ANSIColors.RESET}\"\n    else:\n        return f\"{style}{return_address:#x} &lt;{return_address_symbol}&gt; {ANSIColors.RESET}\"\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pad_colored_string","title":"<code>pad_colored_string(string, length)</code>","text":"<p>Pads a colored string with spaces to the specified length.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to pad.</p> required <code>length</code> <code>int</code> <p>The desired length of the string.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The padded string.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pad_colored_string(string: str, length: int) -&gt; str:\n    \"\"\"Pads a colored string with spaces to the specified length.\n\n    Args:\n        string (str): The string to pad.\n        length (int): The desired length of the string.\n\n    Returns:\n        str: The padded string.\n    \"\"\"\n    stripped_string = strip_ansi_codes(string)\n    padding_length = length - len(stripped_string)\n    if padding_length &gt; 0:\n        return string + \" \" * padding_length\n    return string\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_backtrace_util","title":"<code>pprint_backtrace_util(backtrace, maps, external_symbols=None)</code>","text":"<p>Pretty prints the current backtrace of the thread.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_backtrace_util(\n    backtrace: list,\n    maps: MemoryMapList | MemoryMapSnapshotList,\n    external_symbols: SymbolList = None,\n) -&gt; None:\n    \"\"\"Pretty prints the current backtrace of the thread.\"\"\"\n    for return_address in backtrace:\n        print(get_colored_saved_address_util(return_address, maps, external_symbols))\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_diff_line","title":"<code>pprint_diff_line(content, is_added)</code>","text":"<p>Prints a line of a diff.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_diff_line(content: str, is_added: bool) -&gt; None:\n    \"\"\"Prints a line of a diff.\"\"\"\n    color = ANSIColors.GREEN if is_added else ANSIColors.RED\n\n    prefix = \"&gt;&gt;&gt;\" if is_added else \"&lt;&lt;&lt;\"\n\n    print(f\"{prefix} {color}{content}{ANSIColors.RESET}\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_diff_substring","title":"<code>pprint_diff_substring(content, start, end)</code>","text":"<p>Prints a diff with only a substring highlighted.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_diff_substring(content: str, start: int, end: int) -&gt; None:\n    \"\"\"Prints a diff with only a substring highlighted.\"\"\"\n    color = ANSIColors.ORANGE\n\n    print(f\"{content[:start]}{color}{content[start:end]}{ANSIColors.RESET}{content[end:]}\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_inline_diff","title":"<code>pprint_inline_diff(content, start, end, correction)</code>","text":"<p>Prints a diff with inline changes.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_inline_diff(content: str, start: int, end: int, correction: str) -&gt; None:\n    \"\"\"Prints a diff with inline changes.\"\"\"\n    print(\n        f\"{content[:start]}{ANSIColors.RED}{ANSIColors.STRIKE}{content[start:end]}{ANSIColors.RESET} {ANSIColors.GREEN}{correction}{ANSIColors.RESET}{content[end:]}\"\n    )\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_maps_util","title":"<code>pprint_maps_util(maps)</code>","text":"<p>Prints the memory maps of the process.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_maps_util(maps: MemoryMapList | MemoryMapSnapshotList) -&gt; None:\n    \"\"\"Prints the memory maps of the process.\"\"\"\n    header = f\"{'start':&gt;18}  {'end':&gt;18}  {'perm':&gt;6}  {'size':&gt;8}  {'offset':&gt;8}  {'backing_file':&lt;20}\"\n    print(header)\n    for memory_map in maps:\n        info = (\n            f\"{memory_map.start:#18x}  \"\n            f\"{memory_map.end:#18x}  \"\n            f\"{memory_map.permissions:&gt;6}  \"\n            f\"{memory_map.size:#8x}  \"\n            f\"{memory_map.offset:#8x}  \"\n            f\"{memory_map.backing_file}\"\n        )\n        if \"rwx\" in memory_map.permissions:\n            print(f\"{ANSIColors.RED}{ANSIColors.UNDERLINE}{info}{ANSIColors.RESET}\")\n        elif \"x\" in memory_map.permissions:\n            print(f\"{ANSIColors.RED}{info}{ANSIColors.RESET}\")\n        elif \"w\" in memory_map.permissions:\n            print(f\"{ANSIColors.YELLOW}{info}{ANSIColors.RESET}\")\n        elif \"r\" in memory_map.permissions:\n            print(f\"{ANSIColors.GREEN}{info}{ANSIColors.RESET}\")\n        else:\n            print(info)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_memory_diff_util","title":"<code>pprint_memory_diff_util(address_start, extract_before, extract_after, word_size, maps, integer_mode=False)</code>","text":"<p>Pretty prints the memory diff.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_memory_diff_util(\n    address_start: int,\n    extract_before: bytes,\n    extract_after: bytes,\n    word_size: int,\n    maps: MemoryMapSnapshotList,\n    integer_mode: bool = False,\n) -&gt; None:\n    \"\"\"Pretty prints the memory diff.\"\"\"\n    # Loop through each word-sized chunk\n    for i in range(0, len(extract_before), word_size):\n        # Calculate the current address\n        current_address = address_start + i\n\n        # Extract word-sized chunks from both extracts\n        word_before = extract_before[i : i + word_size]\n        word_after = extract_after[i : i + word_size]\n\n        # Convert each byte in the chunks to hex and compare\n        formatted_before = []\n        formatted_after = []\n        for byte_before, byte_after in zip(word_before, word_after, strict=False):\n            # Check for changes and apply color\n            if byte_before != byte_after:\n                formatted_before.append(f\"{ANSIColors.RED}{byte_before:02x}{ANSIColors.RESET}\")\n                formatted_after.append(f\"{ANSIColors.GREEN}{byte_after:02x}{ANSIColors.RESET}\")\n            else:\n                formatted_before.append(f\"{ANSIColors.RESET}{byte_before:02x}{ANSIColors.RESET}\")\n                formatted_after.append(f\"{ANSIColors.RESET}{byte_after:02x}{ANSIColors.RESET}\")\n\n        # Join the formatted bytes into a string for each column\n        if not integer_mode:\n            before_str = \" \".join(formatted_before)\n            after_str = \" \".join(formatted_after)\n        else:\n            # Right now libdebug only considers little-endian systems, if this changes,\n            # this code should be passed the endianness of the system and format the bytes accordingly\n            before_str = \"0x\" + \"\".join(formatted_before[::-1])\n            after_str = \"0x\" + \"\".join(formatted_after[::-1])\n\n        current_address_str = _get_colored_address_string(current_address, maps)\n\n        # Print the memory diff with the address for this word\n        print(f\"{current_address_str}:  {before_str}    {after_str}\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_memory_util","title":"<code>pprint_memory_util(address_start, extract, word_size, maps, integer_mode=False)</code>","text":"<p>Pretty prints the memory.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_memory_util(\n    address_start: int,\n    extract: bytes,\n    word_size: int,\n    maps: MemoryMapList,\n    integer_mode: bool = False,\n) -&gt; None:\n    \"\"\"Pretty prints the memory.\"\"\"\n    # Loop through each word-sized chunk\n    for i in range(0, len(extract), word_size):\n        # Calculate the current address\n        current_address = address_start + i\n\n        # Extract word-sized chunks from both extracts\n        word = extract[i : i + word_size]\n\n        # Convert each byte in the chunks to hex and compare\n        formatted_word = [f\"{byte:02x}\" for byte in word]\n\n        # Join the formatted bytes into a string for each column\n        out = \" \".join(formatted_word) if not integer_mode else \"0x\" + \"\".join(formatted_word[::-1])\n\n        current_address_str = _get_colored_address_string(current_address, maps)\n\n        # Print the memory diff with the address for this word\n        print(f\"{current_address_str}:  {out}\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_reg_diff_large_util","title":"<code>pprint_reg_diff_large_util(curr_reg_tuple, reg_tuple_before, reg_tuple_after)</code>","text":"<p>Pretty prints a register diff.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_reg_diff_large_util(\n    curr_reg_tuple: (str, str),\n    reg_tuple_before: (int, int),\n    reg_tuple_after: (int, int),\n) -&gt; None:\n    \"\"\"Pretty prints a register diff.\"\"\"\n    print(f\"{ANSIColors.BLUE}\" + \"{\" + f\"{ANSIColors.RESET}\")\n    for reg_name, value_before, value_after in zip(curr_reg_tuple, reg_tuple_before, reg_tuple_after, strict=False):\n        has_changed = value_before != value_after\n\n        # Print the old and new values\n        if has_changed:\n            formatted_value_before = (\n                f\"{ANSIColors.RED}{ANSIColors.STRIKE}\"\n                + (f\"{value_before:#x}\" if isinstance(value_before, int) else str(value_before))\n                + f\"{ANSIColors.RESET}\"\n            )\n\n            formatted_value_after = (\n                f\"{ANSIColors.GREEN}\"\n                + (f\"{value_after:#x}\" if isinstance(value_after, int) else str(value_after))\n                + f\"{ANSIColors.RESET}\"\n            )\n\n            print(\n                f\"  {ANSIColors.RED}{reg_name}{ANSIColors.RESET}\\t{formatted_value_before}\\t-&gt;\\t{formatted_value_after}\"\n            )\n        else:\n            formatted_value = f\"{value_before:#x}\" if isinstance(value_before, int) else str(value_before)\n\n            print(f\"  {ANSIColors.RED}{reg_name}{ANSIColors.RESET}\\t{formatted_value}\")\n\n    print(f\"{ANSIColors.BLUE}\" + \"}\" + f\"{ANSIColors.RESET}\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_reg_diff_util","title":"<code>pprint_reg_diff_util(curr_reg, maps_before, maps_after, before, after)</code>","text":"<p>Pretty prints a register diff.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_reg_diff_util(\n    curr_reg: str,\n    maps_before: MemoryMapList,\n    maps_after: MemoryMapList,\n    before: int,\n    after: int,\n) -&gt; None:\n    \"\"\"Pretty prints a register diff.\"\"\"\n    before_str = _get_colored_address_string(before, maps_before)\n    after_str = _get_colored_address_string(after, maps_after)\n\n    print(f\"{ANSIColors.RED}{curr_reg.ljust(12)}{ANSIColors.RESET}\\t{before_str}\\t{after_str}\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_registers_all_util","title":"<code>pprint_registers_all_util(registers, maps, gen_regs, spec_regs, vec_fp_regs)</code>","text":"<p>Pretty prints all the thread's registers.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_registers_all_util(\n    registers: Registers,\n    maps: MemoryMapList,\n    gen_regs: list[str],\n    spec_regs: list[str],\n    vec_fp_regs: list[str],\n) -&gt; None:\n    \"\"\"Pretty prints all the thread's registers.\"\"\"\n    pprint_registers_util(registers, maps, gen_regs)\n\n    for t in spec_regs:\n        _pprint_reg(registers, maps, t)\n\n    for t in vec_fp_regs:\n        print(f\"{ANSIColors.BLUE}\" + \"{\" + f\"{ANSIColors.RESET}\")\n        for register in t:\n            value = getattr(registers, register)\n            formatted_value = f\"{value:#x}\" if isinstance(value, int) else str(value)\n            print(f\"  {ANSIColors.RED}{register}{ANSIColors.RESET}\\t{formatted_value}\")\n\n        print(f\"{ANSIColors.BLUE}\" + \"}\" + f\"{ANSIColors.RESET}\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.pprint_registers_util","title":"<code>pprint_registers_util(registers, maps, gen_regs)</code>","text":"<p>Pretty prints the thread's registers.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def pprint_registers_util(registers: Registers, maps: MemoryMapList, gen_regs: list[str]) -&gt; None:\n    \"\"\"Pretty prints the thread's registers.\"\"\"\n    for curr_reg in gen_regs:\n        _pprint_reg(registers, maps, curr_reg)\n</code></pre>"},{"location":"from_pydoc/generated/utils/pprint_primitives/#libdebug.utils.pprint_primitives.strip_ansi_codes","title":"<code>strip_ansi_codes(string)</code>","text":"<p>Strips ANSI escape codes from a string.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to strip.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The string without the ANSI escape codes.</p> Source code in <code>libdebug/utils/pprint_primitives.py</code> <pre><code>def strip_ansi_codes(string: str) -&gt; str:\n    \"\"\"Strips ANSI escape codes from a string.\n\n    Args:\n        string (str): The string to strip.\n\n    Returns:\n        str: The string without the ANSI escape codes.\n    \"\"\"\n    ansi_escape = re.compile(r\"\\x1B[@-_][0-?]*[ -/]*[@-~]\")\n    return ansi_escape.sub(\"\", string)\n</code></pre>"},{"location":"logging/liblog/","title":"Logging","text":"<p>Debugging an application with the freedom of a rich API can lead to flows which are hard to unravel. To aid the user in the debugging process, libdebug provides logging. The logging system is implemented in the submodule <code>liblog</code> and adheres to the Python logging system.</p>","boost":4},{"location":"logging/liblog/#event-logging","title":"Event Logging","text":"<p>By default, libdebug only prints critical logs such as warnings and errors. However, the user can enable more verbose logging by setting the <code>argv</code> parameter of the script.</p> <p>The available logging modes for events are:</p> Mode Description <code>debugger</code> Logs related to the debugging operations performed on the process by libdebug. <code>pipe</code> Logs related to interactions with the process pipe: bytes received and bytes sent. <code>dbg</code> Combination of the <code>pipe</code> and <code>debugger</code> options. <p>pwntools compatibility</p> <p>As reported in this documentation, the <code>argv</code> parameters passed to libdebug are lowercase. This choice is made to avoid conflicts with pwntools, which intercepts all uppercase arguments.</p>","boost":4},{"location":"logging/liblog/#debugger-logging","title":"Debugger Logging","text":"<p>The <code>debugger</code> option displays all logs related to the debugging operations performed on the process by libdebug.</p> <p></p>","boost":4},{"location":"logging/liblog/#pipe-logging","title":"Pipe Logging","text":"<p>The <code>pipe</code> option, on the other hand, displays all logs related to interactions with the process pipe: bytes received and bytes sent.</p> <p></p>","boost":4},{"location":"logging/liblog/#the-best-of-both-worlds","title":"The best of both worlds","text":"<p>The <code>dbg</code> option is the combination of the <code>pipe</code> and <code>debugger</code> options. It displays all logs related to the debugging operations performed on the process by libdebug, as well as interactions with the process pipe: bytes received and bytes sent.</p>","boost":4},{"location":"logging/liblog/#changing-logging-levels-at-runtime","title":"Changing logging levels at runtime","text":"<p>libdebug defines logging levels and information types to allow the user to filter the granularity of the the information they want to see. Logger levels for each event type can be changed at runtime using the <code>libcontext</code> module.</p> <p>Example of setting logging levels</p> <pre><code>from libdebug import libcontext\n\nlibcontext.general_logger = 'DEBUG'\nlibcontext.pipe_logger = 'DEBUG'\nlibcontext.debugger_logger = 'DEBUG'\n</code></pre> Logger Description Supported Levels Default Level <code>general_logger</code> Logger used for general libdebug logs, different from the <code>pipe</code> and <code>debugger</code> logs. <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>SILENT</code> <code>INFO</code> <code>pipe_logger</code> Logger used for pipe logs. <code>DEBUG</code>, <code>SILENT</code> <code>SILENT</code> <code>debugger_logger</code> Logger used for debugger logs. <code>DEBUG</code>, <code>SILENT</code> <code>SILENT</code> <p>Let's see what each logging level actually logs:</p> Log Level Debug Logs Information Logs Warnings DEBUG INFO WARNING SILENT","boost":4},{"location":"logging/liblog/#temporary-logging-level-changes","title":"Temporary logging level changes","text":"<p>Logger levels can be temporarily changed at runtime using a <code>with</code> statement, as shown in the following example.</p> <pre><code>from libdebug import libcontext\n\nwith libcontext.tmp(pipe_logger='SILENT', debugger_logger='DEBUG'):\n    r.sendline(b'gimme the flag')\n</code></pre>","boost":4},{"location":"multithreading/multi-stuff/","title":"The Family of the Process","text":"<p>Debugging is all fun and games until you have to deal with a process that spawns children. </p> <p>So...how are children born? In the POSIX standard, children of a process can be either threads or processes. Threads share the same virtual address space, while processes have their own. POSIX-compliant systems such as Linux supply a variety of system calls to create children of both types.</p> <pre><code>flowchart TD\n    P[Parent Process] --&gt;|\"fork()\"| CP1[Child Process]\n    P --&gt;|\"clone()\"| T((Thread))\n    P --&gt;|\"vfork()\"| CP2[Child&lt;br&gt;Process]\n    P --&gt;|\"clone3()\"| T2((Thread))\n\n    CP1 --&gt;|\"fork()\"| GP[Grandchild&lt;br&gt;Process]\n    T --&gt;|\"clone()\"| ST((Sibling&lt;br&gt;Thread))</code></pre> Example family tree of a process in the Linux kernel.","boost":4},{"location":"multithreading/multi-stuff/#processes","title":"Processes","text":"<p>Child processes are created by system calls such as fork, vfork, clone, and clone3. The clone and clone3 system calls are configurable, as they allow the caller to specify the resources to be shared between the parent and child.</p> <p>In the Linux kernel, the ptrace system call allows a tracer to handle events like process creation and termination.</p> <p>Since version 0.8  Chutoro Nigiri , libdebug supports handling children processes. Read more about it in the dedicated Multiprocessing section.</p>","boost":4},{"location":"multithreading/multi-stuff/#threads","title":"Threads","text":"<p>Threads of a running process in the POSIX Threads standard are children of the main process. They are created by the system calls clone and clone3. What distinguishes threads from processes is that threads share the same virtual address space.</p> <p>libdebug offers a simple API to work with children threads. Read more about it in the dedicated Multithreading section.</p>","boost":4},{"location":"multithreading/multiprocessing/","title":"Debugging Multiprocess Applications","text":"<p>Since version 0.8 Chutoro Nigiri , libdebug supports debugging multiprocess applications. This feature allows you to attach to multiple processes and debug them simultaneously. This document explains how to use this feature and provides examples to help you get started.</p>","boost":4},{"location":"multithreading/multiprocessing/#a-child-process-is-born","title":"A Child Process is Born","text":"<p>By default, libdebug will monitor all new children processes created by the tracee process. Of course, it will not retrieve past forked processes that have been created before an attach. </p> <p>A new process is a big deal. For this reason, libdebug will provide you with a brand new Debugger object for each new child process. This object will be available in the list <code>children</code> attribute of the parent Debugger object.</p> <p>Usage Example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"test\")\nd.run()\n\n[...]\n\nprint(f\"The process has spawned {len(d.children)} children\")\n\nfor child in d.children: # (1)!\n    print(f\"Child PID: {child.pid}\")\n</code></pre> <ol> <li>The <code>children</code> attribute is a regular list. Indexing, slicing, and iterating are all supported.</li> </ol>","boost":4},{"location":"multithreading/multiprocessing/#inherited-properties","title":"Inherited Properties","text":"<p>When a child process is spawned, it inherits the properties of the parent debugger. This includes whether ASLR is enabled, fast memory reading, and [other properties}../../basics/libdebug101/#what-else-can-i-do). However, the child debugger from that moment on will act independently. As such, any property changes made to the parent debugger will not affect the child debugger, and vice versa.</p> <p>In terms of registered Stopping Events, the new debugger will be a blank slate. This means the debugger will not inherit breakpoints, watchpoints, syscall handlers, or signal catchers.</p>","boost":4},{"location":"multithreading/multiprocessing/#focusing-on-the-main-process","title":"Focusing on the Main Process","text":"<p>Some applications may spawn a large number of children processes, and you may only be interested in debugging the main process. In this case, you can disable the automatic monitoring of children processes by setting the <code>follow_children</code> parameter to <code>False</code> when creating the Debugger object.</p> <p>Usage Example</p> <p><pre><code>d = debugger(\"test\", follow_children=False)\nd.run()\n</code></pre> In this example, libdebug will only monitor the main process and ignore any child processes spawned by the tracee.</p> <p>However, you can also decide to stop monitoring child processes at any time during debugging by setting the <code>follow_children</code> attribute to <code>False</code> in a certain Debugger object.</p>","boost":4},{"location":"multithreading/multiprocessing/#snapshot-behavior","title":"Snapshot Behavior","text":"<p>When creating a snapshot of a process from the corresponding Debugger object, the snapshot will not include children processes, but only children threads. Read more about snapshots in the Save States section.</p>","boost":4},{"location":"multithreading/multiprocessing/#pipe-redirection","title":"Pipe Redirection","text":"<p>By default, libdebug will redirect the standard input, output, and error of the child processes to pipes. This is how you can interact with these file descriptors using I/O commands. If you keep this parameter enabled, you will be able to interact with the child processes's standard I/O using the same PipeManager object that is provided upon creation of the root Debugger object. This is consistent with limitations of forking in the POSIX standard, where the child process inherits the file descriptors of the parent process.</p> <p>Read more about disabling pipe redirection in the dedicated section.</p>","boost":4},{"location":"multithreading/multithreading/","title":"Debugging Multithreaded Applications","text":"<p>Debugging multi-threaded applications can be a daunting task, particularly in an interactive debugger that is designed to operate on one thread at a time. libdebug offers a few features that will help you debug multi-threaded applications more intuitively and efficiently.</p>","boost":4},{"location":"multithreading/multithreading/#child-threads","title":"Child Threads","text":"<p>libdebug automatically registers new threads and exposes their state with the same API as the main Debugger object. While technically threads can be running or stopped independently, libdebug will enforce a coherent state. This means that if a live thread is stopped, all other live threads will be stopped as well and if a continuation command is issued, all threads will be resumed.</p> <pre><code>stateDiagram-v2\n    state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state: d.interrupt()\n    fork_state --&gt; MainThread: STOP\n    fork_state --&gt; Child1: STOP\n    fork_state --&gt; Child2: STOP\n\n    state join_state &lt;&lt;join&gt;&gt;\n    MainThread --&gt; join_state\n    Child1 --&gt; join_state\n    Child2 --&gt; join_state\n\n    state fork_state1 &lt;&lt;fork&gt;&gt;\n    join_state --&gt; fork_state1: d.cont()\n    fork_state1 --&gt; MainThread_2: CONTINUE\n    fork_state1 --&gt; Child11: CONTINUE\n    fork_state1 --&gt; Child22: CONTINUE\n\n    state join_state2 &lt;&lt;join&gt;&gt;\n    MainThread_2 --&gt; join_state2\n    Child11 --&gt; join_state2\n    Child22 --&gt; join_state2\n\n    state fork_state2 &lt;&lt;fork&gt;&gt;\n    join_state2 --&gt; fork_state2: Breakpoint on Child 2\n    fork_state2 --&gt; MainThread_3: STOP\n    fork_state2 --&gt; Child111: STOP\n    fork_state2 --&gt; Child222: STOP\n\n    state join_state3 &lt;&lt;join&gt;&gt;\n    MainThread_3 --&gt; join_state3\n    Child111 --&gt; join_state3\n    Child222 --&gt; join_state3\n\n    %% State definitions with labels\n    state \"Main Thread\" as MainThread\n    state \"Child 1\" as Child1\n    state \"Child 2\" as Child2\n    state \"Main Thread\" as MainThread_2\n    state \"Child 1\" as Child11\n    state \"Child 2\" as Child22\n    state \"Main Thread\" as MainThread_3\n    state \"Child 1\" as Child111\n    state \"Child 2\" as Child222</code></pre> All live threads are syncronized in their execution state.","boost":4},{"location":"multithreading/multithreading/#libdebug-api-for-multithreading","title":"libdebug API for Multithreading","text":"<p>To access the threads of a process, you can use the <code>threads</code> attribute of the Debugger object. This attribute will return a list of ThreadContext objects, each representing a thread of the process.</p> <p>If you're already familiar with the Debugger object, you'll find the ThreadContext straightforward to use. The Debugger has always acted as a facade for the main thread, enabling you to access registers, memory, and other thread state fields exactly as you would for the main thread. The difference you will notice is that the ThreadContext object is missing a couple of fields that just don't make sense in the context of a single thread (e.g. symbols, which belong to the binary, and memory maps, since they are shared for the whole process).</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./so_many_threads\")\nd.run()\n\n# Reach the point of interest\nd.breakpoint(\"loom\", file=\"binary\")\nd.cont()\nd.wait()\n\nfor thread in d.threads:\n    print(f\"Thread {thread.tid} stopped at {hex(thread.regs.rip)}\")\n    print(\"Function frame:\")\n\n    # Retrieve frame boundaries\n    frame_start = thread.regs.rbp\n    frame_end = thread.regs.rsp\n\n    # Print function frame\n    for addr in range(frame_end, frame_start, 8):\n        print(f\"  {addr:#16x}: {thread.memory[addr:addr+8].hex()}\")\n\n[...]\n</code></pre>","boost":4},{"location":"multithreading/multithreading/#properties-of-the-threadcontext","title":"Properties of the ThreadContext","text":"Property Type Description <code>regs</code> Registers The thread's registers. <code>debugger</code> Debugger The debugging context this thread belongs to. <code>memory</code> AbstractMemoryView The memory view of the debugged process (<code>mem</code> is an alias). <code>instruction_pointer</code> <code>int</code> The thread's instruction pointer. <code>process_id</code> <code>int</code> The process ID (<code>pid</code> is an alias). <code>thread_id</code> <code>int</code> The thread ID (<code>tid</code> is an alias). <code>running</code> <code>bool</code> Whether the process is running. <code>saved_ip</code> <code>int</code> The return address of the current function. <code>dead</code> <code>bool</code> Whether the thread is dead. <code>exit_code</code> <code>int</code> The thread's exit code (if dead). <code>exit_signal</code> <code>str</code> The thread's exit signal (if dead). <code>syscall_arg0</code> <code>int</code> The thread's syscall argument 0. <code>syscall_arg1</code> <code>int</code> The thread's syscall argument 1. <code>syscall_arg2</code> <code>int</code> The thread's syscall argument 2. <code>syscall_arg3</code> <code>int</code> The thread's syscall argument 3. <code>syscall_arg4</code> <code>int</code> The thread's syscall argument 4. <code>syscall_arg5</code> <code>int</code> The thread's syscall argument 5. <code>syscall_number</code> <code>int</code> The thread's syscall number. <code>syscall_return</code> <code>int</code> The thread's syscall return value. <code>signal</code> <code>str</code> The signal will be forwarded to the thread. <code>signal_number</code> <code>int</code> The signal number to forward to the thread. <code>zombie</code> <code>bool</code> Whether the thread is in a zombie state.","boost":4},{"location":"multithreading/multithreading/#methods-of-the-threadcontext","title":"Methods of the ThreadContext","text":"Method Description Return Type <code>set_as_dead()</code> Set the thread as dead. <code>None</code> <code>step()</code> Executes a single instruction of the process (<code>si</code> is an alias). <code>None</code> <code>step_until(position: int, max_steps: int = -1, file: str = \"hybrid\")</code> Executes instructions of the process until the specified location is reached (<code>su</code> is an alias). <code>None</code> <code>finish(heuristic: str = \"backtrace\")</code> Continues execution until the current function returns or the process stops (<code>fin</code> is an alias). <code>None</code> <code>next()</code> Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns (<code>fin</code> is an alias). <code>None</code> <code>backtrace(as_symbols: bool = False)</code> Returns the current backtrace of the thread (see Stack Frame Utils). <code>list</code> <code>pprint_backtrace()</code> Pretty prints the current backtrace of the thread (see Pretty Printing). <code>None</code> <code>pprint_registers()</code> Pretty prints the thread's registers (see Pretty Printing). <code>None</code> <code>pprint_regs()</code> Alias for the <code>pprint_registers</code> method (see Pretty Printing). <code>None</code> <code>pprint_registers_all()</code> Pretty prints all the thread's registers (see Pretty Printing). <code>None</code> <code>pprint_regs_all()</code> Alias for the <code>pprint_registers_all</code> method (see Pretty Printing). <code>None</code> <p>Meaning of the debugger object</p> <p>When accessing state fields of the Debugger object (e.g. registers, memory), the debugger will act as an alias for the main thread. For example, doing d.regs.rax will be equivalent to doing d.threads[0].regs.rax.</p>","boost":4},{"location":"multithreading/multithreading/#shared-and-unshared-state","title":"Shared and Unshared State","text":"<p>Each thread has its own register set, stack, and instruction pointer. However, the virtual address space is shared among all threads. This means that threads can access the same memory and share the same code.</p> <p>How to access TLS?</p> <p>While the virtual address space is shared between threads, each thread has its own Thread Local Storage (TLS) area. As it stands, libdebug does not provide a direct interface to the TLS area.</p> <p>Let's see a couple of things to keep in mind when debugging multi-threaded applications with libdebug.</p>","boost":4},{"location":"multithreading/multithreading/#software-breakpoints","title":"Software Breakpoints","text":"<p>Software breakpoints are implemented through code patching in the process memory. This means that a breakpoint set in one thread will be replicated across all threads.</p> <p>When using synchronous breakpoints, you will need to \"diagnose\" the stopping event to determine which thread triggered the breakpoint. You can do this by checking the return value of the <code>hit_on()</code> method of the Breakpoint object. Passing the ThreadContext as an argument will return <code>True</code> if the breakpoint was hit by that thread.</p> <p>Diagnosing a Synchronous Breakpoint</p> <pre><code>thread = d.threads[2]\n\nfor addr, bp in d.breakpoints.items():\n    if bp.hit_on(thread):\n        print(f\"Thread {thread.tid} hit breakpoint {addr:#x}\")\n</code></pre> <p>When using asynchronous breakpoints, the breakpoint will be more intuitive to handle, as the signature of the callback function includes the ThreadContext object that triggered the breakpoint.</p> <p>Handling an Asynchronous Breakpoint</p> <pre><code>def on_breakpoint_hit(t, bp):\n    print(f\"Thread {t.tid} hit breakpoint {bp.address:#x}\")\n\nd.breakpoint(0x10ab, callback=on_breakpoint_hit, file=\"binary\")\n</code></pre>","boost":4},{"location":"multithreading/multithreading/#hardware-breakpoints-and-watchpoints","title":"Hardware Breakpoints and Watchpoints","text":"<p>While hardware breakpoints are thread-specific, libdebug mirrors them across all threads. This is done to avoid asymmetries with software breakpoints. Watchpoints are hardware breakpoints, so this applies to them as well.</p> <p>For consistency, syscall handlers are also enabled across all threads. The same considerations for synchronous and asynchronous breakpoints apply here as well.</p> <p>Concurrency in Syscall Handling</p> <p>When debugging entering and exiting events in syscalls, be mindful of the scheduling. The kernel may schedule a different thread to handle the syscall exit event right after the enter event of another thread.</p>","boost":4},{"location":"multithreading/multithreading/#signal-catching","title":"Signal Catching","text":"Who will receive the signal?  <p>Signal Catching is also shared among threads. Apart from consistency, this is a necessity. In fact, the kernel does not guarantee that a signal sent to a process will be dispatched to a specific thread. By contrast, when sending arbitrary signals through the ThreadContext object, the signal will be sent to the requested thread.</p>","boost":4},{"location":"multithreading/multithreading/#snapshot-behavior","title":"Snapshot Behavior","text":"<p>When creating a snapshot of a process from the corresponding Debugger object, the snapshot will also save the state of all threads. You can also create a snapshot of a single thread by calling the <code>create_snapshot()</code> method from the ThreadContext object instead. Read more about snapshots in the Save States section.</p>","boost":4},{"location":"multithreading/multithreading/#zombie-threads","title":"Zombie Threads","text":"<p>When a thread or process terminates, it enters a zombie state. This is a temporary condition where the process is effectively dead but awaiting reaping by the parent or debugger, which involves reading its status. Reaping traced zombie threads can become complicated due to certain edge cases.</p> <p>While libdebug automatically handles the reaping of zombie threads, it provides a property named <code>zombie</code> within the ThreadContext object, indicating whether the thread is in a zombie state. The same property is also available in the Debugger object, indicating whether the main thread is in a zombie state.</p> <p>Example Code</p> <pre><code>if d.threads[1].zombie:\n    print(\"The thread is a zombie\")\n</code></pre> <pre><code>sequenceDiagram\n    participant Parent as Parent Process\n    participant Child as Child Thread\n    participant Kernel as Linux Kernel\n\n    Note over Parent,Kernel: Normal Execution Phase\n    Parent-&gt;&gt;Child: clone()\n    activate Child\n    Child-&gt;&gt;Kernel: Task added to the Process Table\n    Kernel--&gt;&gt;Child: Thread ID\n\n    Note over Parent,Kernel: Zombie Creation Phase\n    Child-&gt;&gt;Kernel: exit(statusCode)\n    deactivate Child\n    Note right of Kernel: Parent will be&lt;br/&gt;notified of exit\n    Kernel-&gt;&gt;Parent: SIGCHLD\n    Note right of Parent: Parent Busy&lt;br/&gt;Cannot Process Signal\n\n    Note over Parent,Kernel: Zombie State\n    Note right of Child: Thread becomes&lt;br/&gt;zombie (defunct)&lt;br/&gt;- Maintains TID&lt;br/&gt;- Keeps exit status&lt;br/&gt;- Consumes minimal resources\n\n    Note over Parent,Kernel: Reaping Phase\n    Parent-&gt;&gt;Kernel: waitpid()\n    Kernel--&gt;&gt;Parent: Return Exit Status\n    Kernel-&gt;&gt;Kernel: Remove Zombie Entry&lt;br/&gt;from Process Table\n    Note right of Kernel: Resources Released</code></pre>","boost":4},{"location":"quality_of_life/anti_debugging/","title":"Evasion of Anti-Debugging","text":"","boost":4},{"location":"quality_of_life/anti_debugging/#automatic-evasion-of-anti-debugging-techniques","title":"Automatic Evasion of Anti-Debugging Techniques","text":"<p>A common anti-debugging technique for Linux ELF binaries is to invoke the <code>ptrace</code> syscall with the <code>PTRACE_TRACEME</code> argument. The syscall will fail if the binary is currently being traced by a debugger, as the kernel forbids a process from being traced by multiple debuggers.</p> <p>Bypassing this technique involves intercepting such syscalls and altering the return value to make the binary believe that it is not being traced. While this can absolutely be performed manually, libdebug comes with a pre-made implementation that can save you precious time.</p> <p>To enable this feature, set the <code>escape_antidebug</code> property to <code>True</code> when creating the debugger object. The debugger will take care of the rest.</p> <p>Example</p> <p>&gt; C source code <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/ptrace.h&gt;\n\nint main()\n{\n\n    if (ptrace(PTRACE_TRACEME, 0, NULL, 0) == -1) // (1)!\n    {\n        puts(\"No cheating! Debugger detected.\"); // (2)!\n        exit(1);\n    }\n\n    puts(\"Congrats! Here's your flag:\"); // (3)!\n    puts(\"flag{y0u_sn3aky_guy_y0u_tr1ck3d_m3}\");\n\n    return 0;\n}\n</code></pre></p> <ol> <li>Call ptrace with <code>PTRACE_TRACEME</code> to detect if we are being debugged</li> <li>If the call fails, it means the program is being debugged</li> <li>If the program is not being debugged, print the flag</li> </ol> <p>&gt; libdebug script <pre><code>from libdebug import debugger\n\nd = debugger(\"evasive_binary\",\n    escape_antidebug=True)\n\npipe = d.run()\n\nd.cont()\nout = pipe.recvline(numlines=2)\nd.wait()\n\nprint(out.decode())\n</code></pre></p> <p>Execution of the script will print the flag, even if the binary is being debugged.</p>","boost":4},{"location":"quality_of_life/memory_maps/","title":"Memory Maps","text":"<p>Virtual memory is a fundamental concept in operating systems. It allows the operating system to provide each process with its own address space, which is isolated from other processes. This isolation is crucial for security and stability reasons. The memory of a process is divided into regions called memory maps. Each memory map has a starting address, an ending address, and a set of permissions (read, write, execute).</p> <p>In libdebug, you can access the memory maps of a process using the <code>maps</code> attribute of the Debugger object.</p> <p>The <code>maps</code> attribute returns a list of MemoryMap objects, which contain the following attributes:</p> Attribute Type Description <code>start</code> <code>int</code> The start address of the memory map. There is also an equivalent alias called <code>base</code>. <code>end</code> <code>int</code> The end address of the memory map. <code>permissions</code> <code>str</code> The permissions of the memory map. <code>size</code> <code>int</code> The size of the memory map. <code>offset</code> <code>int</code> The offset of the memory map relative to the backing file. <code>backing_file</code> <code>str</code> The backing file of the memory map, or the symbolic name of the memory map.","boost":4},{"location":"quality_of_life/memory_maps/#filtering-memory-maps","title":"Filtering Memory Maps","text":"<p>You can filter memory maps based on their attributes using the <code>filter()</code> method of the <code>maps</code> attribute. The <code>filter()</code> method accepts a value that can be either a memory address (<code>int</code>) or a symbolic name (<code>str</code>) and returns a list of MemoryMap objects that match the criteria.</p> <p>Function Signature</p> <pre><code>d.maps.filter(value: int | str) -&gt; MemoryMapList[MemoryMap]:\n</code></pre> <p>The behavior of the memory map filtering depends on the type of the <code>value</code> parameter:</p> Queried Value Return Value Integer (memory address) Map that contains the address String (symbolic map name) List of maps with backing file matching the symbolic name","boost":4},{"location":"quality_of_life/pretty_printing/","title":"Pretty Printing","text":"<p>libdebug offers utilities to visualize the process's state in a human-readable format and with color highlighting. This can be especially useful when debugging complex binaries or when you need to quickly understand the behavior of a program.</p>","boost":4},{"location":"quality_of_life/pretty_printing/#registers-pretty-printing","title":"Registers Pretty Printing","text":"<p>There are two functions available to print the registers of a thread: <code>pprint_registers()</code> and <code>print_registers_all()</code>. The former will print the current values of the most commonly-interesting registers, while the latter will print all available registers.</p> <p></p> <p>Aliases</p> <p>If you don't like long function names, you can use aliases for the two register pretty print functions. The shorter aliases are <code>pprint_regs()</code> and <code>print_regs_all()</code>.</p>","boost":4},{"location":"quality_of_life/pretty_printing/#syscall-trace-pretty-printing","title":"Syscall Trace Pretty Printing","text":"<p>When debugging a binary, it is often much faster to guess what the intended functionality is by looking at the syscalls that are being invoked. libdebug offers a function that will intercept any syscall and print its arguments and return value. This can be done by setting the property <code>pprint_syscalls = True</code> in the Debugger object or ThreadContext object and resuming the process.</p> <p>Syscall Trace PPrint Syntax</p> <pre><code>d.pprint_syscalls = True\nd.cont()\n</code></pre> <p>The output will be printed to the console in color according to the following coding:</p> Format Description blue Syscall name red Syscall was intercepted and handled by a callback (either a basic handler or a hijack) yellow Value given to a syscall argument in hexadecimal strikethrough Syscall was hijacked or a value was changed, the new syscall or value follows the striken text <p>Handled syscalls with a callback associated with them will be listed as such. Additionally, syscalls hijacked through the libdebug API will be highlighted as striken through, allowing you to monitor both the original behavior and your own changes to the flow. The id of the thread that made the syscall will be printed in the beginning of the line in white bold.</p> <p></p>","boost":4},{"location":"quality_of_life/pretty_printing/#memory-maps-pretty-printing","title":"Memory Maps Pretty Printing","text":"<p>To pretty print the memory maps of a process, you can simply use the <code>pprint_maps()</code> function. This will print the memory maps of the process in a human-readable format, with color highlighting to distinguish between different memory regions.</p> Format Description underlined Memory map with read, write, and execute permissions red Memory map with execute permissions yellow Memory map with write permissions green Memory map with read permission only white Memory map with no permissions <p></p>","boost":4},{"location":"quality_of_life/pretty_printing/#stack-trace-pretty-printing","title":"Stack Trace Pretty Printing","text":"<p>To pretty print the stack trace (backtrace) of a process, you can use the <code>pprint_backtrace()</code> function. This will print the stack trace of the process in a human-readable format.</p> <p></p>","boost":4},{"location":"quality_of_life/pretty_printing/#memory-pretty-printing","title":"Memory Pretty Printing","text":"<p>The <code>pprint_memory()</code> function will print the contents of the process memory within a certain range of addresses.</p> <p>Function signature</p> <pre><code>d.pprint_memory(\n    start: int,\n    end: int,\n    file: str = \"hybrid\",\n    override_word_size: int = None,\n    integer_mode: bool = False,\n) -&gt; None:\n</code></pre> Parameter Data Type Description <code>start</code> <code>int</code> The start address of the memory range to print. <code>end</code> <code>int</code> The end address of the memory range to print. <code>file</code> <code>str</code> (optional) The file to use for the memory content. Defaults to <code>hybrid</code> mode (see memory access). <code>override_word_size</code> <code>int</code> (optional) The word size to use to align memory contents. By default, it uses the ISA register size. <code>integer_mode</code> <code>bool</code> (optional) Whether to print the memory content in integer mode. Defaults to False <p>Start after End</p> <p>For your convenience, if the <code>start</code> address is greater than the <code>end</code> address, the function will swap the values.</p> <p>Here is a visual example of the memory content pretty printing (with and without integer mode):</p> Integer mode disabledInteger mode enabled <p></p> <p></p>","boost":4},{"location":"quality_of_life/quality_of_life/","title":"Quality of Life Features","text":"<p>For your convenience, libdebug offers a few functions that will speed up your debugging process.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#pretty-printing","title":"Pretty Printing","text":"<p>Visualizing the state of the process you are debugging can be a daunting task. libdebug offers utilities to print registers, memory maps, syscalls, and more in a human-readable format and with color highlighting.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#symbol-resolution","title":"Symbol Resolution","text":"<p>libdebug can resolve symbols in the binary and shared libraries. With big binaries, this can be a computationally intensive, especially if your script needs to be run multiple types. You can set symbol resolution levels and specify where to look for symbols according to your needs.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#memory-maps","title":"Memory Maps","text":"<p>libdebug offers utilities to retrieve the memory maps of a process. This can be useful to understand the memory layout of the process you are debugging.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#stack-frame-utils","title":"Stack Frame Utils","text":"<p>libdebug offers utilities to resolve the return addresses of a process.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#evasion-of-anti-debugging","title":"Evasion of Anti-Debugging","text":"<p>libdebug offers a few functions that will help you evade simple anti-debugging techniques. These functions can be used to bypass checks for the presence of a debugger.</p>","boost":4},{"location":"quality_of_life/stack_frame_utils/","title":"Stack Frame Utils","text":"<p>Function calls in a binary executable are made according to a system calling convention. One constant in these conventions is the use of a stack frame to store the return addresses to resume at the end of the function.</p> <p>Different architectures have slightly different ways to retrieve the return address (for example, in AArch64, the latest return address is stored in <code>x30</code>, the Link Register). To abstract these differences, libdebug provides common utilities to resolve the stack trace (backtrace) of the running process (or thread).</p> <p>libdebug's backtrace is structured like a LIFO stack, with the top-most value being the current instruction pointer. Subsequent values are the return addresses of the functions that were called to reach the current instruction pointer.</p> <p>Backtrace usage example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"test_backtrace\")\nd.run()\n\n# A few calls later...\n[...]\n\ncurrent_ip = d.backtrace()[0]\nreturn_address = d.backtrace()[1]\nother_return_addresses = d.backtrace()[2:]\n</code></pre> <p>Additionally, the field <code>saved_ip</code> of the Debugger or ThreadContext objects will contain the return address of the current function.</p>","boost":4},{"location":"quality_of_life/symbols/","title":"Symbol Resolution","text":"","boost":4},{"location":"quality_of_life/symbols/#symbol-resolution","title":"Symbol Resolution","text":"<p>As described in the memory access section, many functions in libdebug accept symbols as an alternative to actual addresses or offsets.</p> <p>You can list all resolved symbols in the binary and shared libraries using the <code>symbols</code> attribute of the Debugger object. This attribute returns a SymbolList object.</p> <p>This object grants the user hybrid access to the symbols: as a dict or as a list. Tor example, the following lines of code all have a valid syntax:</p> <pre><code>d.symbols['printf'] #(1)!\nd.symbols[0] #(2)!\nd.symbols['printf'][0] #(3)!\n</code></pre> <ol> <li>Returns a list of symbols that match the string <code>printf</code> exactly.</li> <li>Returns the first symbol in the list.</li> <li>Returns the first symbol that matches the string <code>printf</code> exactly.</li> </ol> <p>Please note that the dict-like access returns exact matches with the symbol name. If you want to filter for symbols that contain a specific string, read the dedicated section.</p> <p>C++ Demangling</p> <p>Reverse-engineering of C++ binaries can be a struggle. To help out, libdebug automatically demangles C++ symbols.</p>","boost":4},{"location":"quality_of_life/symbols/#symbol-resolution-levels","title":"Symbol Resolution Levels","text":"<p>With large binaries and libraries, parsing symbols can become an expensive operation. Because of this, libdebug offers the possibility of choosing among 5 levels of symbol resolution. To set the symbol resolution level, you can use the <code>sym_lvl</code> property of the <code>libcontext</code> module. The default value is level 5.</p> Level Description 0 Symbol resolution is disabled. 1 Parse the ELF symbol table (.symtab) and dynamic symbol table (.dynsym). 2 Parse the ELF DWARF. 3 Follow the external debug file link in the .gnu_debuglink and/or .gnu_debugaltlink sections. If the file is present in the system, read its .symtab and .dynsym. 4 Parse the external debug file DWARF, if the file exists in the system. 5 Download the external debug file using <code>debuginfod</code>. The file is cached in the default folder for <code>debuginfod</code>. <p>Upon searching for symbols, libdebug will proceed from the lowest level to the set maximum.</p> <p>Example of setting the symbol resolution level</p> <pre><code>from libdebug import libcontext\n\nlibcontext.sym_lvl = 3\nd.breakpoint('main')\n</code></pre> <p>If you want to change the symbol resolution level temporarily, you can use a <code>with</code> statement along with the <code>tmp</code> method of the <code>libcontext</code> module.</p> <p>Example of temporary resolution level change</p> <pre><code>from libdebug import libcontext\n\nwith libcontext.tmp(sym_lvl = 5):\n    d.breakpoint('main')\n</code></pre>","boost":4},{"location":"quality_of_life/symbols/#symbol-filtering","title":"Symbol Filtering","text":"<p>The <code>symbols</code> attribute of the Debugger object allows you to filter symbols in the binary and shared libraries.</p> <p>Function Signature</p> <pre><code>d.symbols.filter(value: int | str) -&gt; SymbolList[Symbol]\n</code></pre> <p>Given a symbol name or address, this function returns a SymbolList. The list will contain all symbols that match the given value.</p> <p>Symbol objects contain the following attributes:</p> Attribute Type Description <code>start</code> <code>int</code> The start offset of the symbol. <code>end</code> <code>int</code> The end offset of the symbol. <code>name</code> <code>str</code> The name of the symbol. <code>backing_file</code> <code>str</code> The file where the symbol is defined (e.g., binary, libc, ld). <p>Slow Symbol Resolution</p> <p>Please keep in mind that symbol resolution can be an expensive operation on large binaries and shared libraries. If you are experiencing performance issues, you can set the symbol resolution level to a lower value.</p>","boost":4},{"location":"save_states/save_states/","title":"Save States","text":"<p>Save states are a powerful feature in libdebug to save the current state of the process.</p> <p>There is no single way to define a save state. The state of a process in an operating system, is not just its memory and register contents. The process interacts with shared external resources, such as files, sockets, and other processes. These resources cannot be restored in a reliable way. Still, there are many interesting use cases for saving and restoring all that can be saved.</p> <p>So...what is a save state in libdebug? Although we plan on supporting multiple types of save states for different use cases in the near future, libdebug currently supports only snapshots.</p>","boost":4},{"location":"save_states/snapshot_diffs/","title":"Snapshot Diffs","text":"<p>Snapshot diffs are objects that represent what changed between two snapshots. They are created through the <code>diff()</code> method of a snapshot.</p> <p>The level of a diff is resolved as the lowest level of the two snapshots being compared. For example, if a diff is created between a <code>full</code> snapshot and a <code>base</code> snapshot, their diff will be of <code>base</code> level. For more information on the different levels of snapshots, see the Snapshots page.</p> <p>ASLR Mess</p> <p>If Address Space Layout Randomization (ASLR) is enabled, the memory addresses in the diffs may appear inconsistent or messy. libdebug will remind you of this when you diff snapshots with ASLR enabled. See here for more information.</p>","boost":4},{"location":"save_states/snapshot_diffs/#api","title":"API","text":"<p>Just like snapshots themselves, diffs try to mimic the API of the Debugger and ThreadContext objects. The main difference is that returned objects represent a change in state, rather than the state itself.</p>","boost":4},{"location":"save_states/snapshot_diffs/#register-diffs","title":"Register Diffs","text":"<p>The <code>regs</code> attribute of a diff object (aliased as <code>registers</code>) is a RegisterDiffAccessor object that allows you to access the register values of the snapshot. The accessor will return a RegisterDiff object that represents the difference between the two snapshots.</p> <p>You can access each diff with any of the architecture-specific register names. For a full list, refer to the Register Access page.</p> <p>Example usage</p> <p><pre><code>print(ts_diff.regs.rip)\n</code></pre> Output: <pre><code>RegisterDiff(old_value=0x56148d577130, new_value=0x56148d577148, has_changed=True)\n</code></pre></p> <p>Each register diff is an object with the following attributes:</p> Attribute Data Type Description <code>old_value</code> <code>int | float</code> The value of the register in the first snapshot. <code>new_value</code> <code>int | float</code> The value of the register in the second snapshot. <code>has_changed</code> <code>bool</code> Whether the register value has changed.","boost":4},{"location":"save_states/snapshot_diffs/#memory-map-diffs","title":"Memory Map Diffs","text":"<p>The <code>maps</code> attribute of a diff object is a MemoryMapDiffList object that contains the memory maps of the process in each of the snapshots.</p> <p>Here is what a MemoryMapDiff object looks like:</p> <p>Example usage</p> <p><pre><code>print(ts_diff.maps[-2])\n</code></pre> Output (indented for readability): <pre><code>MemoryMapDiff(\n    old_map_state=MemoryMap(\n        start=0x7fff145ea000,\n        end=0x7fff1460c000,\n        permissions=rw-p,\n        size=0x22000,\n        offset=0x0,\n        backing_file=[stack]\n    )   [snapshot with content],\n    new_map_state=MemoryMap(\n        start=0x7fff145ea000,\n        end=0x7fff1460c000,\n        permissions=rw-p,\n        size=0x22000,\n        offset=0x0,\n        backing_file=[stack]\n    )   [snapshot with content],\n    has_changed=True,\n    _cached_diffs=None\n)\n</code></pre></p> <p>The map diff contains the following attributes:</p> Attribute Data Type Description <code>old_map_state</code> <code>MemoryMap</code> The memory map in the first snapshot. <code>new_map_state</code> <code>MemoryMap</code> The memory map in the second snapshot. <code>has_changed</code> <code>bool</code> Whether the memory map has changed. <p>Memory Map Diff Levels</p> <p>If the diff is of <code>base</code> level, the <code>has_changed</code> attribute will only consider superficial changes in the memory map (e.g., permissions, end address). Under the <code>writable</code> and <code>full</code> levels, the diff will also consider the contents of the memory map.</p>","boost":4},{"location":"save_states/snapshot_diffs/#memory-content-diffs","title":"Memory Content Diffs","text":"<p>If the diff is of <code>full</code> or <code>writable</code> level, the MemoryMapDiff object exposes a useful utility to track blocks of differing memory contents in a certain memory map: the <code>content_diff</code> attribute.</p> <p>Example usage</p> <p><pre><code>stack_page_diff = ts_diff.maps.filter(\"stack\")[0]\n\nfor current_slice in stack_page_diff.content_diff:\n    print(f\"Memory diff slice: {hex(current_slice.start)}:{hex(current_slice.stop)}\")\n</code></pre> Output: <pre><code>Memory diff slice: 0x20260:0x20266\nMemory diff slice: 0x20268:0x2026e\n</code></pre></p> <p>The attribute will return a list of slice objects that represent the blocks of differing memory contents in the memory map. Each slice will contain the start and end addresses of the differing memory block relative to the memory map.</p>","boost":4},{"location":"save_states/snapshot_diffs/#attributes","title":"Attributes","text":"Attribute Data Type Level Description Aliases Common <code>snapshot1</code> <code>Snapshot</code> All The earliest snapshot being compared (recency is determined by id ordering). <code>snapshot2</code> <code>Snapshot</code> All The latest snapshot being compared (recency is determined by id ordering). <code>level</code> <code>str</code> All The diff level. <code>maps</code> <code>MemoryMapDiffList</code> All The memory maps of the process. Each map will also have the contents of the memory map under the appropriate snapshot level. Thread Snapshot Diff <code>regs</code> <code>RegisterDiffAccessor</code> All The register values of the thread. <code>registers</code> Process Snapshot Diff <code>born_threads</code> <code>list[LightweightThreadSnapshot]</code> All Snapshots of all threads of the process. <code>dead_threads</code> <code>list[LightweightThreadSnapshot]</code> All Snapshots of all threads of the process. <code>threads</code> <code>list[LightweightThreadSnapshotDiff]</code> All Snapshots of all threads of the process. <code>regs</code> <code>RegsterDiffAccessor</code> All The register values of the main thread of the process. <code>registers</code>","boost":4},{"location":"save_states/snapshot_diffs/#pretty-printing","title":"Pretty Printing","text":"<p>Pretty Printing is a feature of some libdebug objects that allows you to print the contents of a snapshot in a colorful and eye-catching format. This is useful when you want to inspect the state of the process at a glance.</p> <p>Diff objects have the following pretty printing functions:</p> Function Description <code>pprint_registers()</code> Prints changed general-purpose register values <code>pprint_registers_all()</code> Prints all changed register values (including special and vector registers) <code>pprint_maps()</code> Prints memory maps which have changed between snapshots (highlights if only the content or the end address have changed). <code>pprint_memory()</code> Prints the memory content diffs of the snapshot. See next section for more information <code>pprint_backtrace()</code> Prints the diff of the backtrace between the two snapshots. <p>Here are some visual examples of the pretty printing functions:</p>","boost":4},{"location":"save_states/snapshot_diffs/#register-diff-pretty-printing","title":"Register Diff Pretty Printing","text":"<p>The <code>pprint_registers()</code> function of a diff object will print the changed general-purpose register values.</p> <p>Here is a visual example of the register diff pretty printing:</p> <p></p>","boost":4},{"location":"save_states/snapshot_diffs/#memory-map-diff-pretty-printing","title":"Memory Map Diff Pretty Printing","text":"<p>The <code>pprint_maps()</code> function of a diff object will print the memory maps which have changed between snapshots. It also hi</p> <p>Here is a visual example of the memory map diff pretty printing:</p> <p></p>","boost":4},{"location":"save_states/snapshot_diffs/#memory-content-diff-pretty-printing","title":"Memory Content Diff Pretty Printing","text":"<p>The <code>pprint_memory()</code> function of a diff object will print the content diffs within a certain range of memory addresses.</p> <p>Function signature</p> <pre><code>ts_diff.pprint_memory(\n    start: int,\n    end: int,\n    file: str = \"hybrid\",\n    override_word_size: int = None,\n    integer_mode: bool = False,\n) -&gt; None:\n</code></pre> Parameter Data Type Description <code>start</code> <code>int</code> The start address of the memory range to print. <code>end</code> <code>int</code> The end address of the memory range to print. <code>file</code> <code>str</code> (optional) The file to use for the memory content. Defaults to <code>hybrid</code> mode (see memory access). <code>override_word_size</code> <code>int</code> (optional) The word size to use to align memory contents. By default, it uses the ISA register size. <code>integer_mode</code> <code>bool</code> (optional) Whether to print the memory content in integer mode. Defaults to False <p>Start after End</p> <p>For your convenience, if the <code>start</code> address is greater than the <code>end</code> address, the function will swap the values.</p> <p>Here is a visual example of the memory content diff pretty printing (with and without integer mode):</p> Integer mode disabledInteger mode enabled <p></p> <p></p>","boost":4},{"location":"save_states/snapshot_diffs/#stack-trace-diff-pretty-printing","title":"Stack Trace Diff Pretty Printing","text":"<p>To pretty print the stack trace diff (backtrace) of a process, you can use the <code>pprint_backtrace()</code> function. Return addresses are printed from the most to the least recent. They are placed in three columns. The center one is the common part of the backtrace, while the left and right columns are the differing parts. The following image shows an example of a backtrace diff:</p> <p></p>","boost":4},{"location":"save_states/snapshots/","title":"Snapshots","text":"<p>Snapshots are a static type of save state in libdebug. They allow you to save the current state of the process in terms of registers, memory, and other process properties. Snapshots can be saved to disk as a file and loaded for future use. Finally, snapshots can be diffed to compare the differences between the state of the process at two different moments or executions.</p> <p>Snapshots are static</p> <p>Snapshots are static in the sense that they capture the state of the process at a single moment in time. They can be loaded and inspected at any time and across different architectures. They do not, however, allow to restore their state to the process.</p> <p>There are three available levels of snapshots in libdebug, which differ in the amount of information they store:</p> Level Registers Memory Pages Memory Contents <code>base</code> <code>writable</code> writable pages only <code>full</code> <p>Since memory content snapshots can be large, the default level is <code>base</code>.</p> <p>You can create snapshots of single threads or the entire process.</p>","boost":4},{"location":"save_states/snapshots/#api","title":"API","text":"<ul> <li> <p> Register Access</p> <p>You can access a snapshot's registers using the <code>regs</code> attribute, just like you would when debugging the process.</p> <p> API Reference</p> </li> <li> <p> Memory Access</p> <p>When the snapshot level is appropriate, you can access the memory of the process using the <code>memory</code> attribute.</p> <p> API Reference</p> </li> <li> <p> Memory Maps</p> <p>Memory maps are always available. When the snapshot level is appropriate, you can access the contents as a bytes-like object.</p> <p> API Reference</p> </li> <li> <p> Stack Trace</p> <p>When the snapshot level is appropriate, you can access the backtrace of the process or thread.</p> <p> API Reference</p> </li> </ul>","boost":4},{"location":"save_states/snapshots/#creating-snapshots","title":"Creating Snapshots","text":"<p>The function used to create a snapshot is <code>create_snapshot()</code>. It behaves differently depending on the object it is called from.</p> Calling Object Snapshot Type Description ThreadContext ThreadSnapshot Creates a snapshot of the specific thread. Debugger ProcessSnapshot Creates a snapshot of the entire process. This includes snapshots for all threads. <p>The following is the signature of the function:</p> <p>Function Signature</p> <p><pre><code>d.create_snapshot(level: str = \"base\", name: str = None) -&gt; ProcessSnapshot\n</code></pre> or <pre><code>t.create_snapshot(level: str = \"base\", name: str = None) -&gt; ThreadSnapshot\n</code></pre> Where <code>d</code> is a Debugger object and <code>t</code> is a ThreadContext object.</p> <p>The following is an example usage of the function in both cases:</p> <pre><code>d = debugger(\"program\")\n\nmy_thread = d.threads[1]\n\n# Thread Snapshot\nts = my_thread.create_snapshot(level=\"full\", name=\"cool snapshot\") #(1)!\n\n# Process Snapshot\nps = d.create_snapshot(level=\"writable\", name=\"very cool snapshot\") #(2)!\n</code></pre> <ol> <li>This will create a full-level snapshot of the thread <code>my_thread</code> and name it \"cool snapshot\".</li> <li>This will create a writable-level snapshot of the entire process and name it \"very cool snapshot\".</li> </ol> <p>Naming Snapshots</p> <p>When creating a snapshot, you can optionally specify a name for it. The name will be useful when comparing snapshots in diffs or when saving them to disk.</p>","boost":4},{"location":"save_states/snapshots/#saving-and-loading-snapshots","title":"Saving and Loading Snapshots","text":"<p>You can save a snapshot to disk using the <code>save()</code> method of the Snapshot object. The method will create a serializable version of the snapshot and export a json file to the specified path.</p> <p>Example usage</p> <pre><code>ts = d.threads[1].create_snapshot(level=\"full\")\nts.save(\"path/to/save/snapshot.json\")\n</code></pre> <p>You can load a snapshot from disk using the <code>load_snapshot()</code> method of the Debugger object. The method will read the json file from the specified path and create a Snapshot object from it.</p> <p>Example usage</p> <pre><code>ts = d.load_snapshot(\"path/to/load/snapshot.json\")\n</code></pre> <p>The snapshot type will be inferred from the json file, so you can easily load both thread and process snapshots from the same method.</p>","boost":4},{"location":"save_states/snapshots/#resolving-diffs","title":"Resolving Diffs","text":"<p>Thanks to their static nature, snapshots can be easily compared to find differences in saved properties.</p> <p>You can diff a snapshot against another using the <code>diff()</code> method. The method will return a Diff object that represents the differences between the two snapshots. The diff will be of the lowest level of the two snapshots being compared in terms.</p> <p>Example usage</p> <pre><code>ts1 = d.threads[1].create_snapshot(level=\"full\")\n\n[...] # (1)!\n\nts2 = d.threads[1].create_snapshot(level=\"full\")\n\nts_diff = ts1.diff(ts2) # (2)!\n</code></pre> <ol> <li>Do some operations that change the state of the process.</li> <li>Compute the diff between the two snapshots</li> </ol> <p>Diffs have a rich and detailed API that allows you to inspect the differences in registers, memory, and other properties. Read more in the dedicated section.</p>","boost":4},{"location":"save_states/snapshots/#pretty-printing","title":"Pretty Printing","text":"<p>Pretty Printing is a feature of some libdebug objects that allows you to print the contents of a snapshot in a colorful and eye-catching format. This is useful when you want to inspect the state of the process at a glance.</p> <p>Pretty printing utilities of snapshots are \"mirrors\" of pretty pretting functions available for the Debugger and ThreadContext. Here is a list of available pretty printing functions and their equivalent for the running process:</p> Function Description Reference <code>pprint_registers()</code> Prints the general-purpose registers of the snapshot.  API Reference <code>pprint_registers_all()</code> Prints all registers of the snapshot.  API Reference <code>pprint_maps()</code> Prints the memory of the snapshot.  API Reference <code>pprint_backtrace()</code> Prints the backtrace of the snapshot.  API Reference","boost":4},{"location":"save_states/snapshots/#attributes","title":"Attributes","text":"Attribute Data Type Level Description Aliases Common <code>name</code> <code>str</code> (optional) All The name of the snapshot. <code>arch</code> <code>str</code> All The ISA under which the snapshot process was running. <code>snapshot_id</code> int All Progressive id counted from 0. Process and Thread snapshots have separate counters. <code>level</code> <code>str</code> All The snapshot level. <code>maps</code> <code>MemoryMapSnapshotList</code> All The memory maps of the process. Each map will also have the contents of the memory map under the appropriate snapshot level. <code>memory</code> <code>SnapshotMemoryView</code> <code>writable</code> / <code>full</code> Interface to the memory of the process. <code>mem</code> <code>aslr_enabled</code> <code>bool</code> All Whether ASLR was enabled at the time of the snapshot. Thread Snapshot <code>thread_id</code> <code>int</code> All The ID of the thread the snapshot was taken from. <code>tid</code> <code>regs</code> <code>SnapshotRegisters</code> All The register values of the thread. <code>registers</code> Process Snapshot <code>process_id</code> <code>int</code> All The ID of the process the snapshot was taken from. <code>pid</code> <code>threads</code> <code>list[LightweightThreadSnapshot]</code> All Snapshots of all threads of the process. <code>regs</code> <code>SnapshotRegisters</code> All The register values of the main thread of the process. <code>registers</code>","boost":4},{"location":"stopping_events/breakpoints/","title":"Breakpoints","text":"<p>Breakpoints are the killer feature of any debugger, the fundamental stopping event. They allow you to stop the execution of your code at a specific point and inspect the state of your program to find bugs or understand its design.</p> <p>Multithreading and Breakpoints</p> <p>libdebug breakpoints are shared across all threads. This means that any thread can hit the breakpoint and cause the process to stop. You can use the <code>hit_on()</code> method of a breakpoint object to determine which thread hit the breakpoint (provided that the stop was indeed caused by the breakpoint).</p> <p>A breakpoint can be inserted at any of two levels: software or hardware.</p>","boost":4},{"location":"stopping_events/breakpoints/#software-breakpoints","title":"Software Breakpoints","text":"<p>Software breakpoints in the Linux kernel are implemented by patching the code in memory at runtime. The instruction at the chosen address is replaced with an interrupt instruction that is conventionally used for debugging. For example, in the <code>i386</code> and <code>AMD64</code> instruction sets, <code>int3</code> (0xCC) is reserved for this purpose.</p> <p>When the <code>int3</code> instruction is executed, the CPU raises a <code>SIGTRAP</code> signal, which is caught by the debugger. The debugger then stops the process and restores the original instruction to its rightful place.</p> <p>Pros and Cons of Software Breakpoints</p> <p>Software breakpoints are unlimited, but they can break when the program uses self-modifying code. This is because the patched code could be overwritten by the program. On the other hand, software breakpoints are slower than their hardware counterparts on most modern CPUs.</p>","boost":4},{"location":"stopping_events/breakpoints/#hardware-breakpoints","title":"Hardware Breakpoints","text":"<p>Hardware breakpoints are a more reliable way to set breakpoints. They are made possible by the existence of special registers in the CPU that can be used to monitor memory accesses. Differently from software breakpoints, their hardware counterparts allows the debugger to monitor read and write accesses on top of code execution. This kind of hardware breakpoint is also called a watchpoint. More information on watchpoints can be found in the dedicated documentation.</p> <p>Pros and Cons of Hardware Breakpoints</p> <p>Hardware breakpoints are not affected by self-modifying code. They are also usually faster and more flexible. However, hardware breakpoints are limited in number and are hardware-dependent, so their support may vary across different systems.</p> <p>Hardware Breakpoint Alignment in AArch64</p> <p>Hardware breakpoints have to be aligned to 4 bytes (which is the size of an ARM instruction).</p>","boost":4},{"location":"stopping_events/breakpoints/#libdebug-api-for-breakpoints","title":"libdebug API for Breakpoints","text":"<p>The <code>breakpoint()</code> function in the Debugger object sets a breakpoint at a specific address.</p> <p>Function Signature</p> <pre><code>d.breakpoint(address, hardware=False, condition='x', length=1, callback=None, file='hybrid')\n</code></pre> <p>Parameters:</p> Argument Type Description <code>address</code> <code>int</code> | <code>str</code> The address or symbol where the breakpoint will be set. <code>hardware</code> <code>bool</code> Set to <code>True</code> to set a hardware breakpoint. <code>condition</code> <code>str</code> The type of access in case of a hardware breakpoint. <code>length</code> <code>int</code> The size of the word being watched in case of a hardware breakpoint. <code>callback</code> <code>Callable</code> | <code>bool</code> (see callback signature here) Used to create asyncronous breakpoints (read more on the debugging flow of stopping events). <code>file</code> <code>str</code> The backing file for relative addressing. Refer to the memory access section for more information on addressing modes. <p>Returns:</p> Return Type Description <code>Breakpoint</code> Breakpoint The breakpoint object created. <p>Limited Hardware Breakpoints</p> <p>Hardware breakpoints are limited in number. If you exceed the number of hardware breakpoints available on your system, a <code>RuntimeError</code> will be raised.</p> <p>Usage Example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\n\nd.run()\n\nbp = d.breakpoint(0x10ab, file=\"binary\") # (1)!\nbp1 = d.breakpoint(\"main\", file=\"binary\") # (3)!\nbp2 = d.breakpoint(\"printf\", file=\"libc\") # (4)!\n\nd.cont()\n\nprint(f\"RAX: {d.regs.rax:#x} at the breakpoint\") # (2)!\nif bp.hit_on(d):\n    print(\"Breakpoint at 0x10ab was hit\")\nelif bp1.hit_on(d):\n    print(\"Breakpoint at main was hit\")\nelif bp2.hit_on(d):\n    print(\"Breakpoint at printf was hit\")\n</code></pre> <ol> <li>Set a software breakpoint at address 0x10ab relative to the program's base address</li> <li>Print the value of the RAX register when the breakpoint is hit</li> <li>Set a software breakpoint at the <code>main</code> symbol</li> <li>Set a software breakpoint at the <code>printf</code> symbol in the <code>libc</code> library</li> </ol>","boost":4},{"location":"stopping_events/breakpoints/#callback-signature","title":"Callback Signature","text":"<p>If you wish to create an asynchronous breakpoint, you will have to provide a callback function. If you want to leave the callback empty, you can set callback to <code>True</code>.</p> <p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, bp: Breakpoint):\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the breakpoint. <code>bp</code> Breakpoint The breakpoint object that triggered the callback. <p>Example usage of asynchronous breakpoints</p> <pre><code>def on_breakpoint_hit(t, bp):\n    print(f\"RAX: {t.regs.rax:#x}\")\n\n    if bp.hit_count == 100:\n        print(\"Hit count reached 100\")\n        bp.disable()\n\nd.breakpoint(0x11f0, callback=on_breakpoint_hit, file=\"binary\")\n</code></pre>","boost":4},{"location":"stopping_events/breakpoints/#the-breakpoints-dict","title":"The Breakpoints Dict","text":"<p>The <code>breakpoints</code> attribute of the Debugger object is a dictionary that contains all the breakpoints set by the user. The keys are the addresses of the breakpoints, and the values are the corresponding Breakpoint objects. This is useful to retrieve breakpoints in \\(O(1)\\) time complexity.</p> <p>Usage Example - Massive Breakpoint Insertion</p> <pre><code>from libdebug import debugger\n\ndef hook_callback(t, bp):\n    [...]\n\nd = debugger(\"example_binary\")\nd.run()\n\n# Massive breakpoint insertion\nwith open(\"example_binary\", \"rb\") as f:\n    binary_data = f.read()\n\ncursor = 0\nwhile cursor &lt; len(binary_data):\n    if binary_data[cursor:cursor+2] == b\"\\xD9\\xC9\":\n        d.breakpoint(cursor, callback=hook_callback, file=\"binary\") # (1)!\n    cursor += 1\n\nd.cont()\n\n[...]\n\nip = d.regs.rip\n\nif d.memory[0x10, 4, \"binary\"] == b\"\\x00\\xff\\x00\\xab\":\n    d.breakpoints[ip].disable() # (2)!\n[...]\n</code></pre> <ol> <li>Insert a breakpoint at every <code>FXCH</code> instruction in the binary (at least ones found through static analysis)</li> <li>If some condition is met, disable the breakpoint at the current instruction pointer</li> </ol>","boost":4},{"location":"stopping_events/debugging_flow/","title":"Debugging Flow of Stopping Events","text":"<p>Before diving into each libdebug stopping event, it's crucial to understand the debugging flow that these events introduce, based on the mode selected by the user.</p> <p>The flow of all stopping events is similar and adheres to a mostly uniform API structure. Upon placing a stopping event, the user is allowed to specify a callback function for the stopping event. If a callback is passed, the event will trigger asynchronously. Otherwise, if the callback is not passed, the event will be synchronous. The following flowchart shows the difference between the two flows.</p> Flowchart of different handling modes for stopping events <p>When a synchronous event is hit, the process will stop, awaiting further commands. When an asynchronous event is hit, libdebug temporarily stops the process and invokes the user callback. Process execution is automatically resumed right after.</p> <p>Tip: Use cases of asynchronous stopping events</p> <p>The asynchronous mode for stopping events is particularly useful for events being repeated as a result of a loop in the executed code.</p> <p>When attempting side-channel reverse engineering, this mode can save a lot of your time.</p>","boost":4},{"location":"stopping_events/debugging_flow/#types-of-stopping-events","title":"Types of Stopping Events","text":"<p>libdebug supports the following types of stopping events:</p> Event Type Description Notes Breakpoint Stops the process when a certain address is executed Can be a software or a hardware breakpoint Watchpoint Stops the process when a memory area is read or written Alias for a hardware breakpoint Syscall Stops the process when a syscall is made Two events are supported: syscall start and end Signal Stops the process when a signal is received <p>Multiple callbacks or hijacks</p> <p>Please note that there can be at most one user-defined callback or hijack for each instance of a stopping event (the same syscall, signal or breakpoint address). If a new stopping event is defined for the same thing, the new stopping event will replace the old one, and a warning will be printed.</p> <p>Internally, hijacks are considered callbacks, so you cannot have a callback and hijack registered for the same event.</p>","boost":4},{"location":"stopping_events/debugging_flow/#common-apis-of-stopping-events","title":"Common APIs of Stopping Events","text":"<p>All libdebug stopping events share some common attributes that can be employed in debugging scripts.</p>","boost":4},{"location":"stopping_events/debugging_flow/#enabledisable","title":"Enable/Disable","text":"<p>All stopping events can be enabled or disabled at any time. You can read the <code>enabled</code> attribute to check the current state of the event. To enable or disable the event, you can call the <code>enable()</code> or <code>disable()</code> methods respectively.</p>","boost":4},{"location":"stopping_events/debugging_flow/#callback","title":"Callback","text":"<p>The callback function of the event can be set, changed or removed (set to <code>None</code>) at any time. Please be mindful of the event mode resulting from the change on the callback parameter. Additionally, you can set the callback to <code>True</code> to register an empty callback.</p>","boost":4},{"location":"stopping_events/debugging_flow/#hit-records","title":"Hit Records","text":"<p>Stopping events have attributes that can help you keep track of hits. For example, the <code>hit_count</code> attribute stores the number of times the event has been triggered.</p> <p>The <code>hit_on()</code> function is used to check if the stopping event was the cause of the process stopping. It is particularly useful when debugging multithreaded applications, as it takes a ThreadContext as a parameter. Refer to multithreading for more information.</p>","boost":4},{"location":"stopping_events/debugging_flow/#hijacking","title":"Hijacking","text":"<p>Hijacking is a powerful feature that allows you to change the flow of the process when a stopping event is hit. It is available for both syscalls and signals, but currently not for other stopping events. When registering a hijack for a compatible stopping event, that execution flow will be replaced with another.</p> Example hijacking of a SIGALRM to a SIGUSR1 <p>For example, in the case of a signal, you can specify that a received <code>SIGALRM</code> signal should be replaced with a <code>SIGUSR1</code> signal. This can be useful when you want to prevent a process from executing a certain code path. In fact, you can even use the hijack feature to \"NOP\" the syscall or signal altogether, avoiding it to be executed / forwarded to the processed. More information on how to use this feature in each stopping event can be found in their respective documentation.</p>","boost":4},{"location":"stopping_events/debugging_flow/#recursion","title":"Recursion","text":"<p>Mixing asynchronous callbacks and hijacking can become messy. Because of this, libdebug provides users with the choice of whether to execute the callback for an event that was triggered by a callback or hijack.</p> <p>This behavior is enabled by the parameter <code>recursive</code>, available when instantiating a syscall handler, a signal catcher, or their respective hijackers. By default, recursion is disabled.</p> <p>Recursion Loop Detection</p> <p>When carelessly doing recursive callbacks and hijacking, it could happen that loops are created. libdebug automatically performs checks to avoid these situations and raises an exception if an infinite loop is detected.</p> <p>For example, the following code raises a <code>RuntimeError</code>:</p> <pre><code>handler = d.hijack_syscall(\"read\", \"write\", recursive=True)\nhandler = d.hijack_syscall(\"write\", \"read\", recursive=True)\n</code></pre>","boost":4},{"location":"stopping_events/signals/","title":"Signals","text":"<p>Signals are a feature of POSIX systems like (e.g., the Linux kernel) that provide a mechanism for asynchronous communication between processes and the operating system. When certain events occur (e.g., hardware interrupts, illegal operations, or termination requests) the kernel can send a signal to a process to notify it of the event. Each signal is identified by a unique integer and corresponds to a specific type of event. For example, <code>SIGINT</code> (usually triggered by pressing <code>Ctrl+C</code>) is used to interrupt a process, while <code>SIGKILL</code> forcefully terminates a process without cleanup. </p> <p>Processes can handle these signals in different ways: they may catch and define custom behavior for certain signals, ignore them, or allow the default action to occur.</p> <p>Restrictions on Signal Catching</p> <p>libdebug does not support catching <code>SIGSTOP</code> and <code>SIGKILL</code>, since kernel-level restrictions prevent these signals from being caught or ignored. While <code>SIGTRAP</code> can be caught, it is used internally by libdebug to implement stopping events and should be used with caution.</p> <p>libdebug allows you to intercept signals sent to the tracee. Specifically, you can choose to catch or hijack a specific signal (read more on hijacking).</p>","boost":4},{"location":"stopping_events/signals/#signal-catchers","title":"Signal Catchers","text":"<p>Signal catchers can be created to register stopping events for when a signal is received.</p> <p>Multiple catchers for the same signal</p> <p>Please note that there can be at most one user-defined catcher or hijack for each signal. If a new catcher is defined for a signal that is already caught or hijacked, the new catcher will replace the old one, and a warning will be printed.</p>","boost":4},{"location":"stopping_events/signals/#libdebug-api-for-signal-catching","title":"libdebug API for Signal Catching","text":"<p>The <code>catch_signal()</code> function in the Debugger object registers a catcher for the specified signal.</p> <p>Function Signature</p> <pre><code>d.catch_signal(signal, callback=None, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>signal</code> <code>int</code> | <code>str</code> The signal number or name to catch. If set to <code>\"*\"</code> or <code>\"all\"</code>, all signals will be caught. <code>callback</code> <code>Callable</code> | <code>bool</code> (see callback signature here) The callback function to be executed when the signal is received. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the catcher's callback will be executed even if the signal was triggered by a hijack. <p>Returns:</p> Return Type Description <code>SignalCatcher</code> SignalCatcher The catcher object created. <p>Inside a callback or when the process stops on hitting your catcher, you can retrieve the signal number that triggered the catcher by accessing the <code>signal_number</code> attribute of the ThreadContext object. Alternatively, if one exists, the <code>signal</code> attribute of the will contain the signal mnemonic corresponding to the signal number. This is particularly useful when your catcher is registered for multiple signals (e.g., with the <code>all</code> option) and accessing the signal number from it will not represent the signal that triggered the catcher.</p>","boost":4},{"location":"stopping_events/signals/#callback-signature","title":"Callback Signature","text":"<p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, catcher: SignalCatcher):\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that received the signal. <code>catcher</code> SignalCatcher The SignalCatcher object that triggered the callback. <p>Signals in multi-threaded applications</p> <p>In the Linux kernel, an incoming signal could be delivered to any thread in the process. Please do not assume that the signal will be delivered to a specific thread in your scripts.</p> <p>Example usage of asynchronous signal catchers</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\n# Define the callback function\ndef catcher_SIGUSR1(t, catcher):\n    t.signal = 0x0 # (1)!\n    print(\"Look mum, I'm catching a signal\")\n\ndef catcher_SIGINT(t, catcher):\n    print(\"Look mum, I'm catching another signal\")\n\n# Register the signal catchers\ncatcher1 = d.catch_signal(10, callback=catcher_SIGUSR1)\ncatcher2 = d.catch_signal('SIGINT', callback=catcher_SIGINT)\n\nd.cont()\nd.wait()\n</code></pre> <ol> <li>This line replaces the signal number with <code>0x0</code> to prevent the signal from being delivered to the process. (Equivalent to filtering the signal).</li> </ol> <p>Example of synchronous signal catching</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\ncatcher = d.catch_signal(10)\nd.cont()\n\nif catcher.hit_on(d):\n    print(\"Signal 10 was caught\")\n</code></pre> <p>The script above will print \"Signal 10 was entered\".</p> <p>Example of all signal catching</p> <pre><code>from libdebug import debugger\n\ndef catcher(t, catcher):\n    print(f\"Signal {t.signal_number} ({t.signal}) was caught\")\n\nd = debugger(\"./test_program\")\nd.run()\n\ncatcher = d.catch_signal(\"all\")\nd.cont()\nd.wait()\n</code></pre> <p>The script above will print the number and mnemonic of the signal that was caught.</p>","boost":4},{"location":"stopping_events/signals/#hijacking","title":"Hijacking","text":"<p>When hijacking a signal, the user can provide an alternative signal to be executed in place of the original one. Internally, the hijack is implemented by registering a catcher for the signal and replacing the signal number with the new one.</p> <p>Function Signature</p> <pre><code>d.hijack_signal(original_signal, new_signal, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>original_signal</code> <code>int</code> | <code>str</code> The signal number or name to be hijacked. If set to <code>\"*\"</code> or <code>\"all\"</code>, all signals except the restricted ones will be hijacked. <code>new_signal</code> <code>int</code> | <code>str</code> The signal number or name to be delivered instead. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the catcher's callback will be executed even if the signal was dispached by a hijack. <p>Returns:</p> Return Type Description <code>SignalCatcher</code> SignalCatcher The catcher object created. <p>Example of hijacking a signal</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n\n// Handler for SIGALRM\nvoid handle_sigalrm(int sig) {\n    printf(\"You failed. Better luck next time\\n\");\n    exit(1);\n}\n\n// Handler for SIGUSR1\nvoid handle_sigusr1(int sig) {\n    printf(\"Congrats: flag{pr1nt_pr0vol4_1s_th3_w4y}\\n\");\n    exit(0);\n}\n\nint main() {\n    // Set up the SIGALRM handler\n    struct sigaction sa_alrm;\n    sa_alrm.sa_handler = handle_sigalrm;\n    sigemptyset(&amp;sa_alrm.sa_mask);\n    sa_alrm.sa_flags = 0;\n    sigaction(SIGALRM, &amp;sa_alrm, NULL);\n\n    // Set up the SIGUSR1 handler\n    struct sigaction sa_usr1;\n    sa_usr1.sa_handler = handle_sigusr1;\n    sigemptyset(&amp;sa_usr1.sa_mask);\n    sa_usr1.sa_flags = 0;\n    sigaction(SIGUSR1, &amp;sa_usr1, NULL);\n\n    // Set an alarm to go off after 10 seconds\n    alarm(10);\n\n    printf(\"Waiting for a signal...\\n\");\n\n    // Infinite loop, waiting for signals\n    while (1) {\n        pause(); // Suspend the program until a signal is caught\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.hijack_signal(\"SIGALRM\", \"SIGUSR1\")\n\nd.cont()\n\n# Will print \"Waiting for a signal...\"\nout = pipe.recvline()\nprint(out.decode())\n\nd.wait()\n\n# Will print the flag\nout = pipe.recvline()\nprint(out.decode())\n</code></pre>","boost":4},{"location":"stopping_events/signals/#signal-filtering","title":"Signal Filtering","text":"<p>Instead of setting a catcher on signals, you might want to filter which signals are not to be forwarded to the debugged process during execution.</p> <p>Example of signal filtering</p> <pre><code>d.signals_to_block = [10, 15, 'SIGINT', 3, 13]\n</code></pre>","boost":4},{"location":"stopping_events/signals/#arbitrary-signals","title":"Arbitrary Signals","text":"<p>You can also send an arbitrary signal to the process. The signal will be forwarded upon resuming execution. As always, you can specify the signal number or name.</p> <p>Example of sending an arbitrary signal</p> <pre><code>d.signal = 10\nd.cont()\n</code></pre> <p>In multithreaded applications, the same syntax applies when using a ThreadContext object instead of the Debugger object.</p>","boost":4},{"location":"stopping_events/stopping_events/","title":"Stopping Events","text":"<p>Debugging a process involves stopping the execution at specific points to inspect the state of the program. libdebug provides several ways to stop the execution of a program, such as breakpoints, syscall handling and signal catching. This section covers the different stopping events available in libdebug.</p>","boost":4},{"location":"stopping_events/stopping_events/#is-the-process-running","title":"Is the process running?","text":"<p>Before we dive into the different stopping events, it is important to understand how to check if the process is running. The <code>running</code> attribute of the Debugger object returns <code>True</code> if the process is running and <code>False</code> otherwise.</p> <p>Example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\n\nd.run()\n\nif d.running:\n    print(\"The process is running\")\nelse:\n    print(\"The process is not running\")\n</code></pre> <p>In this example, the script should print <code>The process is not running</code>, since the <code>run()</code> command gives you control over a stopped process, ready to be debugged.</p> <p>To know more on how to wait for the process to stop or forcibly cause it to stop, please read about control flow commands.</p>","boost":4},{"location":"stopping_events/syscalls/","title":"Syscalls","text":"<p>System calls (a.k.a. syscalls or software interrupts) are the interface between user space and kernel space. They are used to request services from the kernel, such as reading from a file or creating a new process. libdebug allows you to trace syscalls invoked by the debugged program. Specifically, you can choose to handle or hijack a specific syscall (read more on hijacking).</p> <p>For extra convenience, the Debugger and the ThreadContext objects provide a system-agnostic interface to the arguments and return values of syscalls. Interacting directly with these parameters enables you to create scripts that are independent of the syscall calling convention specific to the target architecture.</p> Field Description <code>syscall_number</code> The number of the syscall. <code>syscall_arg0</code> The first argument of the syscall. <code>syscall_arg1</code> The second argument of the syscall. <code>syscall_arg2</code> The third argument of the syscall. <code>syscall_arg3</code> The fourth argument of the syscall. <code>syscall_arg4</code> The fifth argument of the syscall. <code>syscall_arg5</code> The sixth argument of the syscall. <code>syscall_return</code> The return value of the syscall. <p>Example of Syscall Parameters</p> <pre><code>[...] # (1)!\n\nbinsh_str = d.memory.find(b\"/bin/sh\\x00\", file=\"libc\")[0]\n\nd.syscall_arg0 = binsh_str\nd.syscall_arg1 = 0x0\nd.syscall_arg2 = 0x0\nd.syscall_number = 0x3b\n\nd.step() # (2)!\n</code></pre> <ol> <li>The instruction pointer is on a syscall / SVC instruction</li> <li>Now the <code>execve('/bin/sh', 0, 0)</code> will be executed in place of the previous syscall.</li> </ol>","boost":4},{"location":"stopping_events/syscalls/#syscall-handlers","title":"Syscall Handlers","text":"<p>Syscall handlers can be created to register stopping events for when a syscall is entered and exited.</p> <p>Do I have to handle both on enter and on exit?</p> <p>When using asynchronous syscall handlers, you can choose to handle both or only one of the two events. However, when using synchronous handlers, both events will stop the process.</p>","boost":4},{"location":"stopping_events/syscalls/#libdebug-api-for-syscall-handlers","title":"libdebug API for Syscall Handlers","text":"<p>The <code>handle_syscall()</code> function in the Debugger object registers a handler for the specified syscall.</p> <p>Function Signature</p> <pre><code>d.handle_syscall(syscall, on_enter=None, on_exit=None, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be handled. If set to <code>\"*\"</code> or <code>\"all\"</code> or <code>\"ALL\"</code>, all syscalls will be handled. <code>on_enter</code> <code>Callable</code> | <code>bool</code> (see callback signature here) The callback function to be executed when the syscall is entered. <code>on_exit</code> <code>Callable</code> | <code>bool</code> (see callback signature here) The callback function to be executed when the syscall is exited. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the handler's callback will be executed even if the syscall was triggered by a hijack or caused by a callback. <p>Returns:</p> Return Type Description <code>SyscallHandler</code> SyscallHandler The handler object created.","boost":4},{"location":"stopping_events/syscalls/#callback-signature","title":"Callback Signature","text":"<p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, handler: HandledSyscall) -&gt; None:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the syscall. <code>handler</code> SyscallHandler The SyscallHandler object that triggered the callback. <p>Nuances of Syscall Handling</p> <p>The syscall handler is the only stopping event that can be triggered by the same syscall twice in a row. This is because the handler is triggered both when the syscall is entered and when it is exited. As a result the <code>hit_on()</code> method of the SyscallHandler object will return <code>True</code> in both instances.</p> <p>You can also use the <code>hit_on_enter()</code> and <code>hit_on_exit()</code> functions to check if the cause of the process stop was the syscall entering or exiting, respectively.</p> <p>As for the <code>hit_count</code> attribute, it only stores the number of times the syscall was exited.</p> <p>Example usage of asynchronous syscall handlers</p> <pre><code>def on_enter_open(t, handler):\n    print(\"entering open\")\n    t.syscall_arg0 = 0x1\n\ndef on_exit_open(t, handler):\n    print(\"exiting open\")\n    t.syscall_return = 0x0\n\nhandler = d.handle_syscall(syscall=\"open\", on_enter=on_enter_open, on_exit=on_exit_open)\n</code></pre> <p>Example of synchronous syscall handling</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.handle_syscall(syscall=\"open\")\nd.cont()\n\nif handler.hit_on_enter(d):\n    print(\"open syscall was entered\")\nelif handler.hit_on_exit(d):\n    print(\"open syscall was exited\")\n</code></pre> <p>The script above will print \"open syscall was entered\".</p>","boost":4},{"location":"stopping_events/syscalls/#resolution-of-syscall-numbers","title":"Resolution of Syscall Numbers","text":"<p>Syscall handlers can be created with the identifier number of the syscall or by the syscall's common name. In the second case, syscall names are resolved from a definition list for Linux syscalls on the target architecture. The list is fetched from mebeim's syscall table. We thank him for hosting such a precious resource. Once downloaded, the list is cached internally. </p>","boost":4},{"location":"stopping_events/syscalls/#hijacking","title":"Hijacking","text":"<p>When hijacking a syscall, the user can provide an alternative syscall to be executed in place of the original one. Internally, the hijack is implemented by registering a handler for the syscall and replacing the syscall number with the new one.</p> <p>Function Signature</p> <pre><code>d.hijack_syscall(original_syscall, new_syscall, recursive=False, **kwargs) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>original_syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be hijacked. If set to <code>\"*\"</code> or <code>\"all\"</code> or <code>\"ALL\"</code>, all syscalls will be hijacked. <code>new_syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be executed instead. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the handler's callback will be executed even if the syscall was triggered by a hijack or caused by a callback. <code>**kwargs</code> <code>(int, optional)</code> Additional arguments to be passed to the new syscall. <p>Returns:</p> Return Type Description <code>SyscallHandler</code> SyscallHandler The handler object created. <p>Example of hijacking a syscall</p> <pre><code>#include &lt;unistd.h&gt;\n\nchar secretBuffer[32] = \"The password is 12345678\";\n\nint main(int argc, char** argv)\n{\n    [...]\n\n    read(0, secretBuffer, 31);\n\n    [...]\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.hijack_syscall(\"read\", \"write\")\n\nd.cont()\nd.wait()\n\nout = pipe.recvline()\nprint(out.decode())\n</code></pre> <p> In this case, the secret will be leaked to the standard output instead of being overwritten with content from the standard input.</p> <p>For your convenience, you can also easily provide the syscall parameters to be used when the hijacked syscall is executed:</p> <p>Example of hijacking a syscall with parameters</p> <pre><code>#include &lt;unistd.h&gt;\n\nchar manufacturerName[32] = \"libdebug\";\nchar secretKey[32] = \"provola\";\n\nint main(int argc, char** argv)\n{\n    [...]\n\n    read(0, manufacturerName, 31);\n\n    [...]\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nmanufacturerBuffer = ...\n\nhandler = d.hijack_syscall(\"read\", \"write\",\n    syscall_arg0=0x1,\n    syscall_arg1=manufacturerBuffer,\n    syscall_arg2=0x100\n)\n\nd.cont()\nd.wait()\n\nout = pipe.recvline()\nprint(out.decode())\n</code></pre> <p>Again, the secret will be leaked to the standard output.</p>","boost":4},{"location":"stopping_events/watchpoints/","title":"Watchpoints","text":"<p>Watchpoints are a special type of hardware breakpoint that triggers when a specific memory location is accessed. You can set a watchpoint to trigger on certain memory access conditions, or upon execution (equivalent to a hardware breakpoint).</p> <p>Features of watchpoints are shared with breakpoints, so you can set asynchronous watchpoints and use properties in the same way.</p>","boost":4},{"location":"stopping_events/watchpoints/#libdebug-api-for-watchpoints","title":"libdebug API for Watchpoints","text":"<p>The <code>watchpoint()</code> function in the Debugger object sets a watchpoint at a specific address. While you can also use the breakpoint API to set up a watchpoint, a specific API is provided for your convenience:</p> <p>Function Signature</p> <pre><code>d.watchpoint(position, condition='w', length=1, callback=None, file='hybrid') \n</code></pre> <p>Parameters:</p> Argument Type Description <code>position</code> <code>int</code> | <code>str</code> The address or symbol where the watchpoint will be set. <code>condition</code> <code>str</code> The type of access (see later section). <code>length</code> <code>int</code> The size of the word being watched (see later section). <code>callback</code> <code>Callable</code> | <code>bool</code> (see callback signature here) Used to create asyncronous watchpoints (read more on the debugging flow of stopping events). <code>file</code> <code>str</code> The backing file for relative addressing. Refer to the memory access section for more information on addressing modes. <p>Returns:</p> Return Type Description <code>Breakpoint</code> Breakpoint The breakpoint object created.","boost":4},{"location":"stopping_events/watchpoints/#valid-access-conditions","title":"Valid Access Conditions","text":"<p>The <code>condition</code> parameter specifies the type of access that triggers the watchpoint. Default is write access.</p> Condition Description Supported Architectures <code>\"r\"</code> Read access AArch64 <code>\"w\"</code> Write access AMD64, AArch64 <code>\"rw\"</code> Read/write access AMD64, AArch64 <code>\"x\"</code> Execute access AMD64","boost":4},{"location":"stopping_events/watchpoints/#valid-word-lengths","title":"Valid Word Lengths","text":"<p>The <code>length</code> parameter specifies the size of the word being watched. By default, the watchpoint is set to watch a single byte.</p> Architecture Supported Lengths  AMD64 1, 2, 4, 8  i386 1, 2, 4  AArch64 Any length from 1 to 8 bytes <p>Watchpoint alignment in AArch64</p> <p>The address of the watchpoint on AArch64-based CPUs needs to be aligned to 8 bytes. Instead, basic hardware breakpoints have to be aligned to 4 bytes (which is the size of an ARM instruction).</p>","boost":4},{"location":"stopping_events/watchpoints/#callback-signature","title":"Callback Signature","text":"<p>If you wish to create an asynchronous watchpoint, you will have to provide a callback function. Since internally watchpoints are implemented as hardware breakpoints, the callback signature is the same as for breakpoints. As for breakpoints, if you want to leave the callback empty, you can set callback to <code>True</code>.</p> <p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, bp: Breakpoint):\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the breakpoint. <code>bp</code> Breakpoint The breakpoint object that triggered the callback. <p>Example usage of asynchronous watchpoints</p> <pre><code>def on_watchpoint_hit(t, bp):\n    print(f\"RAX: {t.regs.rax:#x}\")\n\n    if bp.hit_count == 100:\n        print(\"Hit count reached 100\")\n        bp.disable()\n\nd.watchpoint(0x11f0, condition=\"rw\", length=8, callback=on_watchpoint_hit, file=\"binary\")\n</code></pre>","boost":4},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2024/","title":"2024","text":""}]}