{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"","boost":2},{"location":"#quick-start","title":"Quick Start","text":"<p>Welcome to libdebug! This powerful Python library can be used to debug your binary executables programmatically, providing a robust, user-friendly interface. Debugging multithreaded applications can be a nightmare, but libdebug has you covered. Hijack and manage signals and syscalls with a simple API.</p> <p>Supported Systems</p> <p>libdebug currently supports Linux under the x86_64, x86 and ARM64 architectures. Other operating systems and architectures are not supported at this time.</p>","boost":2},{"location":"#dependencies","title":"Dependencies","text":"<p>To install libdebug, you first need to have some dependencies that will not be automatically resolved. These dependencies are libraries, utilities and development headers which are required by libdebug to compile its internals during installation.</p>  Ubuntu Arch Linux Fedora Debian <pre><code>sudo apt install -y python3 python3-dev libdwarf-dev libelf-dev libiberty-dev linux-headers-generic libc6-dbg\n</code></pre> <pre><code>sudo pacman -S python libelf libdwarf gcc make debuginfod\n</code></pre> <pre><code>sudo dnf install -y python3 python3-devel kernel-devel binutils-devel libdwarf-devel\n</code></pre> <pre><code>sudo apt install -y python3 python3-dev libdwarf-dev libelf-dev libiberty-dev linux-headers-generic libc6-dbg\n</code></pre> <p>Is your distro missing?</p> <p>If you are using a Linux distribution that is not included in this section, you can search for equivalent packages for your distro. Chances are the naming convention of your system's repository will only change a prefix or suffix.</p>","boost":2},{"location":"#installation","title":"Installation","text":"<p>Installing libdebug once you have dependencies is as simple as running the following command:</p> stabledevelopment <pre><code>python3 -m pip install libdebug\n</code></pre> <pre><code>python3 -m pip install git+https://github.com/libdebug/libdebug.git@dev\n</code></pre> <p>If you want to test your installation when installing from source, we provide a suite of tests that you can run:</p> Testing your installation<pre><code>cd test\npython run_suite.py\n</code></pre>","boost":2},{"location":"#your-first-script","title":"Your First Script","text":"<p>Now that you have libdebug installed, you can start using it in your scripts. Here is a simple example of how to use libdebug to debug an executable:</p> libdebug's Hello World!<pre><code>from libdebug import debugger\n\nd = debugger(\"./test\") # (1)\n\n# Start debugging from the entry point\nd.run() # (2)\n\nmy_breakpoint = d.breakpoint(\"function\") # (3)\n\n# Continue the execution until the breakpoint is hit\nd.cont() # (4)\n\n# Print RAX\nprint(f\"RAX is {hex(d.regs.rax)}\") # (5)\n</code></pre> <ol> <li>A debugger is created for the <code>test</code> executable</li> <li>The process is spawned and the entry point is reached</li> <li>A breakpoint is placed at the symbol <code>&lt;function&gt;</code> in the binary</li> <li>A continuation command is issued, execution resumes</li> <li>The value of the RAX register is read and printed</li> </ol>","boost":2},{"location":"#conflicts-with-other-python-packages","title":"Conflicts with other Python packages","text":"<p>Using pwntools alongside libdebug</p> <p>The current version of libdebug is incompatible with pwntools.</p> <p>While having both installed in your Python environment is not a problem, starting a process with pwntools in a libdebug script will cause unexpected behaviors as a result of some race conditions.</p> <p>Examples of some known issues include:</p> <ul> <li><code>ptrace</code> not intercepting SIGTRAP signals when the process is run with pwntools. This behavior is described in  Issue #48.</li> <li>Attaching libdebug to a process that was started with pwntools with <code>shell=True</code> will cause the process to attach to the shell process instead. This behavior is described in  Issue #57.</li> </ul>","boost":2},{"location":"#older-versions-of-the-documentation","title":"Older versions of the documentation","text":"<p>The documentation for versions of libdebug older that 0.7.0 has to be accessed manually at http://docs.libdebug.org/archive/VERSION, where <code>VERSION</code> is the version number you are looking for.</p>","boost":2},{"location":"#cite-us","title":"Cite Us","text":"<p>Need to cite libdebug in your research? Use the following BibTeX entry:</p> <pre><code>@software{libdebug_2024,\n    title = {libdebug: {Build} {Your} {Own} {Debugger}},\n    copyright = {MIT Licence},\n    url = {https://libdebug.org},\n    publisher = {libdebug.org},\n    author = {Digregorio, Gabriele and Bertolini, Roberto Alessandro and Panebianco, Francesco and Polino, Mario},\n    year = {2024},\n    doi = {10.5281/zenodo.13151549},\n}\n</code></pre>","boost":2},{"location":"basics/command_queue/","title":"Default VS ASAP Mode","text":"<p>For most commands that can be issued in libdebug, it is necessary that the traced process stops running. When the traced process stops running as a result of a stopping event, libdebug can inspect the state and intervene in its control flow. When one of this command is used in the script as the process is still running, libdebug will wait for the process to stop before executing the command.</p> <p>In the following example, the content of the <code>RAX</code> register is printed after the program hits the breakpoint or stops for any other reason:</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\nd.run()\n\nd.breakpoint(\"func\")\n\nd.cont()\n\nprint(f\"RAX: {hex(d.regs.rax)}\")\n</code></pre> <p>Script execution</p> <p>Please note that, after resuming execution of the tracee process, the script will continue to run. This means that the script will not wait for the process to stop before continuing with the rest of the script. If the next command is a libdebug command that requires the process to be stopped, the script will then wait for a stopping event before executing that command.</p> <p>In the following example, we make a similar scenario, but show how you can inspect the state of the process by arbitrarily stopping it in the default mode.</p> <pre><code>d = debugger(\"program\")\n\nd.run()\n\nd.breakpoint(\"func\")\n\nd.cont()\n\nprint(f\"RAX: {hex(d.regs.rax)}\") # (1)\n\nd.cont()\nd.interrupt() # (2)\n\nprint(f\"RAX: {hex(d.regs.rax)}\") # (3)\n\nd.cont()\n\n[...]\n</code></pre> <ol> <li>This is the value of RAX at the breakpoint.</li> <li>Stop the process shortly after the process resumes.</li> <li>This is the value of RAX at the arbitrary stop (shortly after the breakpoint). </li> </ol>","boost":4},{"location":"basics/command_queue/#asap-mode","title":"ASAP Mode","text":"<p>If you want the command to be executed As Soon As Possible (ASAP) instead of waiting for a stopping event, you can specify it when creating the Debugger object. In this mode, the debugger will stop the process and issue the command as it runs your script without waiting. The following script has the same behavior as the previous one, using the corresponding option:</p> <pre><code>d = debugger(\"program\", auto_interrupt_on_command=True)\n\nd.run()\n\nd.breakpoint(\"func\")\n\nd.cont()\nd.wait()\n\nprint(f\"RAX: {hex(d.regs.rax)}\") # (1)\n\nd.cont()\n\nprint(f\"RAX: {hex(d.regs.rax)}\") # (2)\n\nd.cont()\n\n[...]\n</code></pre> <ol> <li>This is the value of RAX at the breakpoint.</li> <li>This is the value of RAX shortly after the breakpoint. The process is forcibly stopped to read the register.</li> </ol> <p>For the sake of this example the <code>wait()</code> method is used to wait for the stopping event (in this case, a breakpoint). This enforces the syncronization of the execution to the stopping point that we want to reach. Read more about the <code>wait()</code> method in the section dedicated to control flow commands.</p> <p>Pwning with libdebug</p> <p>Respectable pwners in the field find that the ASAP polling mode is particularly useful when writing exploits.</p>","boost":4},{"location":"basics/control_flow_commands/","title":"Control Flow Commands","text":"<p>Control flow commands allow you to set step through the code, stop execution and resume it at your pleasure. </p>","boost":4},{"location":"basics/control_flow_commands/#stepping","title":"Stepping","text":"<p>A basic feature of any debugger is the ability to step through the code. libdebug provides several methods to step, some of which will be familiar to users of other debuggers.</p>","boost":4},{"location":"basics/control_flow_commands/#single-step","title":"Single Step","text":"<p>The <code>step()</code> command executes the instruction at the instruction pointer and stops the process. When possible, it uses the hardware single-step feature of the CPU for better performance.</p> <p>Function Signature</p> <pre><code>d.step()\n</code></pre>","boost":4},{"location":"basics/control_flow_commands/#next","title":"Next","text":"<p>The <code>next()</code> command executes the current instruction at the instruction pointer and stops the process. If the instruction is a function call, it will execute the whole function and stop at the instruction following the call. In other debuggers, this command is known as \"step over\".</p> <p>Please note that the <code>next()</code> command resumes the execution of the program if the instruction is a function call. This means that the debugger can encounter stopping events in the middle of the function, causing the command to return before the function finishes.</p> <p>Function Signature</p> <pre><code>d.next()\n</code></pre> <p>Damn heuristics!</p> <p>The <code>next()</code> command uses heuristics to determine if the instruction is a function call and to find the stopping point. This means that the command may not work as expected in some cases (e.g. functions called with a jump, non-returning calls).</p>","boost":4},{"location":"basics/control_flow_commands/#step-until","title":"Step Until","text":"<p>The <code>step_until()</code> command executes single steps until a specific address is reached. Optionally, you can also limit steps to a maximum count (default value is -1, meaning no limit).</p> <p>Function Signature</p> <pre><code>d.step_until(position, max_steps=-1, file='hybrid') \n</code></pre> <p>The file parameter can be used to specify the choice on relative addressing. Refer to the memory access section for more information on addressing modes.</p>","boost":4},{"location":"basics/control_flow_commands/#continuing","title":"Continuing","text":"<p>The <code>cont()</code> command continues the execution.</p> <p>Function Signature</p> <pre><code>d.cont()\n</code></pre> <p>For example, in the following script, libdebug will not wait for the process to stop before checking d.dead. To change this behavior, you can use the <code>wait()</code> command right after the <code>cont()</code>. <pre><code>from libdebug import debugger\n\nd = debugger(\"program_that_dies_tragically\")\n\nd.run()\n\nd.cont()\n\nif d.dead:\n    print(\"The program is dead!\")\n</code></pre></p>","boost":4},{"location":"basics/control_flow_commands/#the-wait-method","title":"The <code>wait()</code> Method","text":"<p>The <code>wait()</code> command is likely the most important in libdebug. Loved by most and hated by many, it instructs the debugger to wait for a stopping event before continuing with the execution of the script.</p> <p>Example</p> <p>In the following script, libdebug will wait for the process to stop before printing \"provola\". <pre><code>from libdebug import debugger\n\nd = debugger(\"program_that_dies_tragically\")\n\nd.run()\n\nd.cont()\nd.wait()\n\nprint(\"provola\")\n</code></pre></p>","boost":4},{"location":"basics/control_flow_commands/#interrupt","title":"Interrupt","text":"<p>You can manually issue a stopping signal to the program using the <code>interrupt()</code> command. Clearly, this command is issued as soon as it is executed within the script.</p> <p>Function Signature</p> <pre><code>d.interrupt()\n</code></pre>","boost":4},{"location":"basics/control_flow_commands/#finish","title":"Finish","text":"<p>The <code>finish()</code> command continues execution until the current function returns or a breakpoint is hit. In other debuggers, this command is known as \"step out\".</p> <p>Function Signature</p> <pre><code>d.finish(heuristic='backtrace')\n</code></pre> <p>Damn heuristics!</p> <p>The <code>finish()</code> command uses heuristics to determine the end of a function. While libdebug allows to choose the heuristic, it is possible that none of the available options work in some specific cases. (e.g. tail-calls, non-returning calls).</p>","boost":4},{"location":"basics/control_flow_commands/#available-heuristics","title":"Available Heuristics","text":"<p>The <code>finish()</code> command allows you to choose the heuristic to use. If you don't specify any, the <code>\"backtrace\"</code> heuristic will be used. The following heuristics are available:</p> Heuristic Description <code>backtrace</code> The <code>backtrace</code> heuristic uses the return address on the function stack frame to determine the end of the function. This is the default heuristic but may fail in case of broken stack, rare execution flows, and obscure compiler optimizations. <code>step-mode</code> The <code>step-mode</code> heuristic uses repeated single steps to execute instructions until a <code>ret</code> instruction is reached. Nested calls are handled, when the calling convention is respected. This heuristic is slower and may fail in case of rare execution flows and obscure compiler optimizations.","boost":4},{"location":"basics/detach_and_gdb/","title":"Detach and GDB Migration","text":"<p>In libdebug, you can detach from the debugged process and continue execution with the <code>detach()</code> method.</p> <p>Function Signature</p> <pre><code>d.detach()\n</code></pre> <p>Detaching from a running process</p> <p>Remember that detaching from a process is meant to be used when the process is stopped. If the process is running, the command will wait for a stopping event. To forcibly stop the process, you can use the <code>interrupt()</code> method before migrating.</p>","boost":4},{"location":"basics/detach_and_gdb/#gdb-migration","title":"GDB Migration","text":"<p>If at any time during your script you want to take a more traditional approach to debugging, you can seamlessly switch to GDB. This will temporarily detach libdebug from the program and give you control over the program using GDB. Quitting GDB will return control to libdebug.</p> <p>Function Signature</p> <pre><code>d.gdb(\n    migrate_breakpoints: bool = True,\n    open_in_new_process: bool = True,\n    blocking: bool = True,\n) -&gt; GdbResumeEvent:\n</code></pre> Parameter Description <code>migrate_breakpoints</code> If set to <code>True</code>, libdebug will migrate the breakpoints to GDB. <code>open_in_new_process</code> If set to <code>True</code>, libdebug will open GDB in a new process. <code>blocking</code> If set to <code>True</code>, libdebug will wait for the user to terminate the GDB session to continue the script. <p>Setting the <code>blocking</code> to <code>False</code> is useful when you want to continue using the pipe interaction and other parts of your script as you take control of the debugging process. </p> <p>Please consider a few requirements when opening GDB in a new process. For this mode to work, libdebug needs to know which terminal emulator you are using. If not set, libdebug will try to detect this automatically. In some cases, detection may fail. You can manually set the terminal command in libcontext. If instead of opening GDB in a new terminal window you want to use the current terminal, you can simply set the <code>open_in_new_process</code> parameter to <code>False</code>.</p> <p>Example of setting the terminal with tmux</p> <pre><code>from libdebug import libcontext\n\nlibcontext.terminal = ['tmux', 'splitw', '-h']\n</code></pre> <p>Migrating from a running process</p> <p>Remember that GDB Migration is meant to be used when the process is stopped. If the process is running, the command will wait for a stopping event. To forcibly stop the process, you can use the <code>interrupt()</code> method before migrating.</p>","boost":4},{"location":"basics/detach_and_gdb/#graceful-termination","title":"Graceful Termination","text":"<p>If you are finished working with a Debugger object and wish to deallocate it, you can terminate it using the <code>terminate()</code> command.</p> <p>Function Signature</p> <pre><code>d.terminate()\n</code></pre> <p>What happens to the running process?</p> <p>When you terminate a Debugger object, the process is forcibly killed. If you wish to detach from the process and continue execution before terminating it, you should use the <code>detach()</code> command before.</p>","boost":4},{"location":"basics/kill_and_post_mortem/","title":"Process Death (and afterlife)","text":"<p>The default behavior in libdebug is to kill the debugged process when the script exits. This is done to prevent the process from running indefinitely if the debugging script terminates or you forget to kill it manually. When creating a Debugger object, you can set the <code>kill_on_exit</code> attribute to <code>False</code> to prevent this behavior:</p> <pre><code>from libdebug import Debugger\n\nd = debugger(\"test\", kill_on_exit=False)\n</code></pre> <p>You can also change this attribute in an existing Debugger object at runtime:  </p> <pre><code>d.kill_on_exit = False\n</code></pre> <p>Behavior when attaching to a process</p> <p>When debugging is initiated by attaching to an existing process, the <code>kill_on_exit</code> policy is enforced in the same way as when starting a new process.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#killing-the-process","title":"Killing the Process","text":"<p>You can kill the process any time the process is stopped using the <code>kill()</code> method:</p> <pre><code>d.kill()\n</code></pre> <p>The method sends a <code>SIGKILL</code> signal to the process, which terminates it immediately. If the process is already dead, libdebug will throw an exception. When multiple threads are running, the <code>kill()</code> method will kill all threads under the parent process.</p> <p>Process Stop</p> <p>The <code>kill()</code> method will not stop a running process, unless libdebug is operating in ASAP Mode. Just like other commands, in the default mode, the <code>kill()</code> method will wait for the process to stop before executing.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#post-mortem-analysis","title":"Post Mortem Analysis","text":"<p>You can check if the process is dead using the <code>dead</code> property:</p> <pre><code>if not d.dead:\n    print(\"The process is not dead\")\nelse:\n    print(\"The process is dead\")\n</code></pre> <p>The <code>running</code> property</p> <p>The Debugger object also exposes the <code>running</code> property. This is not the opposite of <code>dead</code>. The <code>running</code> property is <code>True</code> when the process is not stopped and <code>False</code> otherwise. If execution was stopped by a stopping event, the <code>running</code> property will be equal to <code>False</code>. However, in this case the process can still be alive.</p>","boost":4},{"location":"basics/kill_and_post_mortem/#cause-of-death","title":"Cause of Death","text":"<p>Has your process passed away unexpectedly? We are sorry to hear that. If your process is indeed defunct, you can access the exit code and signal using <code>exit_code</code> and <code>exit_signal</code>. When there is no valid exit code or signal, these properties will return <code>None</code>.</p> <pre><code>if d.dead:\n    print(f\"The process exited with code {d.exit_code}\")\n\nif d.dead:\n    print(f\"The process exited with signal {d.exit_signal}\")\n</code></pre>","boost":4},{"location":"basics/libdebug101/","title":"libdebug 101","text":"<p>Welcome to libdebug! When writing a script to debug a program, the first step is to create a Debugger object. This object will be your main interface for debugging commands.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(argv=[\"./program\", \"arg1\", \"arg2\"]) # (1)\n</code></pre> <ol> <li><code>argv</code> can either be a string (the name/path of the executable) or an array corresponding to the argument vector of the execution.</li> </ol> <p>Am I already debugging?</p> <p>Creating a Debugger object will not start the execution automatically. You can reuse the same debugger to iteratively run multiple instances of the program. This is particularly useful for smart bruteforcing or fuzzing scripts.</p> <p>Performing debugger initialization each time is not required and can be expensive.</p> <p>To run the executable, refer to Running an Executable</p>","boost":4},{"location":"basics/libdebug101/#environment","title":"Environment","text":"<p>Just as you would expect, you can also pass environment variables to the program using the <code>env</code> parameter. Here, the variables are passed as a string-string dictionary.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", env = {\"LD_PRELOAD\": \"musl_libc.so\"})\n</code></pre>","boost":4},{"location":"basics/libdebug101/#address-space-layout-randomization-aslr","title":"Address Space Layout Randomization (ASLR)","text":"<p>Modern operating system kernels implement mitigations against predictable addresses in binary exploitation scenarios. One such feature is ASLR, which randomizes the base address of mapped virtual memory pages (e.g., binary, libraries, stack). When debugging, this feature can become a nuisance for the user.</p> <p>By default, libdebug keeps ASLR enabled. The debugger <code>aslr</code> parameter can be used to change this behavior.</p> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", aslr=False)\n</code></pre>","boost":4},{"location":"basics/libdebug101/#binary-entry-point","title":"Binary Entry Point","text":"<p>When a child process is spawned on the Linux kernel through the <code>ptrace</code> system call, it is possible to trace it as soon as the loader has set up your executable. Debugging these first instructions inside the loader library is generally uninteresting.</p> <p>For this reason, the default behavior for libdebug is to continue until the binary entry point (1) is reached. When you need to start debugging from the very beginning, you can simply disable this behavior in the following way:</p> <ol> <li>In Linux, the binary entry point corresponds to the <code>_start</code> / <code>__rt_entry</code> symbol in your binary executable. This function is the initial stub that calls the <code>main()</code> function in your executable, through a call to the standard library of your system (e.g., <code>__libc_start_main</code>, <code>__rt_lib_init</code>)</li> </ol> <pre><code>from libdebug import debugger\n\ndebugger = debugger(\"test\", continue_to_binary_entrypoint=False)\n</code></pre> <p>What the hell are you debugging?</p> <p>Please note that this feature assumes the binary is well-formed. If the ELF header is corrupt, the binary entrypoint will not be resolved correctly. As such, setting this parameter to <code>False</code> is a good practice when you don't want libdebug to rely on this information.</p>","boost":4},{"location":"basics/libdebug101/#what-else-can-i-do","title":"What else can I do?","text":"<p>The Debugger object has many more parameters it can take.</p> <p>Function Signature</p> <pre><code>debugger(\n    argv=[],\n    aslr=True,\n    env=None,\n    escape_antidebug=False,\n    continue_to_binary_entrypoint=True,\n    auto_interrupt_on_command=False,\n    fast_memory=False,\n    kill_on_exit=True\n) -&gt; Debugger\n</code></pre> Parameter Type Description <code>argv</code> <code>str</code> | <code>list[str]</code> Path to the binary or argv list <code>aslr</code> <code>bool</code> Whether to enable ASLR. Defaults to True. <code>env</code> <code>dict[str, str]</code> The environment variables to use. Defaults to the same environment of the parent process. <code>escape_antidebug</code> <code>bool</code> Whether to automatically attempt to patch antidebugger detectors based on <code>ptrace</code>. <code>continue_to_binary_entrypoint</code> <code>bool</code> Whether to automatically continue to the binary entrypoint. <code>auto_interrupt_on_command</code> <code>bool</code> Whether to run libdebug in ASAP Mode. <code>fast_memory</code> <code>bool</code> Whether to use a faster memory reading method. Defaults to False. <code>kill_on_exit</code> <code>bool</code> Whether to kill the debugged process when the debugger exits. Defaults to True. Return Value Debugger <code>Debugger</code> The debugger object","boost":4},{"location":"basics/memory_access/","title":"Memory Access","text":"<p>In libdebug, memory access is performed via the <code>memory</code> attribute of the Debugger object or the Thread Context. When reading from memory, a bytes-like object is returned. The following methods are available:</p> Single byte accessSlice accessBase and lengthSymbol accessSymbol Range <p>Access a single byte of memory by providing the address as an integer. <pre><code>d.memory[0x1000]\n</code></pre></p> <p>Access a range of bytes by providing the start and end addresses as integers. <pre><code>d.memory[0x1000:0x1010]\n</code></pre></p> <p>Access a range of bytes by providing the base address and length as integers. <pre><code>d.memory[0x1000, 0x10]\n</code></pre></p> <p>Access memory using a symbol name. <pre><code>d.memory[\"function\", 0x8]\n</code></pre></p> <p>When specifying a symbol, you can also provide an offset. Contrary to what happens in GDB, the offset is always interpreted as hexadecimal. <pre><code>d.memory[\"function+a8\"]\n</code></pre></p> <p>Access a range of bytes using a symbol name. <pre><code>d.memory[\"function\":\"function+0f\"]\n</code></pre> Please note that contrary to what happens in GDB, the offset is always interpreted as hexadecimal.</p> <p>Accessing memory with symbols</p> <p>Please note that, unless otherwise specified, symbols are resolved in the debugged binary only. To resolve symbols in shared libraries, you need to indicate it in the third parameter of the function.</p> <pre><code>d.memory[\"__libc_start_main\", 0x8, \"libc\"]\n</code></pre> <p>Writing to memory works similarly. You can write a bytes-like object to memory using the same addressing methods:</p> <pre><code>d.memory[d.rsp, 0x10] = b\"AAAAAAABC\"\nd.memory[\"main_arena\", 16, \"libc\"] = b\"12345678\"\n</code></pre> <p>Length/Slice when writing</p> <p>When writing to memory, slices and length are ignored in favor of the length of the specified bytes-like object.</p> <p>In the following example, only 4 bytes are written:</p> <pre><code>d.memory[\"main_arena\", 50] = b\"\\x0a\\xeb\\x12\\xfc\"\n</code></pre>","boost":4},{"location":"basics/memory_access/#absolute-and-relative-addressing","title":"Absolute and Relative Addressing","text":"<p>Just like with symbols, memory addresses can also be accessed relative to a certain file base. libdebug uses <code>\"hybrid\"</code> addressing by default. This means it first attempts to resolve addresses as absolute. If the address does not correspond to an absolute one, it considers it relative to the base of the binary.</p> <p>You can use the third parameter of the memory access method to select the file you want to use as base (e.g., libc, ld, binary). If you want to force libdebug to use absolute addressing, you can specify <code>\"absolute\"</code> instead.</p> <p>Examples of relative and absolute addressing</p> <pre><code># Absolute addressing\nd.memory[0x7ffff7fcb200, 0x10, \"absolute\"]\n\n# Hybrid addressing\nd.memory[0x1000, 0x10, \"hybrid\"]\n\n# Relative addressing\nd.memory[0x1000, 0x10, \"binary\"]\nd.memory[0x1000, 0x10, \"libc\"]\n</code></pre>","boost":4},{"location":"basics/memory_access/#searching-inside-memory","title":"Searching inside Memory","text":"<p>The <code>memory</code> attribute of the Debugger object also allows you to search for specific values in the memory of the process. You can search for integers, strings, or bytes-like objects.</p> <p>Function Signature</p> <pre><code>d.memory.find(\n    value: int | bytes | str,\n    file: str = \"all\",\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; list[int]:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>value</code> <code>int</code> | <code>bytes</code> | <code>str</code> The value to search for. <code>file</code> <code>str</code> The backing file to search in (e.g, binary, libc, stack). <code>start</code> <code>int</code> (optional) The start address of the search (works with both relative and absolute). <code>end</code> <code>int</code> (optional) The end address of the search (works with both relative and absolute). <p>Returns:</p> Return Type Description <code>Addresses</code> <code>list[int]</code> List of memory addresses where the value was found. <p>Usage Example</p> <pre><code>bish_string_addr = d.memory.find(\"/bin/sh\", file=\"libc\")\n\nvalue_address = d.memory.find(0x1234, file=\"stack\", start=d.regs.rsp)\n</code></pre>","boost":4},{"location":"basics/memory_access/#faster-memory-access","title":"Faster Memory Access","text":"<p>Warning: This feature is Experimental!</p> <p>This feature is experimental and may not work as expected. Please report any issues you encounter  here.</p> <p>By default, libdebug reads and writes memory using the <code>ptrace</code> system call interface. However, this is not the most efficient way to access memory and will likely be changed in future versions.</p> <p>To speed up memory access, you can already enable a faster system that relies on Linux's procfs. To use it, simply set the <code>fast_memory</code> parameter to <code>True</code> when creating the Debugger object. You can also enable and disable this feature at runtime by accessing the debugger's attribute.</p> When creating the Debugger objectAt runtime <pre><code>d = debugger(\"test\", fast_memory=True)\n</code></pre> <pre><code>d.fast_memory = True\n</code></pre>","boost":4},{"location":"basics/register_access/","title":"Register Access","text":"<p>libdebug offers a simple register access interface for supported architectures. Registers are accessible through the <code>regs</code> attribute of the Debugger object or the Thread Context.</p> <p>Multithreading</p> <p>In multi-threaded debugging, the <code>regs</code> attribute of the Debugger object will return the registers of the main thread.</p> <p>The following is an example of how to interact with the <code>RAX</code> register in a debugger object on AMD64:</p> Operation Code Snippet Reading <code>read_value = d.regs.rax</code> Writing <code>d.regs.rax = read_value + 1</code> <p>Note that the register values are read and written as Python integers. This is true for all registers except for floating point ones, which are coherent with their type. To avoid confusion, we list available registers and their types below. Related registers are available to access as well.</p> AMD64i386AArch64 Register Type Related Description General Purpose RAX Integer EAX, AX, AH, AL Accumulator register RBX Integer EBX, BX, BH, BL Base register RCX Integer ECX, CX, CH, CL Counter register RDX Integer EDX, DX, DH, DL Data register RSI Integer ESI, SI Source index for string operations RDI Integer EDI, DI Destination index for string operations RBP Integer EBP, BP Base pointer (frame pointer) RSP Integer ESP, SP Stack pointer R8 Integer R8D, R8W, R8B General-purpose register R9 Integer R9D, R9W, R9B General-purpose register R10 Integer R10D, R10W, R10B General-purpose register R11 Integer R11D, R11W, R11B General-purpose register R12 Integer R12D, R12W, R12B General-purpose register R13 Integer R13D, R13W, R13B General-purpose register R14 Integer R14D, R14W, R14B General-purpose register R15 Integer R15D, R15W, R15B General-purpose register RIP Integer EIP Instruction pointer Flags EFLAGS Integer Flags register Segment Registers CS Integer Code segment DS Integer Data segment ES Integer Extra segment FS Integer Additional segment GS Integer Additional segment SS Integer Stack segment FS_BASE Integer FS segment base address GS_BASE Integer GS segment base address Vector Registers XMM0 Integer Lower 128 bits of YMM0/ZMM0 XMM1 Integer Lower 128 bits of YMM1/ZMM1 XMM2 Integer Lower 128 bits of YMM2/ZMM2 XMM3 Integer Lower 128 bits of YMM3/ZMM3 XMM4 Integer Lower 128 bits of YMM4/ZMM4 XMM5 Integer Lower 128 bits of YMM5/ZMM5 XMM6 Integer Lower 128 bits of YMM6/ZMM6 XMM7 Integer Lower 128 bits of YMM7/ZMM7 XMM8 Integer Lower 128 bits of YMM8/ZMM8 XMM9 Integer Lower 128 bits of YMM9/ZMM9 XMM10 Integer Lower 128 bits of YMM10/ZMM10 XMM11 Integer Lower 128 bits of YMM11/ZMM11 XMM12 Integer Lower 128 bits of YMM12/ZMM12 XMM13 Integer Lower 128 bits of YMM13/ZMM13 XMM14 Integer Lower 128 bits of YMM14/ZMM14 XMM15 Integer Lower 128 bits of YMM15/ZMM15 YMM0 Integer 256-bit AVX extension of XMM0 YMM1 Integer 256-bit AVX extension of XMM1 YMM2 Integer 256-bit AVX extension of XMM2 YMM3 Integer 256-bit AVX extension of XMM3 YMM4 Integer 256-bit AVX extension of XMM4 YMM5 Integer 256-bit AVX extension of XMM5 YMM6 Integer 256-bit AVX extension of XMM6 YMM7 Integer 256-bit AVX extension of XMM7 YMM8 Integer 256-bit AVX extension of XMM8 YMM9 Integer 256-bit AVX extension of XMM9 YMM10 Integer 256-bit AVX extension of XMM10 YMM11 Integer 256-bit AVX extension of XMM11 YMM12 Integer 256-bit AVX extension of XMM12 YMM13 Integer 256-bit AVX extension of XMM13 YMM14 Integer 256-bit AVX extension of XMM14 YMM15 Integer 256-bit AVX extension of XMM15 ZMM0 Integer 512-bit AVX-512 extension of XMM0 ZMM1 Integer 512-bit AVX-512 extension of XMM1 ZMM2 Integer 512-bit AVX-512 extension of XMM2 ZMM3 Integer 512-bit AVX-512 extension of XMM3 ZMM4 Integer 512-bit AVX-512 extension of XMM4 ZMM5 Integer 512-bit AVX-512 extension of XMM5 ZMM6 Integer 512-bit AVX-512 extension of XMM6 ZMM7 Integer 512-bit AVX-512 extension of XMM7 ZMM8 Integer 512-bit AVX-512 extension of XMM8 ZMM9 Integer 512-bit AVX-512 extension of XMM9 ZMM10 Integer 512-bit AVX-512 extension of XMM10 ZMM11 Integer 512-bit AVX-512 extension of XMM11 ZMM12 Integer 512-bit AVX-512 extension of XMM12 ZMM13 Integer 512-bit AVX-512 extension of XMM13 ZMM14 Integer 512-bit AVX-512 extension of XMM14 ZMM15 Integer 512-bit AVX-512 extension of XMM15 Floating Point (Legacy x87) ST(0)-ST(7) Floating Point x87 FPU data registers MM0-MM7 Integer MMX registers Register Type Related Description General Purpose EAX Integer AX, AH, AL Accumulator register EBX Integer BX, BH, BL Base register ECX Integer CX, CH, CL Counter register EDX Integer DX, DH, DL Data register ESI Integer SI Source index for string operations EDI Integer DI Destination index for string operations EBP Integer BP Base pointer (frame pointer) ESP Integer SP Stack pointer EIP Integer IP Instruction pointer Flags EFLAGS Integer Flags register Segment Registers CS Integer Code segment DS Integer Data segment ES Integer Extra segment FS Integer Additional segment GS Integer Additional segment SS Integer Stack segment Floating Point Registers ST(0)-ST(7) Floating Point x87 FPU data registers Vector Registers XMM0 Integer Lower 128 bits of YMM0/ZMM0 XMM1 Integer Lower 128 bits of YMM1/ZMM1 XMM2 Integer Lower 128 bits of YMM2/ZMM2 XMM3 Integer Lower 128 bits of YMM3/ZMM3 XMM4 Integer Lower 128 bits of YMM4/ZMM4 XMM5 Integer Lower 128 bits of YMM5/ZMM5 XMM6 Integer Lower 128 bits of YMM6/ZMM6 XMM7 Integer Lower 128 bits of YMM7/ZMM7 YMM0 Integer 256-bit AVX extension of XMM0 YMM1 Integer 256-bit AVX extension of XMM1 YMM2 Integer 256-bit AVX extension of XMM2 YMM3 Integer 256-bit AVX extension of XMM3 YMM4 Integer 256-bit AVX extension of XMM4 YMM5 Integer 256-bit AVX extension of XMM5 YMM6 Integer 256-bit AVX extension of XMM6 YMM7 Integer 256-bit AVX extension of XMM7 Register Type Alias(es) Description General Purpose X0 Integer W0 Function result or argument X1 Integer W1 Function result or argument X2 Integer W2 Function result or argument X3 Integer W3 Function result or argument X4 Integer W4 Function result or argument X5 Integer W5 Function result or argument X6 Integer W6 Function result or argument X7 Integer W7 Function result or argument X8 Integer W8 Indirect result location (also called \"IP0\") X9 Integer W9 Temporary register X10 Integer W10 Temporary register X11 Integer W11 Temporary register X12 Integer W12 Temporary register X13 Integer W13 Temporary register X14 Integer W14 Temporary register X15 Integer W15 Temporary register (also called \"IP1\") X16 Integer W16 Platform Register (often used as scratch) X17 Integer W17 Platform Register (often used as scratch) X18 Integer W18 Platform Register X19 Integer W19 Callee-saved register X20 Integer W20 Callee-saved register X21 Integer W21 Callee-saved register X22 Integer W22 Callee-saved register X23 Integer W23 Callee-saved register X24 Integer W24 Callee-saved register X25 Integer W25 Callee-saved register X26 Integer W26 Callee-saved register X27 Integer W27 Callee-saved register X28 Integer W28 Callee-saved register X29 Integer W29, FP Frame pointer X30 Integer W30, LR Link register (return address) XZR Integer WZR, ZR Zero register (always reads as zero) SP Integer Stack pointer PC Integer Program counter Flags PSTATE Integer Processor state in exception handling Vector Registers (SIMD/FP) V0 Integer Vector or scalar register V1 Integer Vector or scalar register V2 Integer Vector or scalar register V3 Integer Vector or scalar register V4 Integer Vector or scalar register V5 Integer Vector or scalar register V6 Integer Vector or scalar register V7 Integer Vector or scalar register V8 Integer Vector or scalar register V9 Integer Vector or scalar register V10 Integer Vector or scalar register V11 Integer Vector or scalar register V12 Integer Vector or scalar register V13 Integer Vector or scalar register V14 Integer Vector or scalar register V15 Integer Vector or scalar register V16 Integer Vector or scalar register V17 Integer Vector or scalar register V18 Integer Vector or scalar register V19 Integer Vector or scalar register V20 Integer Vector or scalar register V21 Integer Vector or scalar register V22 Integer Vector or scalar register V23 Integer Vector or scalar register V24 Integer Vector or scalar register V25 Integer Vector or scalar register V26 Integer Vector or scalar register V27 Integer Vector or scalar register V28 Integer Vector or scalar register V29 Integer Vector or scalar register V30 Integer Vector or scalar register V31 Integer Vector or scalar register Q0 Integer Vector or scalar register Q1 Integer Vector or scalar register Q2 Integer Vector or scalar register Q3 Integer Vector or scalar register Q4 Integer Vector or scalar register Q5 Integer Vector or scalar register Q6 Integer Vector or scalar register Q7 Integer Vector or scalar register Q8 Integer Vector or scalar register Q9 Integer Vector or scalar register Q10 Integer Vector or scalar register Q11 Integer Vector or scalar register Q12 Integer Vector or scalar register Q13 Integer Vector or scalar register Q14 Integer Vector or scalar register Q15 Integer Vector or scalar register Q16 Integer Vector or scalar register Q17 Integer Vector or scalar register Q18 Integer Vector or scalar register Q19 Integer Vector or scalar register Q20 Integer Vector or scalar register Q21 Integer Vector or scalar register Q22 Integer Vector or scalar register Q23 Integer Vector or scalar register Q24 Integer Vector or scalar register Q25 Integer Vector or scalar register Q26 Integer Vector or scalar register Q27 Integer Vector or scalar register Q28 Integer Vector or scalar register Q29 Integer Vector or scalar register Q30 Integer Vector or scalar register Q31 Integer Vector or scalar register D0 Integer Vector or scalar register D1 Integer Vector or scalar register D2 Integer Vector or scalar register D3 Integer Vector or scalar register D4 Integer Vector or scalar register D5 Integer Vector or scalar register D6 Integer Vector or scalar register D7 Integer Vector or scalar register D8 Integer Vector or scalar register D9 Integer Vector or scalar register D10 Integer Vector or scalar register D11 Integer Vector or scalar register D12 Integer Vector or scalar register D13 Integer Vector or scalar register D14 Integer Vector or scalar register D15 Integer Vector or scalar register D16 Integer Vector or scalar register D17 Integer Vector or scalar register D18 Integer Vector or scalar register D19 Integer Vector or scalar register D20 Integer Vector or scalar register D21 Integer Vector or scalar register D22 Integer Vector or scalar register D23 Integer Vector or scalar register D24 Integer Vector or scalar register D25 Integer Vector or scalar register D26 Integer Vector or scalar register D27 Integer Vector or scalar register D28 Integer Vector or scalar register D29 Integer Vector or scalar register D30 Integer Vector or scalar register D31 Integer Vector or scalar register S0 Integer Vector or scalar register S1 Integer Vector or scalar register S2 Integer Vector or scalar register S3 Integer Vector or scalar register S4 Integer Vector or scalar register S5 Integer Vector or scalar register S6 Integer Vector or scalar register S7 Integer Vector or scalar register S8 Integer Vector or scalar register S9 Integer Vector or scalar register S10 Integer Vector or scalar register S11 Integer Vector or scalar register S12 Integer Vector or scalar register S13 Integer Vector or scalar register S14 Integer Vector or scalar register S15 Integer Vector or scalar register S16 Integer Vector or scalar register S17 Integer Vector or scalar register S18 Integer Vector or scalar register S19 Integer Vector or scalar register S20 Integer Vector or scalar register S21 Integer Vector or scalar register S22 Integer Vector or scalar register S23 Integer Vector or scalar register S24 Integer Vector or scalar register S25 Integer Vector or scalar register S26 Integer Vector or scalar register S27 Integer Vector or scalar register S28 Integer Vector or scalar register S29 Integer Vector or scalar register S30 Integer Vector or scalar register S31 Integer Vector or scalar register H0 Integer Vector or scalar register H1 Integer Vector or scalar register H2 Integer Vector or scalar register H3 Integer Vector or scalar register H4 Integer Vector or scalar register H5 Integer Vector or scalar register H6 Integer Vector or scalar register H7 Integer Vector or scalar register H8 Integer Vector or scalar register H9 Integer Vector or scalar register H10 Integer Vector or scalar register H11 Integer Vector or scalar register H12 Integer Vector or scalar register H13 Integer Vector or scalar register H14 Integer Vector or scalar register H15 Integer Vector or scalar register H16 Integer Vector or scalar register H17 Integer Vector or scalar register H18 Integer Vector or scalar register H19 Integer Vector or scalar register H20 Integer Vector or scalar register H21 Integer Vector or scalar register H22 Integer Vector or scalar register H23 Integer Vector or scalar register H24 Integer Vector or scalar register H25 Integer Vector or scalar register H26 Integer Vector or scalar register H27 Integer Vector or scalar register H28 Integer Vector or scalar register H29 Integer Vector or scalar register H30 Integer Vector or scalar register H31 Integer Vector or scalar register B0 Integer Vector or scalar register B1 Integer Vector or scalar register B2 Integer Vector or scalar register B3 Integer Vector or scalar register B4 Integer Vector or scalar register B5 Integer Vector or scalar register B6 Integer Vector or scalar register B7 Integer Vector or scalar register B8 Integer Vector or scalar register B9 Integer Vector or scalar register B10 Integer Vector or scalar register B11 Integer Vector or scalar register B12 Integer Vector or scalar register B13 Integer Vector or scalar register B14 Integer Vector or scalar register B15 Integer Vector or scalar register B16 Integer Vector or scalar register B17 Integer Vector or scalar register B18 Integer Vector or scalar register B19 Integer Vector or scalar register B20 Integer Vector or scalar register B21 Integer Vector or scalar register B22 Integer Vector or scalar register B23 Integer Vector or scalar register B24 Integer Vector or scalar register B25 Integer Vector or scalar register B26 Integer Vector or scalar register B27 Integer Vector or scalar register B28 Integer Vector or scalar register B29 Integer Vector or scalar register B30 Integer Vector or scalar register B31 Integer Vector or scalar register <p>Hardware Support</p> <p>libdebug only exposes registers which are available on your CPU model. For AMD64, the list of available AVX registers is determined by checking the CPU capabilities. If you believe your CPU supports AVX registers but they are not available, we encourage your to open an  Issue with your hardware details.</p>","boost":4},{"location":"basics/register_access/#filtering-registers","title":"Filtering Registers","text":"<p>The <code>regs</code> field of the Debugger object or the Thread Context can also be used to filter registers with specific values.</p> <p>Function Signature</p> <pre><code>d.regs.filter(value: float) -&gt; list[str]:\n</code></pre> <p>The filtering routine will look for the given value in both integer and floating point registers.</p> <p>Example of Filtering Registers</p> <pre><code>d.regs.rax = 0x1337\n\n# Filter the value 0x1337 in the registers\nresults = d.regs.filter(0x1337)\nprint(f\"Found in: {results}\")\n</code></pre>","boost":4},{"location":"basics/running_an_executable/","title":"Running an Executable","text":"<p>You have created your first debugger object, and now you want to run the executable. Calling the <code>run()</code> method will spawn a new child process and prepare it for the execution of your binary.</p> <p><pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\nd.run()\n</code></pre> At this point, the process execution is stopped, waiting for your commands.</p> <p>A few things to keep in mind</p> <ul> <li>Please remember that the process you are debugging (the tracee) and the debugger itself are running in different threads. </li> <li>Also note that breakpoints and other stopping events set by the user are not kept between different runs of the program. If you want to place them again, you should redo so after each call to <code>d.run()</code>. You cannot set breakpoints before calling <code>d.run()</code>.</li> </ul>","boost":4},{"location":"basics/running_an_executable/#process-io","title":"Process I/O","text":"<p>When execution is resumed, chances are that your process will need to take input and produce output. To interact with the standard input and output of the process, you can use the PipeManager returned by the <code>run()</code> function.</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\npipe = d.run()\n\nd.cont()\nprint(pipe.recvline().decode())\nd.wait()\n</code></pre> <p>All pipe receive-like methods have a timeout parameter that you can set. The default value, <code>timeout_default</code>, can be set globally as a parameter of the PipeManager object. By default, this value is set to 2 seconds.</p> <p>Changing the global timeout</p> <pre><code>pipe = d.run()\n\npipe.timeout_default = 10 # (1)\n</code></pre> <ol> <li>This sets the default timeout for all pipe receive-like methods to 10 seconds.</li> </ol> <p>You can interact with the process's pipe manager using the following methods:</p> Method Description <code>recv</code> Receives at most <code>numb</code> bytes from the target's stdout.Parameters:- <code>numb</code> (int) \u00a0\u00a0\u00a0 [default = 4096]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default] <code>recverr</code> Receives at most <code>numb</code> bytes from the target's stderr.Parameters:- <code>numb</code> (int) \u00a0\u00a0\u00a0 [default = 4096]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default] <code>recvuntil</code> Receives data from stdout until a specified delimiter is encountered for a certain number of occurrences.Parameters:- <code>delims</code> (bytes)- <code>occurrences</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = False]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>recverruntil</code> Receives data from stderr until a specified delimiter is encountered for a certain number of occurrences.Parameters:- <code>delims</code> (bytes)- <code>occurrences</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = False]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>recvline</code> Receives <code>numlines</code> lines from the target's stdout.Parameters:- <code>numlines</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = True]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>recverrline</code> Receives <code>numlines</code> lines from the target's stderr.Parameters:- <code>numlines</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = True]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>send</code> Sends <code>data</code> to the target's stdin.Parameters:- <code>data</code> (bytes) <code>sendafter</code> Sends <code>data</code> after receiving a specified number of occurrences of a delimiter from stdout.Parameters:- <code>delims</code> (bytes)- <code>data</code> (bytes)- <code>occurrences</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = False]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>sendline</code> Sends <code>data</code> followed by a newline to the target's stdin.Parameters:- <code>data</code> (bytes) <code>sendlineafter</code> Sends a line of <code>data</code> after receiving a specified number of occurrences of a delimiter from stdout.Parameters:- <code>delims</code> (bytes)- <code>data</code> (bytes)- <code>occurrences</code> (int) \u00a0\u00a0\u00a0 [default = 1]- <code>drop</code> (bool) \u00a0\u00a0\u00a0 [default = False]- <code>timeout</code> (int) \u00a0\u00a0\u00a0 [default = timeout_default]- <code>optional</code> (bool) \u00a0\u00a0\u00a0 [default = False] <code>close</code> Closes the connection to the target. <code>interactive</code> Enters interactive mode, allowing manual send/receive operations with the target. Read more in the dedicated section.Parameters:- <code>prompt</code> (str) \u00a0\u00a0\u00a0 [default = \"$ \"]- <code>auto_quit</code> (bool) \u00a0\u00a0\u00a0 [default = False] <p>When process is stopped</p> <p>When the process is stopped, the PipeManager will not be able to receive new (unbuffered) data from the target. For this reason, the API includes a parameter called <code>optional</code>.</p> <p>When set to <code>True</code>, libdebug will not necessarily expect to receive data from the process when it is stopped. When set to <code>False</code>, any recv-like instruction (including <code>sendafter</code> and <code>sendlineafter</code>) will fail with an exception when the process is not running.</p> <p>Operations on stdin like <code>send</code> and <code>sendline</code> are not affected by this limitation, since the kernel will buffer the data until the process is resumed.</p>","boost":4},{"location":"basics/running_an_executable/#interactive-io","title":"Interactive I/O","text":"<p>The PipeManager contains a method called <code>interactive()</code> that allows you to directly interact with the process's standard I/O. This method will print characters from standard output and error and read your inputs, letting you interact naturally with the process. The <code>interactive()</code> method is blocking, so the execution of the script will wait for the user to terminate the interactive session. To quit an interactive session, you can press <code>Ctrl+C</code> or <code>Ctrl+D</code>.</p> <p>Function Signature</p> <pre><code>pipe.interactive(prompt: str = prompt_default, auto_quit: bool = False):\n</code></pre> <p>The <code>prompt</code> parameter sets the line prefix in the terminal (e.g. <code>\"$ \"</code> and <code>\"&gt; \"</code> will produce <code>$ cat flag</code> and <code>&gt; cat flag</code> respectively). By default, it is set to <code>\"$ \"</code>. The <code>auto_quit</code> parameter, when set to <code>True</code>, will automatically quit the interactive session when the process is stopped.</p> <p>If any of the file descriptors of standard input, output, or error are closed, a warning will be printed.</p>","boost":4},{"location":"basics/running_an_executable/#attaching-to-a-running-process","title":"Attaching to a Running Process","text":"<p>If you want to attach to a running process instead of spawning a child, you can use the <code>attach()</code> method in the Debugger object. This method will attach to the process with the specified PID.</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"test\")\n\npid = 1234\n\nd.attach(pid)\n</code></pre> <p>The process will stop upon attachment, waiting for your commands.</p> <p>Ptrace Scope</p> <p>libdebug uses the <code>ptrace</code> system call to interact with the process. For security reasons, this system call is limited by the kernel according to a <code>ptrace_scope</code> parameter. Different systems have different default values for this parameter. If the <code>ptrace</code> system call is not allowed, the <code>attach()</code> method will raise an exception notifying you of this issue.</p>","boost":4},{"location":"basics/supported_systems/","title":"Supported Systems","text":"","boost":4},{"location":"basics/supported_systems/#operating-systems","title":"Operating Systems","text":"<p>Currently, libdebug only supports the  GNU/Linux Operating System.</p>","boost":4},{"location":"basics/supported_systems/#architectures","title":"Architectures","text":"Architecture Alias Support  x86_64 AMD64  Stable  i386 over AMD64 32-bit compatibility mode  Alpha  i386 IA-32  Alpha  ARM 64-bit AArch64  Beta  ARM 32-bit ARM32  Not Supported <p>Forcing a specific architecture</p> <p>If for any reason you need to force libdebug to use a specific architecture (e.g., corrupted ELF), you can do so by setting the <code>arch</code> parameter in the Debugger object. For example, to force the debugger to use the x86_64 architecture, you can use the following code: <pre><code>from libdebug import debugger\n\nd = debugger(\"program\", ...)\n\nd.arch = \"amd64\"\n</code></pre></p>","boost":4},{"location":"blog/","title":"Blogposts","text":""},{"location":"blog/2024/10/13/a-new-documentation/","title":"A New Documentation","text":"<p>Hello, World! Thank for using libdebug. We are proud to roll out our new documentation along with version 0.7.0. This new documentation is powered by MkDocs and Material for MkDocs. We hope you find it more intuitive and easier to navigate.</p> <p>We have expanded the documentation to cover more topics and provide more examples. We also tried to highlight some common difficulties that have been reported. Also, thanks to the mkdocs search plugin, you can more easily find what you are looking for, both in the documentation and pages generated from Pydoc.</p> <p>We hope you enjoy the new documentation. If you find any mistakes or would like to suggest improvements, please let us know by opening an  issue on our GitHub repository.</p>"},{"location":"blog/2024/10/14/see-you-at-acm-ccs-2024/","title":"See you at ACM CCS 2024!","text":"<p>We are excited to announce that we will be presenting a poster on libdebug at the 2024 ACM Conference on Computer and Communications Security (ACM CCS 2024). The conference will be held in Salt Lake City, Utah. The poster session is October 16th at 16:30. We will be presenting the rationale behind libdebug and demonstrating how it can be used in some cool use cases.</p> <p>If you are attending the conference, please stop by our poster and say hello. We would love to meet you and hear about your ideas. We are also looking forward to hearing about your research and how libdebug can help you in your work. Come by and grab some swag!</p> <p>Link to the conference: ACM CCS 2024 Link to the poster information: libdebug Poster</p>"},{"location":"code_examples/example_cc24/","title":"CyberChallenge 2024 - Workshop","text":"<p>This script was used to showcase the power of libdebug during the Workshop at the CyberChallenge.IT 2024 Finals. An explanation of the script, along with a brief introduction to libdebug, is available in the official stream of the event, starting from timestamp 2:17:00.</p> <pre><code>from libdebug import debugger\nfrom string import ascii_letters, digits\n\n# Enable the escape_antidebug option to bypass the ptrace call\nd = debugger(\"main\", escape_antidebug=True)\n\ndef callback(_, __):\n    # This will automatically issue a continue when the breakpoint is hit\n    pass\n\ndef on_enter_nanosleep(t, _):\n    # This sets every argument to NULL to make the syscall fail\n    t.syscall_arg0 = 0\n    t.syscall_arg1 = 0\n    t.syscall_arg2 = 0\n    t.syscall_arg3 = 0\n\nalphabet = ascii_letters + digits + \"_{}\"\n\nflag = b\"\"\nbest_hit_count = 0\n\nwhile True:\n    for c in alphabet:\n        r = d.run()\n\n        # Any time we call run() we have to reset the breakpoint and syscall handler\n        bp = d.breakpoint(0x13e1, hardware=True, callback=callback, file=\"binary\")\n        d.handle_syscall(\"clock_nanosleep\", on_enter=on_enter_nanosleep)\n\n        d.cont()\n\n        r.sendline(flag + c.encode())\n\n        # This makes the debugger wait for the process to terminate\n        d.wait()\n\n        response = r.recvline()\n\n        # `run()` will automatically kill any still-running process, but it's good practice to do it manually\n        d.kill()\n\n        if b\"Yeah\" in response:\n            # The flag is correct\n            flag += c.encode()\n            print(flag)\n            break\n\n        if bp.hit_count &gt; best_hit_count:\n            # We have found a new flag character\n            best_hit_count = bp.hit_count\n            flag += c.encode()\n            print(flag)\n            break\n\n    if c == \"}\":\n        break\n\nprint(flag)\n</code></pre>","boost":0.8},{"location":"code_examples/example_nlinks/","title":"DEF CON Quals 2023 - nlinks","text":"<p>This is a script that solves the challenge nlinks from DEF CON Quals 2023. Please find the binary executables here. <pre><code>def get_passsphrase_from_class_1_binaries(previous_flag):\n    flag = b\"\"\n\n    d = debugger(\"CTF/1\")\n    r = d.run()\n\n    bp = d.breakpoint(0x7EF1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.recvuntil(b\"Passphrase:\\n\")\n\n    # We send a fake flag after the valid password\n    r.send(previous_flag + b\"a\" * 8)\n\n    for _ in range(8):\n        # Here we reached the breakpoint\n        if not bp.hit_on(d):\n            print(\"Here we should have hit the breakpoint\")\n\n        offset = ord(\"a\") ^ d.regs.rbp\n        d.regs.rbp = d.regs.r13\n\n        # We calculate the correct character value and append it to the flag\n        flag += (offset ^ d.regs.r13).to_bytes(1, \"little\")\n\n        d.cont()\n\n    r.recvline()\n\n    d.kill()\n\n    # Here the value of flag is b\"\\x00\\x006\\x00\\x00\\x00(\\x00\"\n    return flag\n\ndef get_passsphrase_from_class_2_binaries(previous_flag):\n    bitmap = {}\n    lastpos = 0\n    flag = b\"\"\n\n    d = debugger(\"CTF/2\")\n    r = d.run()\n\n    bp1 = d.breakpoint(0xD8C1, hardware=True, file=\"binary\")\n    bp2 = d.breakpoint(0x1858, hardware=True, file=\"binary\")\n    bp3 = d.breakpoint(0xDBA1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.recvuntil(b\"Passphrase:\\n\")\n    r.send(previous_flag + b\"a\" * 8)\n\n    while True:\n        if d.regs.rip == bp1.address:\n            # Prepare for the next element in the bitmap\n            lastpos = d.regs.rbp\n            d.regs.rbp = d.regs.r13 + 1\n        elif d.regs.rip == bp2.address:\n            # Update the bitmap\n            bitmap[d.regs.r12 &amp; 0xFF] = lastpos &amp; 0xFF\n        elif d.regs.rip == bp3.address:\n            # Use the bitmap to calculate the expected character\n            d.regs.rbp = d.regs.r13\n            wanted = d.regs.rbp\n            needed = 0\n            for i in range(8):\n                if wanted &amp; (2**i):\n                    needed |= bitmap[2**i]\n            flag += chr(needed).encode()\n\n            if bp3.hit_count == 8:\n                # We have found all the characters\n                d.cont()\n                break\n\n        d.cont()\n\n    d.kill()\n\n    # Here the value of flag is b\"\\x00\\x00\\x00\\x01\\x00\\x00a\\x00\"\n    return flag\n\ndef get_passsphrase_from_class_3_binaries():\n    flag = b\"\"\n\n    d = debugger(\"CTF/0\")\n    r = d.run()\n\n    bp = d.breakpoint(0x91A1, hardware=True, file=\"binary\")\n\n    d.cont()\n\n    r.send(b\"a\" * 8)\n\n    for _ in range(8):\n\n        # Here we reached the breakpoint\n        if not bp.hit_on(d):\n            print(\"Here we should have hit the breakpoint\")\n\n        offset = ord(\"a\") - d.regs.rbp\n        d.regs.rbp = d.regs.r13\n\n        # We calculate the correct character value and append it to the flag\n        flag += chr((d.regs.r13 + offset) % 256).encode(\"latin-1\")\n\n        d.cont()\n\n    r.recvline()\n\n    d.kill()\n\n    # Here the value of flag is b\"BM8\\xd3\\x02\\x00\\x00\\x00\"\n    return flag\n\ndef run_nlinks():\n    flag0 = get_passsphrase_from_class_3_binaries()\n    flag1 = get_passsphrase_from_class_1_binaries(flag0)\n    flag2 = get_passsphrase_from_class_2_binaries(flag1)\n\n    print(flag0, flag1, flag2)\n</code></pre></p>","boost":0.8},{"location":"code_examples/examples_index/","title":"Examples Index","text":"<p>This chapter contains a collection of examples showcasing the power of libdebug in various scenarios. Each example is a script that uses the library to solve a specific challenge or demonstrate a particular feature.</p>","boost":1},{"location":"from_pydoc/generated/libdebug/","title":"libdebug.libdebug","text":""},{"location":"from_pydoc/generated/libdebug/#libdebug.libdebug.debugger","title":"<code>debugger(argv=[], aslr=True, env=None, escape_antidebug=False, continue_to_binary_entrypoint=True, auto_interrupt_on_command=False, fast_memory=False, kill_on_exit=True)</code>","text":"<p>This function is used to create a new <code>Debugger</code> object. It returns a <code>Debugger</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>argv</code> <code>str | list[str]</code> <p>The location of the binary to debug and any arguments to pass to it.</p> <code>[]</code> <code>aslr</code> <code>bool</code> <p>Whether to enable ASLR. Defaults to True.</p> <code>True</code> <code>env</code> <code>dict[str, str]</code> <p>The environment variables to use. Defaults to the same environment of the debugging script.</p> <code>None</code> <code>escape_antidebug</code> <code>bool</code> <p>Whether to automatically attempt to patch antidebugger detectors based on the ptrace syscall.</p> <code>False</code> <code>continue_to_binary_entrypoint</code> <code>bool</code> <p>Whether to automatically continue to the binary entrypoint. Defaults to True.</p> <code>True</code> <code>auto_interrupt_on_command</code> <code>bool</code> <p>Whether to automatically interrupt the process when a command is issued. Defaults to False.</p> <code>False</code> <code>fast_memory</code> <code>bool</code> <p>Whether to use a faster memory reading method. Defaults to False.</p> <code>False</code> <code>kill_on_exit</code> <code>bool</code> <p>Whether to kill the debugged process when the debugger exits. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Debugger</code> <code>Debugger</code> <p>The <code>Debugger</code> object.</p> Source code in <code>libdebug/libdebug.py</code> <pre><code>def debugger(\n    argv: str | list[str] = [],\n    aslr: bool = True,\n    env: dict[str, str] | None = None,\n    escape_antidebug: bool = False,\n    continue_to_binary_entrypoint: bool = True,\n    auto_interrupt_on_command: bool = False,\n    fast_memory: bool = False,\n    kill_on_exit: bool = True,\n) -&gt; Debugger:\n    \"\"\"This function is used to create a new `Debugger` object. It returns a `Debugger` object.\n\n    Args:\n        argv (str | list[str], optional): The location of the binary to debug and any arguments to pass to it.\n        aslr (bool, optional): Whether to enable ASLR. Defaults to True.\n        env (dict[str, str], optional): The environment variables to use. Defaults to the same environment of the debugging script.\n        escape_antidebug (bool): Whether to automatically attempt to patch antidebugger detectors based on the ptrace syscall.\n        continue_to_binary_entrypoint (bool, optional): Whether to automatically continue to the binary entrypoint. Defaults to True.\n        auto_interrupt_on_command (bool, optional): Whether to automatically interrupt the process when a command is issued. Defaults to False.\n        fast_memory (bool, optional): Whether to use a faster memory reading method. Defaults to False.\n        kill_on_exit (bool, optional): Whether to kill the debugged process when the debugger exits. Defaults to True.\n\n    Returns:\n        Debugger: The `Debugger` object.\n    \"\"\"\n    if isinstance(argv, str):\n        argv = [resolve_argv_path(argv)]\n    elif argv:\n        argv[0] = resolve_argv_path(argv[0])\n\n    internal_debugger = InternalDebugger()\n    internal_debugger.argv = argv\n    internal_debugger.env = env\n    internal_debugger.aslr_enabled = aslr\n    internal_debugger.autoreach_entrypoint = continue_to_binary_entrypoint\n    internal_debugger.auto_interrupt_on_command = auto_interrupt_on_command\n    internal_debugger.escape_antidebug = escape_antidebug\n    internal_debugger.fast_memory = fast_memory\n    internal_debugger.kill_on_exit = kill_on_exit\n\n    debugger = Debugger()\n    debugger.post_init_(internal_debugger)\n\n    internal_debugger.debugger = debugger\n\n    # If we are attaching, we assume the architecture is the same as the current platform\n    if argv:\n        debugger.arch = elf_architecture(argv[0])\n\n    return debugger\n</code></pre>"},{"location":"from_pydoc/generated/liblog/","title":"libdebug.liblog","text":""},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog","title":"<code>LibLog</code>","text":"<p>Custom logger singleton class that can be used to log messages to the console.</p> Source code in <code>libdebug/liblog.py</code> <pre><code>class LibLog:\n    \"\"\"Custom logger singleton class that can be used to log messages to the console.\"\"\"\n\n    _instance = None\n\n    def __new__(cls: type):\n        \"\"\"Create a new instance of the class if it does not exist yet.\n\n        Returns:\n            LibLog: the instance of the class.\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self: LibLog) -&gt; None:\n        \"\"\"Initializes the logger.\"\"\"\n        if self._initialized:\n            return\n\n        # Add custom log levels\n        logging.addLevelName(60, \"SILENT\")\n        logging.SILENT = 60\n\n        # General logger\n        self.general_logger = self._setup_logger(\"libdebug\", logging.INFO)\n\n        # Component-specific loggers\n        self.debugger_logger = self._setup_logger(\"debugger\", logging.SILENT)\n        self.pipe_logger = self._setup_logger(\"pipe\", logging.SILENT)\n\n        self._initialized = True\n\n    def _setup_logger(self: LibLog, name: str, level: int) -&gt; logging.Logger:\n        \"\"\"Setup a logger with the given name and level.\n\n        Args:\n            name (str): name of the logger.\n            level (int): logging level.\n\n        Returns:\n            logging.Logger: the logger object.\n        \"\"\"\n        logger = logging.getLogger(name)\n        logger.setLevel(level)\n        handler = logging.StreamHandler()\n        formatter = logging.Formatter(\"%(message)s\")\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n\n        return logger\n\n    def debugger(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log a message to the debugger logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{ANSIColors.RED}DEBUGGER{ANSIColors.DEFAULT_COLOR}]\"\n        self.debugger_logger.debug(f\"{header} {message}\", *args, **kwargs)\n\n    def pipe(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log a message to the pipe logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{ANSIColors.BLUE}PIPE{ANSIColors.DEFAULT_COLOR}]\"\n        self.pipe_logger.debug(f\"{header} {message}\", *args, **kwargs)\n\n    def info(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log a info message to the general logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{ANSIColors.GREEN}INFO{ANSIColors.DEFAULT_COLOR}]\"\n        self.general_logger.info(f\"{header} {message}\", *args, **kwargs)\n\n    def warning(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log a warning message to the general logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{ANSIColors.BRIGHT_YELLOW}WARNING{ANSIColors.DEFAULT_COLOR}]\"\n        self.general_logger.warning(f\"{header} {message}\", *args, **kwargs)\n\n    def error(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n        \"\"\"Log an error message to the general logger.\n\n        Args:\n            message (str): the message to log.\n            *args: positional arguments to pass to the logger.\n            **kwargs: keyword arguments to pass to the logger.\n        \"\"\"\n        header = f\"[{ANSIColors.RED}ERROR{ANSIColors.DEFAULT_COLOR}]\"\n        self.general_logger.error(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the logger.</p> Source code in <code>libdebug/liblog.py</code> <pre><code>def __init__(self: LibLog) -&gt; None:\n    \"\"\"Initializes the logger.\"\"\"\n    if self._initialized:\n        return\n\n    # Add custom log levels\n    logging.addLevelName(60, \"SILENT\")\n    logging.SILENT = 60\n\n    # General logger\n    self.general_logger = self._setup_logger(\"libdebug\", logging.INFO)\n\n    # Component-specific loggers\n    self.debugger_logger = self._setup_logger(\"debugger\", logging.SILENT)\n    self.pipe_logger = self._setup_logger(\"pipe\", logging.SILENT)\n\n    self._initialized = True\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.__new__","title":"<code>__new__()</code>","text":"<p>Create a new instance of the class if it does not exist yet.</p> <p>Returns:</p> Name Type Description <code>LibLog</code> <p>the instance of the class.</p> Source code in <code>libdebug/liblog.py</code> <pre><code>def __new__(cls: type):\n    \"\"\"Create a new instance of the class if it does not exist yet.\n\n    Returns:\n        LibLog: the instance of the class.\n    \"\"\"\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n        cls._instance._initialized = False\n    return cls._instance\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.debugger","title":"<code>debugger(message, *args, **kwargs)</code>","text":"<p>Log a message to the debugger logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def debugger(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log a message to the debugger logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{ANSIColors.RED}DEBUGGER{ANSIColors.DEFAULT_COLOR}]\"\n    self.debugger_logger.debug(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.error","title":"<code>error(message, *args, **kwargs)</code>","text":"<p>Log an error message to the general logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def error(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log an error message to the general logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{ANSIColors.RED}ERROR{ANSIColors.DEFAULT_COLOR}]\"\n    self.general_logger.error(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.info","title":"<code>info(message, *args, **kwargs)</code>","text":"<p>Log a info message to the general logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def info(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log a info message to the general logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{ANSIColors.GREEN}INFO{ANSIColors.DEFAULT_COLOR}]\"\n    self.general_logger.info(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.pipe","title":"<code>pipe(message, *args, **kwargs)</code>","text":"<p>Log a message to the pipe logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def pipe(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log a message to the pipe logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{ANSIColors.BLUE}PIPE{ANSIColors.DEFAULT_COLOR}]\"\n    self.pipe_logger.debug(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/liblog/#libdebug.liblog.LibLog.warning","title":"<code>warning(message, *args, **kwargs)</code>","text":"<p>Log a warning message to the general logger.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>the message to log.</p> required <code>*args</code> <code>str</code> <p>positional arguments to pass to the logger.</p> <code>()</code> <code>**kwargs</code> <code>str</code> <p>keyword arguments to pass to the logger.</p> <code>{}</code> Source code in <code>libdebug/liblog.py</code> <pre><code>def warning(self: LibLog, message: str, *args: str, **kwargs: str) -&gt; None:\n    \"\"\"Log a warning message to the general logger.\n\n    Args:\n        message (str): the message to log.\n        *args: positional arguments to pass to the logger.\n        **kwargs: keyword arguments to pass to the logger.\n    \"\"\"\n    header = f\"[{ANSIColors.BRIGHT_YELLOW}WARNING{ANSIColors.DEFAULT_COLOR}]\"\n    self.general_logger.warning(f\"{header} {message}\", *args, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/breakpoint_validator/","title":"libdebug.architectures.breakpoint_validator","text":""},{"location":"from_pydoc/generated/architectures/breakpoint_validator/#libdebug.architectures.breakpoint_validator.validate_hardware_breakpoint","title":"<code>validate_hardware_breakpoint(arch, bp)</code>","text":"<p>Validate a hardware breakpoint for the specified architecture.</p> Source code in <code>libdebug/architectures/breakpoint_validator.py</code> <pre><code>def validate_hardware_breakpoint(arch: str, bp: Breakpoint) -&gt; None:\n    \"\"\"Validate a hardware breakpoint for the specified architecture.\"\"\"\n    if arch == \"aarch64\":\n        validate_breakpoint_aarch64(bp)\n    elif arch == \"amd64\":\n        validate_breakpoint_amd64(bp)\n    elif arch == \"i386\":\n        validate_breakpoint_i386(bp)\n    else:\n        raise ValueError(f\"Architecture {arch} not supported\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_manager/","title":"libdebug.architectures.call_utilities_manager","text":""},{"location":"from_pydoc/generated/architectures/call_utilities_manager/#libdebug.architectures.call_utilities_manager.CallUtilitiesManager","title":"<code>CallUtilitiesManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An architecture-independent interface for call instruction utilities.</p> Source code in <code>libdebug/architectures/call_utilities_manager.py</code> <pre><code>class CallUtilitiesManager(ABC):\n    \"\"\"An architecture-independent interface for call instruction utilities.\"\"\"\n\n    @abstractmethod\n    def is_call(self: CallUtilitiesManager, opcode_window: bytes) -&gt; bool:\n        \"\"\"Check if the current instruction is a call instruction.\"\"\"\n\n    @abstractmethod\n    def compute_call_skip(self: CallUtilitiesManager, opcode_window: bytes) -&gt; int:\n        \"\"\"Compute the address where to skip after the current call instruction.\"\"\"\n\n    @abstractmethod\n    def get_call_and_skip_amount(self, opcode_window: bytes) -&gt; tuple[bool, int]:\n        \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_manager/#libdebug.architectures.call_utilities_manager.CallUtilitiesManager.compute_call_skip","title":"<code>compute_call_skip(opcode_window)</code>  <code>abstractmethod</code>","text":"<p>Compute the address where to skip after the current call instruction.</p> Source code in <code>libdebug/architectures/call_utilities_manager.py</code> <pre><code>@abstractmethod\ndef compute_call_skip(self: CallUtilitiesManager, opcode_window: bytes) -&gt; int:\n    \"\"\"Compute the address where to skip after the current call instruction.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_manager/#libdebug.architectures.call_utilities_manager.CallUtilitiesManager.get_call_and_skip_amount","title":"<code>get_call_and_skip_amount(opcode_window)</code>  <code>abstractmethod</code>","text":"<p>Check if the current instruction is a call instruction and compute the instruction size.</p> Source code in <code>libdebug/architectures/call_utilities_manager.py</code> <pre><code>@abstractmethod\ndef get_call_and_skip_amount(self, opcode_window: bytes) -&gt; tuple[bool, int]:\n    \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_manager/#libdebug.architectures.call_utilities_manager.CallUtilitiesManager.is_call","title":"<code>is_call(opcode_window)</code>  <code>abstractmethod</code>","text":"<p>Check if the current instruction is a call instruction.</p> Source code in <code>libdebug/architectures/call_utilities_manager.py</code> <pre><code>@abstractmethod\ndef is_call(self: CallUtilitiesManager, opcode_window: bytes) -&gt; bool:\n    \"\"\"Check if the current instruction is a call instruction.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/call_utilities_provider/","title":"libdebug.architectures.call_utilities_provider","text":""},{"location":"from_pydoc/generated/architectures/call_utilities_provider/#libdebug.architectures.call_utilities_provider.call_utilities_provider","title":"<code>call_utilities_provider(architecture)</code>","text":"<p>Returns an instance of the call utilities provider to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/architectures/call_utilities_provider.py</code> <pre><code>def call_utilities_provider(architecture: str) -&gt; CallUtilitiesManager:\n    \"\"\"Returns an instance of the call utilities provider to be used by the `_InternalDebugger` class.\"\"\"\n    match architecture:\n        case \"amd64\":\n            return _amd64_call_utilities\n        case \"aarch64\":\n            return _aarch64_call_utilities\n        case \"i386\":\n            return _i386_call_utilities\n        case _:\n            raise NotImplementedError(f\"Architecture {architecture} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/ptrace_software_breakpoint_patcher/","title":"libdebug.architectures.ptrace_software_breakpoint_patcher","text":""},{"location":"from_pydoc/generated/architectures/ptrace_software_breakpoint_patcher/#libdebug.architectures.ptrace_software_breakpoint_patcher.software_breakpoint_byte_size","title":"<code>software_breakpoint_byte_size(architecture)</code>","text":"<p>Return the size of a software breakpoint instruction.</p> Source code in <code>libdebug/architectures/ptrace_software_breakpoint_patcher.py</code> <pre><code>def software_breakpoint_byte_size(architecture: str) -&gt; int:\n    \"\"\"Return the size of a software breakpoint instruction.\"\"\"\n    match architecture:\n        case \"amd64\" | \"i386\":\n            return 1\n        case \"aarch64\":\n            return 4\n        case _:\n            raise ValueError(f\"Unsupported architecture: {architecture}\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/register_helper/","title":"libdebug.architectures.register_helper","text":""},{"location":"from_pydoc/generated/architectures/register_helper/#libdebug.architectures.register_helper.register_holder_provider","title":"<code>register_holder_provider(architecture, register_file, fp_register_file)</code>","text":"<p>Returns an instance of the register holder to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/architectures/register_helper.py</code> <pre><code>def register_holder_provider(\n    architecture: str,\n    register_file: object,\n    fp_register_file: object,\n) -&gt; RegisterHolder:\n    \"\"\"Returns an instance of the register holder to be used by the `_InternalDebugger` class.\"\"\"\n    match architecture:\n        case \"amd64\":\n            return Amd64PtraceRegisterHolder(register_file, fp_register_file)\n        case \"aarch64\":\n            return Aarch64PtraceRegisterHolder(register_file, fp_register_file)\n        case \"i386\":\n            if libcontext.platform == \"amd64\":\n                return I386OverAMD64PtraceRegisterHolder(register_file, fp_register_file)\n            else:\n                return I386PtraceRegisterHolder(register_file, fp_register_file)\n        case _:\n            raise NotImplementedError(f\"Architecture {architecture} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/stack_unwinding_manager/","title":"libdebug.architectures.stack_unwinding_manager","text":""},{"location":"from_pydoc/generated/architectures/stack_unwinding_manager/#libdebug.architectures.stack_unwinding_manager.StackUnwindingManager","title":"<code>StackUnwindingManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An architecture-independent interface for stack unwinding.</p> Source code in <code>libdebug/architectures/stack_unwinding_manager.py</code> <pre><code>class StackUnwindingManager(ABC):\n    \"\"\"An architecture-independent interface for stack unwinding.\"\"\"\n\n    @abstractmethod\n    def unwind(self: StackUnwindingManager, target: ThreadContext) -&gt; list:\n        \"\"\"Unwind the stack of the target process.\"\"\"\n\n    @abstractmethod\n    def get_return_address(self: StackUnwindingManager, target: ThreadContext, vmaps: list[MemoryMap]) -&gt; int:\n        \"\"\"Get the return address of the current function.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/stack_unwinding_manager/#libdebug.architectures.stack_unwinding_manager.StackUnwindingManager.get_return_address","title":"<code>get_return_address(target, vmaps)</code>  <code>abstractmethod</code>","text":"<p>Get the return address of the current function.</p> Source code in <code>libdebug/architectures/stack_unwinding_manager.py</code> <pre><code>@abstractmethod\ndef get_return_address(self: StackUnwindingManager, target: ThreadContext, vmaps: list[MemoryMap]) -&gt; int:\n    \"\"\"Get the return address of the current function.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/stack_unwinding_manager/#libdebug.architectures.stack_unwinding_manager.StackUnwindingManager.unwind","title":"<code>unwind(target)</code>  <code>abstractmethod</code>","text":"<p>Unwind the stack of the target process.</p> Source code in <code>libdebug/architectures/stack_unwinding_manager.py</code> <pre><code>@abstractmethod\ndef unwind(self: StackUnwindingManager, target: ThreadContext) -&gt; list:\n    \"\"\"Unwind the stack of the target process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/stack_unwinding_provider/","title":"libdebug.architectures.stack_unwinding_provider","text":""},{"location":"from_pydoc/generated/architectures/stack_unwinding_provider/#libdebug.architectures.stack_unwinding_provider.stack_unwinding_provider","title":"<code>stack_unwinding_provider(architecture)</code>","text":"<p>Returns an instance of the stack unwinding provider to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/architectures/stack_unwinding_provider.py</code> <pre><code>def stack_unwinding_provider(architecture: str) -&gt; StackUnwindingManager:\n    \"\"\"Returns an instance of the stack unwinding provider to be used by the `_InternalDebugger` class.\"\"\"\n    match architecture:\n        case \"amd64\":\n            return _amd64_stack_unwinder\n        case \"aarch64\":\n            return _aarch64_stack_unwinder\n        case \"i386\":\n            return _i386_stack_unwinder\n        case _:\n            raise NotImplementedError(f\"Architecture {architecture} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/syscall_hijacker/","title":"libdebug.architectures.syscall_hijacker","text":""},{"location":"from_pydoc/generated/architectures/syscall_hijacker/#libdebug.architectures.syscall_hijacker.SyscallHijacker","title":"<code>SyscallHijacker</code>","text":"<p>Class that provides syscall hijacking for the x86_64 architecture.</p> Source code in <code>libdebug/architectures/syscall_hijacker.py</code> <pre><code>class SyscallHijacker:\n    \"\"\"Class that provides syscall hijacking for the x86_64 architecture.\"\"\"\n\n    # Allowed arguments for the hijacker\n    allowed_args: set[str] = frozenset(\n        {\n            \"syscall_number\",\n            \"syscall_arg0\",\n            \"syscall_arg1\",\n            \"syscall_arg2\",\n            \"syscall_arg3\",\n            \"syscall_arg4\",\n            \"syscall_arg5\",\n        },\n    )\n\n    def create_hijacker(\n        self: SyscallHijacker,\n        new_syscall: int,\n        **kwargs: int,\n    ) -&gt; Callable[[ThreadContext, int], None]:\n        \"\"\"Create a new hijacker for the given syscall.\n\n        Args:\n            new_syscall (int): The new syscall number.\n            **kwargs: The keyword arguments.\n        \"\"\"\n\n        def hijack_on_enter_wrapper(d: ThreadContext, _: int) -&gt; None:\n            \"\"\"Wrapper for the hijack_on_enter method.\"\"\"\n            self._hijack_on_enter(d, new_syscall, **kwargs)\n\n        return hijack_on_enter_wrapper\n\n    def _hijack_on_enter(\n        self: SyscallHijacker,\n        d: ThreadContext,\n        new_syscall: int,\n        **kwargs: int,\n    ) -&gt; None:\n        \"\"\"Hijack the syscall on enter.\n\n        Args:\n            d (ThreadContext): The target ThreadContext.\n            new_syscall (int): The new syscall number.\n            **kwargs: The keyword arguments.\n        \"\"\"\n        d.syscall_number = new_syscall\n        if \"syscall_arg0\" in kwargs:\n            d.syscall_arg0 = kwargs.get(\"syscall_arg0\", False)\n        if \"syscall_arg1\" in kwargs:\n            d.syscall_arg1 = kwargs.get(\"syscall_arg1\", False)\n        if \"syscall_arg2\" in kwargs:\n            d.syscall_arg2 = kwargs.get(\"syscall_arg2\", False)\n        if \"syscall_arg3\" in kwargs:\n            d.syscall_arg3 = kwargs.get(\"syscall_arg3\", False)\n        if \"syscall_arg4\" in kwargs:\n            d.syscall_arg4 = kwargs.get(\"syscall_arg4\", False)\n        if \"syscall_arg5\" in kwargs:\n            d.syscall_arg5 = kwargs.get(\"syscall_arg5\", False)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/syscall_hijacker/#libdebug.architectures.syscall_hijacker.SyscallHijacker.create_hijacker","title":"<code>create_hijacker(new_syscall, **kwargs)</code>","text":"<p>Create a new hijacker for the given syscall.</p> <p>Parameters:</p> Name Type Description Default <code>new_syscall</code> <code>int</code> <p>The new syscall number.</p> required <code>**kwargs</code> <code>int</code> <p>The keyword arguments.</p> <code>{}</code> Source code in <code>libdebug/architectures/syscall_hijacker.py</code> <pre><code>def create_hijacker(\n    self: SyscallHijacker,\n    new_syscall: int,\n    **kwargs: int,\n) -&gt; Callable[[ThreadContext, int], None]:\n    \"\"\"Create a new hijacker for the given syscall.\n\n    Args:\n        new_syscall (int): The new syscall number.\n        **kwargs: The keyword arguments.\n    \"\"\"\n\n    def hijack_on_enter_wrapper(d: ThreadContext, _: int) -&gt; None:\n        \"\"\"Wrapper for the hijack_on_enter method.\"\"\"\n        self._hijack_on_enter(d, new_syscall, **kwargs)\n\n    return hijack_on_enter_wrapper\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_breakpoint_validator/","title":"libdebug.architectures.aarch64.aarch64_breakpoint_validator","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_breakpoint_validator/#libdebug.architectures.aarch64.aarch64_breakpoint_validator.validate_breakpoint_aarch64","title":"<code>validate_breakpoint_aarch64(bp)</code>","text":"<p>Validate a hardware breakpoint for the AARCH64 architecture.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_breakpoint_validator.py</code> <pre><code>def validate_breakpoint_aarch64(bp: Breakpoint) -&gt; None:\n    \"\"\"Validate a hardware breakpoint for the AARCH64 architecture.\"\"\"\n    if bp.condition not in [\"r\", \"w\", \"rw\", \"x\"]:\n        raise ValueError(\"Invalid condition for watchpoints. Supported conditions are 'r', 'w', 'rw', 'x'.\")\n\n    if not (1 &lt;= bp.length &lt;= 8):\n        raise ValueError(\"Invalid length for watchpoints. Supported lengths are between 1 and 8.\")\n\n    if bp.condition != \"x\" and bp.address &amp; 0x7:\n        raise ValueError(\"Watchpoint address must be aligned to 8 bytes on aarch64. This is a kernel limitation.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/","title":"libdebug.architectures.aarch64.aarch64_call_utilities","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/#libdebug.architectures.aarch64.aarch64_call_utilities.Aarch64CallUtilities","title":"<code>Aarch64CallUtilities</code>","text":"<p>               Bases: <code>CallUtilitiesManager</code></p> <p>Class that provides call utilities for the AArch64 architecture.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_call_utilities.py</code> <pre><code>class Aarch64CallUtilities(CallUtilitiesManager):\n    \"\"\"Class that provides call utilities for the AArch64 architecture.\"\"\"\n\n    def is_call(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; bool:\n        \"\"\"Check if the current instruction is a call instruction.\"\"\"\n        # Check for BL instruction\n        if (opcode_window[3] &amp; 0xFC) == 0x94:\n            return True\n\n        # Check for BLR instruction\n        return bool(opcode_window[3] == 214 and opcode_window[2] &amp; 63 == 63)\n\n    def compute_call_skip(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; int:\n        \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n        # Check for BL instruction\n        if self.is_call(opcode_window):\n            return 4\n\n        return 0\n\n    def get_call_and_skip_amount(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; tuple[bool, int]:\n        \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n        skip = self.compute_call_skip(opcode_window)\n        return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/#libdebug.architectures.aarch64.aarch64_call_utilities.Aarch64CallUtilities.compute_call_skip","title":"<code>compute_call_skip(opcode_window)</code>","text":"<p>Compute the instruction size of the current call instruction.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_call_utilities.py</code> <pre><code>def compute_call_skip(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; int:\n    \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n    # Check for BL instruction\n    if self.is_call(opcode_window):\n        return 4\n\n    return 0\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/#libdebug.architectures.aarch64.aarch64_call_utilities.Aarch64CallUtilities.get_call_and_skip_amount","title":"<code>get_call_and_skip_amount(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction and compute the instruction size.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_call_utilities.py</code> <pre><code>def get_call_and_skip_amount(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; tuple[bool, int]:\n    \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n    skip = self.compute_call_skip(opcode_window)\n    return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_call_utilities/#libdebug.architectures.aarch64.aarch64_call_utilities.Aarch64CallUtilities.is_call","title":"<code>is_call(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_call_utilities.py</code> <pre><code>def is_call(self: Aarch64CallUtilities, opcode_window: bytes) -&gt; bool:\n    \"\"\"Check if the current instruction is a call instruction.\"\"\"\n    # Check for BL instruction\n    if (opcode_window[3] &amp; 0xFC) == 0x94:\n        return True\n\n    # Check for BLR instruction\n    return bool(opcode_window[3] == 214 and opcode_window[2] &amp; 63 == 63)\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/","title":"libdebug.architectures.aarch64.aarch64_ptrace_register_holder","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder","title":"<code>Aarch64PtraceRegisterHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PtraceRegisterHolder</code></p> <p>A class that provides views and setters for the register of an aarch64 process.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>@dataclass\nclass Aarch64PtraceRegisterHolder(PtraceRegisterHolder):\n    \"\"\"A class that provides views and setters for the register of an aarch64 process.\"\"\"\n\n    def provide_regs_class(self: Aarch64PtraceRegisterHolder) -&gt; type:\n        \"\"\"Provide a class to hold the register accessors.\"\"\"\n        return Aarch64Registers\n\n    def provide_regs(self: Aarch64PtraceRegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of registers, excluding the vector and fp registers.\"\"\"\n        return AARCH64_REGS\n\n    def provide_vector_fp_regs(self: Aarch64PtraceRegisterHolder) -&gt; list[tuple[str]]:\n        \"\"\"Provide the list of vector and floating point registers.\"\"\"\n        return self._vector_fp_registers\n\n    def provide_special_regs(self: Aarch64PtraceRegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of special registers, which are not intended for general-purpose use.\"\"\"\n        return AARCH64_SPECIAL_REGS\n\n    def apply_on_regs(self: Aarch64PtraceRegisterHolder, target: Aarch64Registers, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the Aarch64Registers class.\"\"\"\n        target.register_file = self.register_file\n        target._fp_register_file = self.fp_register_file\n\n        if hasattr(target_class, \"w0\"):\n            return\n\n        self._vector_fp_registers = []\n\n        for i in range(31):\n            name_64 = f\"x{i}\"\n            name_32 = f\"w{i}\"\n\n            setattr(target_class, name_64, _get_property_64(name_64))\n            setattr(target_class, name_32, _get_property_32(name_64))\n\n        for reg in AARCH64_SPECIAL_REGS:\n            setattr(target_class, reg, _get_property_64(reg))\n\n        # setup the floating point registers\n        for i in range(32):\n            name_v = f\"v{i}\"\n            name_128 = f\"q{i}\"\n            name_64 = f\"d{i}\"\n            name_32 = f\"s{i}\"\n            name_16 = f\"h{i}\"\n            name_8 = f\"b{i}\"\n            setattr(target_class, name_v, _get_property_fp_128(name_v, i))\n            setattr(target_class, name_128, _get_property_fp_128(name_128, i))\n            setattr(target_class, name_64, _get_property_fp_64(name_64, i))\n            setattr(target_class, name_32, _get_property_fp_32(name_32, i))\n            setattr(target_class, name_16, _get_property_fp_16(name_16, i))\n            setattr(target_class, name_8, _get_property_fp_8(name_8, i))\n            self._vector_fp_registers.append((name_v, name_128, name_64, name_32, name_16, name_8))\n\n        # setup special aarch64 registers\n        target_class.pc = _get_property_64(\"pc\")\n        target_class.sp = _get_property_64(\"sp\")\n        target_class.lr = _get_property_64(\"x30\")\n        target_class.fp = _get_property_64(\"x29\")\n        target_class.xzr = _get_property_zr(\"xzr\")\n        target_class.wzr = _get_property_zr(\"wzr\")\n\n        Aarch64PtraceRegisterHolder._vector_fp_registers = self._vector_fp_registers\n\n    def apply_on_thread(self: Aarch64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the thread class.\"\"\"\n        target.register_file = self.register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"instruction_pointer\"):\n            return\n\n        # setup generic \"instruction_pointer\" property\n        target_class.instruction_pointer = _get_property_64(\"pc\")\n\n        # setup generic syscall properties\n        target_class.syscall_return = _get_property_64(\"x0\")\n        target_class.syscall_arg0 = _get_property_64(\"x0\")\n        target_class.syscall_arg1 = _get_property_64(\"x1\")\n        target_class.syscall_arg2 = _get_property_64(\"x2\")\n        target_class.syscall_arg3 = _get_property_64(\"x3\")\n        target_class.syscall_arg4 = _get_property_64(\"x4\")\n        target_class.syscall_arg5 = _get_property_64(\"x5\")\n\n        # syscall number handling is special on aarch64, as the original number is stored in x8\n        # but writing to x8 isn't enough to change the actual called syscall\n        target_class.syscall_number = _get_property_syscall_num()\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.apply_on_regs","title":"<code>apply_on_regs(target, target_class)</code>","text":"<p>Apply the register accessors to the Aarch64Registers class.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def apply_on_regs(self: Aarch64PtraceRegisterHolder, target: Aarch64Registers, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the Aarch64Registers class.\"\"\"\n    target.register_file = self.register_file\n    target._fp_register_file = self.fp_register_file\n\n    if hasattr(target_class, \"w0\"):\n        return\n\n    self._vector_fp_registers = []\n\n    for i in range(31):\n        name_64 = f\"x{i}\"\n        name_32 = f\"w{i}\"\n\n        setattr(target_class, name_64, _get_property_64(name_64))\n        setattr(target_class, name_32, _get_property_32(name_64))\n\n    for reg in AARCH64_SPECIAL_REGS:\n        setattr(target_class, reg, _get_property_64(reg))\n\n    # setup the floating point registers\n    for i in range(32):\n        name_v = f\"v{i}\"\n        name_128 = f\"q{i}\"\n        name_64 = f\"d{i}\"\n        name_32 = f\"s{i}\"\n        name_16 = f\"h{i}\"\n        name_8 = f\"b{i}\"\n        setattr(target_class, name_v, _get_property_fp_128(name_v, i))\n        setattr(target_class, name_128, _get_property_fp_128(name_128, i))\n        setattr(target_class, name_64, _get_property_fp_64(name_64, i))\n        setattr(target_class, name_32, _get_property_fp_32(name_32, i))\n        setattr(target_class, name_16, _get_property_fp_16(name_16, i))\n        setattr(target_class, name_8, _get_property_fp_8(name_8, i))\n        self._vector_fp_registers.append((name_v, name_128, name_64, name_32, name_16, name_8))\n\n    # setup special aarch64 registers\n    target_class.pc = _get_property_64(\"pc\")\n    target_class.sp = _get_property_64(\"sp\")\n    target_class.lr = _get_property_64(\"x30\")\n    target_class.fp = _get_property_64(\"x29\")\n    target_class.xzr = _get_property_zr(\"xzr\")\n    target_class.wzr = _get_property_zr(\"wzr\")\n\n    Aarch64PtraceRegisterHolder._vector_fp_registers = self._vector_fp_registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.apply_on_thread","title":"<code>apply_on_thread(target, target_class)</code>","text":"<p>Apply the register accessors to the thread class.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def apply_on_thread(self: Aarch64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the thread class.\"\"\"\n    target.register_file = self.register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"instruction_pointer\"):\n        return\n\n    # setup generic \"instruction_pointer\" property\n    target_class.instruction_pointer = _get_property_64(\"pc\")\n\n    # setup generic syscall properties\n    target_class.syscall_return = _get_property_64(\"x0\")\n    target_class.syscall_arg0 = _get_property_64(\"x0\")\n    target_class.syscall_arg1 = _get_property_64(\"x1\")\n    target_class.syscall_arg2 = _get_property_64(\"x2\")\n    target_class.syscall_arg3 = _get_property_64(\"x3\")\n    target_class.syscall_arg4 = _get_property_64(\"x4\")\n    target_class.syscall_arg5 = _get_property_64(\"x5\")\n\n    # syscall number handling is special on aarch64, as the original number is stored in x8\n    # but writing to x8 isn't enough to change the actual called syscall\n    target_class.syscall_number = _get_property_syscall_num()\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.provide_regs","title":"<code>provide_regs()</code>","text":"<p>Provide the list of registers, excluding the vector and fp registers.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def provide_regs(self: Aarch64PtraceRegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of registers, excluding the vector and fp registers.\"\"\"\n    return AARCH64_REGS\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.provide_regs_class","title":"<code>provide_regs_class()</code>","text":"<p>Provide a class to hold the register accessors.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def provide_regs_class(self: Aarch64PtraceRegisterHolder) -&gt; type:\n    \"\"\"Provide a class to hold the register accessors.\"\"\"\n    return Aarch64Registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.provide_special_regs","title":"<code>provide_special_regs()</code>","text":"<p>Provide the list of special registers, which are not intended for general-purpose use.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def provide_special_regs(self: Aarch64PtraceRegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of special registers, which are not intended for general-purpose use.\"\"\"\n    return AARCH64_SPECIAL_REGS\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_ptrace_register_holder/#libdebug.architectures.aarch64.aarch64_ptrace_register_holder.Aarch64PtraceRegisterHolder.provide_vector_fp_regs","title":"<code>provide_vector_fp_regs()</code>","text":"<p>Provide the list of vector and floating point registers.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_ptrace_register_holder.py</code> <pre><code>def provide_vector_fp_regs(self: Aarch64PtraceRegisterHolder) -&gt; list[tuple[str]]:\n    \"\"\"Provide the list of vector and floating point registers.\"\"\"\n    return self._vector_fp_registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_registers/","title":"libdebug.architectures.aarch64.aarch64_registers","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_registers/#libdebug.architectures.aarch64.aarch64_registers.Aarch64Registers","title":"<code>Aarch64Registers</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Registers</code></p> <p>This class holds the state of the architectural-dependent registers of a process.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_registers.py</code> <pre><code>class Aarch64Registers(Registers):\n    \"\"\"This class holds the state of the architectural-dependent registers of a process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_stack_unwinder/","title":"libdebug.architectures.aarch64.aarch64_stack_unwinder","text":""},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_stack_unwinder/#libdebug.architectures.aarch64.aarch64_stack_unwinder.Aarch64StackUnwinder","title":"<code>Aarch64StackUnwinder</code>","text":"<p>               Bases: <code>StackUnwindingManager</code></p> <p>Class that provides stack unwinding for the AArch64 architecture.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_stack_unwinder.py</code> <pre><code>class Aarch64StackUnwinder(StackUnwindingManager):\n    \"\"\"Class that provides stack unwinding for the AArch64 architecture.\"\"\"\n\n    def unwind(self: Aarch64StackUnwinder, target: ThreadContext) -&gt; list:\n        \"\"\"Unwind the stack of a process.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n\n        Returns:\n            list: A list of return addresses.\n        \"\"\"\n        assert hasattr(target.regs, \"pc\")\n\n        frame_pointer = target.regs.x29\n\n        vmaps = target._internal_debugger.debugging_interface.get_maps()\n        initial_link_register = None\n\n        try:\n            initial_link_register = self.get_return_address(target, vmaps)\n        except ValueError:\n            liblog.warning(\n                \"Failed to get the return address. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n            )\n\n        stack_trace = [target.regs.pc, initial_link_register] if initial_link_register else [target.regs.pc]\n\n        # Follow the frame chain\n        while frame_pointer:\n            try:\n                link_register = int.from_bytes(target.memory[frame_pointer + 8, 8, \"absolute\"], sys.byteorder)\n                frame_pointer = int.from_bytes(target.memory[frame_pointer, 8, \"absolute\"], sys.byteorder)\n\n                if not vmaps.filter(link_register):\n                    break\n\n                # Leaf functions don't set the previous stack frame pointer\n                # But they set the link register to the return address\n                # Non-leaf functions set both\n                if initial_link_register and link_register == initial_link_register:\n                    initial_link_register = None\n                    continue\n\n                stack_trace.append(link_register)\n            except (OSError, ValueError):\n                break\n\n        return stack_trace\n\n    def get_return_address(\n        self: Aarch64StackUnwinder,\n        target: ThreadContext,\n        vmaps: MemoryMapList[MemoryMap],\n    ) -&gt; int:\n        \"\"\"Get the return address of the current function.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n            vmaps (MemoryMapList[MemoryMap]): The memory maps of the process.\n\n        Returns:\n            int: The return address.\n        \"\"\"\n        return_address = target.regs.x30\n\n        if not vmaps.filter(return_address):\n            raise ValueError(\"Return address not in any valid memory map\")\n\n        return return_address\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_stack_unwinder/#libdebug.architectures.aarch64.aarch64_stack_unwinder.Aarch64StackUnwinder.get_return_address","title":"<code>get_return_address(target, vmaps)</code>","text":"<p>Get the return address of the current function.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <code>vmaps</code> <code>MemoryMapList[MemoryMap]</code> <p>The memory maps of the process.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The return address.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_stack_unwinder.py</code> <pre><code>def get_return_address(\n    self: Aarch64StackUnwinder,\n    target: ThreadContext,\n    vmaps: MemoryMapList[MemoryMap],\n) -&gt; int:\n    \"\"\"Get the return address of the current function.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n        vmaps (MemoryMapList[MemoryMap]): The memory maps of the process.\n\n    Returns:\n        int: The return address.\n    \"\"\"\n    return_address = target.regs.x30\n\n    if not vmaps.filter(return_address):\n        raise ValueError(\"Return address not in any valid memory map\")\n\n    return return_address\n</code></pre>"},{"location":"from_pydoc/generated/architectures/aarch64/aarch64_stack_unwinder/#libdebug.architectures.aarch64.aarch64_stack_unwinder.Aarch64StackUnwinder.unwind","title":"<code>unwind(target)</code>","text":"<p>Unwind the stack of a process.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of return addresses.</p> Source code in <code>libdebug/architectures/aarch64/aarch64_stack_unwinder.py</code> <pre><code>def unwind(self: Aarch64StackUnwinder, target: ThreadContext) -&gt; list:\n    \"\"\"Unwind the stack of a process.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n\n    Returns:\n        list: A list of return addresses.\n    \"\"\"\n    assert hasattr(target.regs, \"pc\")\n\n    frame_pointer = target.regs.x29\n\n    vmaps = target._internal_debugger.debugging_interface.get_maps()\n    initial_link_register = None\n\n    try:\n        initial_link_register = self.get_return_address(target, vmaps)\n    except ValueError:\n        liblog.warning(\n            \"Failed to get the return address. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n        )\n\n    stack_trace = [target.regs.pc, initial_link_register] if initial_link_register else [target.regs.pc]\n\n    # Follow the frame chain\n    while frame_pointer:\n        try:\n            link_register = int.from_bytes(target.memory[frame_pointer + 8, 8, \"absolute\"], sys.byteorder)\n            frame_pointer = int.from_bytes(target.memory[frame_pointer, 8, \"absolute\"], sys.byteorder)\n\n            if not vmaps.filter(link_register):\n                break\n\n            # Leaf functions don't set the previous stack frame pointer\n            # But they set the link register to the return address\n            # Non-leaf functions set both\n            if initial_link_register and link_register == initial_link_register:\n                initial_link_register = None\n                continue\n\n            stack_trace.append(link_register)\n        except (OSError, ValueError):\n            break\n\n    return stack_trace\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_breakpoint_validator/","title":"libdebug.architectures.amd64.amd64_breakpoint_validator","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_breakpoint_validator/#libdebug.architectures.amd64.amd64_breakpoint_validator.validate_breakpoint_amd64","title":"<code>validate_breakpoint_amd64(bp)</code>","text":"<p>Validate a hardware breakpoint for the AMD64 architecture.</p> Source code in <code>libdebug/architectures/amd64/amd64_breakpoint_validator.py</code> <pre><code>def validate_breakpoint_amd64(bp: Breakpoint) -&gt; None:\n    \"\"\"Validate a hardware breakpoint for the AMD64 architecture.\"\"\"\n    if bp.condition not in [\"w\", \"rw\", \"x\"]:\n        raise ValueError(\"Invalid condition for watchpoints. Supported conditions are 'w', 'rw', 'x'.\")\n\n    if bp.length not in [1, 2, 4, 8]:\n        raise ValueError(\"Invalid length for watchpoints. Supported lengths are 1, 2, 4, 8.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/","title":"libdebug.architectures.amd64.amd64_call_utilities","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/#libdebug.architectures.amd64.amd64_call_utilities.Amd64CallUtilities","title":"<code>Amd64CallUtilities</code>","text":"<p>               Bases: <code>CallUtilitiesManager</code></p> <p>Class that provides call utilities for the x86_64 architecture.</p> Source code in <code>libdebug/architectures/amd64/amd64_call_utilities.py</code> <pre><code>class Amd64CallUtilities(CallUtilitiesManager):\n    \"\"\"Class that provides call utilities for the x86_64 architecture.\"\"\"\n\n    def is_call(self, opcode_window: bytes) -&gt; bool:\n        \"\"\"Check if the current instruction is a call instruction.\"\"\"\n        # Check for direct CALL (E8 xx xx xx xx)\n        if opcode_window[0] == 0xE8:\n            return True\n\n        # Check for indirect CALL using ModR/M (FF /2)\n        if opcode_window[0] == 0xFF:\n            # Extract ModR/M byte\n            modRM = opcode_window[1]\n            reg = (modRM &gt;&gt; 3) &amp; 0x07  # Middle three bits\n\n            if reg == 2:\n                return True\n\n        return False\n\n    def compute_call_skip(self, opcode_window: bytes) -&gt; int:\n        \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n        # Check for direct CALL (E8 xx xx xx xx)\n        if opcode_window[0] == 0xE8:\n            return 5  # Direct CALL\n\n        # Check for indirect CALL using ModR/M (FF /2)\n        if opcode_window[0] == 0xFF:\n            # Extract ModR/M byte\n            modRM = opcode_window[1]\n            mod = (modRM &gt;&gt; 6) &amp; 0x03  # First two bits\n            reg = (modRM &gt;&gt; 3) &amp; 0x07  # Next three bits\n\n            # Check if reg field is 010 (indirect CALL)\n            if reg == 2:\n                if mod == 0:\n                    if (modRM &amp; 0x07) == 4:\n                        return 3 + (4 if opcode_window[2] == 0x25 else 0)  # SIB byte + optional disp32\n                    elif (modRM &amp; 0x07) == 5:\n                        return 6  # disp32\n                    return 2  # No displacement\n                elif mod == 1:\n                    return 3  # disp8\n                elif mod == 2:\n                    return 6  # disp32\n                elif mod == 3:\n                    return 2  # Register direct\n\n        return 0  # Not a CALL\n\n    def get_call_and_skip_amount(self, opcode_window: bytes) -&gt; tuple[bool, int]:\n        \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n        skip = self.compute_call_skip(opcode_window)\n        return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/#libdebug.architectures.amd64.amd64_call_utilities.Amd64CallUtilities.compute_call_skip","title":"<code>compute_call_skip(opcode_window)</code>","text":"<p>Compute the instruction size of the current call instruction.</p> Source code in <code>libdebug/architectures/amd64/amd64_call_utilities.py</code> <pre><code>def compute_call_skip(self, opcode_window: bytes) -&gt; int:\n    \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n    # Check for direct CALL (E8 xx xx xx xx)\n    if opcode_window[0] == 0xE8:\n        return 5  # Direct CALL\n\n    # Check for indirect CALL using ModR/M (FF /2)\n    if opcode_window[0] == 0xFF:\n        # Extract ModR/M byte\n        modRM = opcode_window[1]\n        mod = (modRM &gt;&gt; 6) &amp; 0x03  # First two bits\n        reg = (modRM &gt;&gt; 3) &amp; 0x07  # Next three bits\n\n        # Check if reg field is 010 (indirect CALL)\n        if reg == 2:\n            if mod == 0:\n                if (modRM &amp; 0x07) == 4:\n                    return 3 + (4 if opcode_window[2] == 0x25 else 0)  # SIB byte + optional disp32\n                elif (modRM &amp; 0x07) == 5:\n                    return 6  # disp32\n                return 2  # No displacement\n            elif mod == 1:\n                return 3  # disp8\n            elif mod == 2:\n                return 6  # disp32\n            elif mod == 3:\n                return 2  # Register direct\n\n    return 0  # Not a CALL\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/#libdebug.architectures.amd64.amd64_call_utilities.Amd64CallUtilities.get_call_and_skip_amount","title":"<code>get_call_and_skip_amount(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction and compute the instruction size.</p> Source code in <code>libdebug/architectures/amd64/amd64_call_utilities.py</code> <pre><code>def get_call_and_skip_amount(self, opcode_window: bytes) -&gt; tuple[bool, int]:\n    \"\"\"Check if the current instruction is a call instruction and compute the instruction size.\"\"\"\n    skip = self.compute_call_skip(opcode_window)\n    return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_call_utilities/#libdebug.architectures.amd64.amd64_call_utilities.Amd64CallUtilities.is_call","title":"<code>is_call(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction.</p> Source code in <code>libdebug/architectures/amd64/amd64_call_utilities.py</code> <pre><code>def is_call(self, opcode_window: bytes) -&gt; bool:\n    \"\"\"Check if the current instruction is a call instruction.\"\"\"\n    # Check for direct CALL (E8 xx xx xx xx)\n    if opcode_window[0] == 0xE8:\n        return True\n\n    # Check for indirect CALL using ModR/M (FF /2)\n    if opcode_window[0] == 0xFF:\n        # Extract ModR/M byte\n        modRM = opcode_window[1]\n        reg = (modRM &gt;&gt; 3) &amp; 0x07  # Middle three bits\n\n        if reg == 2:\n            return True\n\n    return False\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/","title":"libdebug.architectures.amd64.amd64_ptrace_register_holder","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder","title":"<code>Amd64PtraceRegisterHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PtraceRegisterHolder</code></p> <p>A class that provides views and setters for the registers of an x86_64 process.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>@dataclass\nclass Amd64PtraceRegisterHolder(PtraceRegisterHolder):\n    \"\"\"A class that provides views and setters for the registers of an x86_64 process.\"\"\"\n\n    def provide_regs_class(self: Amd64PtraceRegisterHolder) -&gt; type:\n        \"\"\"Provide a class to hold the register accessors.\"\"\"\n        return Amd64Registers\n\n    def provide_regs(self: Amd64PtraceRegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of registers, excluding the vector and fp registers.\"\"\"\n        return AMD64_REGS\n\n    def provide_vector_fp_regs(self: Amd64PtraceRegisterHolder) -&gt; list[tuple[str]]:\n        \"\"\"Provide the list of vector and floating point registers.\"\"\"\n        return self._vector_fp_registers\n\n    def provide_special_regs(self: Amd64PtraceRegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of special registers, which are not intended for general-purpose use.\"\"\"\n        return AMD64_SPECIAL_REGS\n\n    def apply_on_regs(self: Amd64PtraceRegisterHolder, target: Amd64Registers, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the Amd64Registers class.\"\"\"\n        target.register_file = self.register_file\n        target._fp_register_file = self.fp_register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"rip\"):\n            return\n\n        self._vector_fp_registers = []\n\n        # setup accessors\n        for name in AMD64_GP_REGS:\n            name_64 = \"r\" + name + \"x\"\n            name_32 = \"e\" + name + \"x\"\n            name_16 = name + \"x\"\n            name_8l = name + \"l\"\n            name_8h = name + \"h\"\n\n            setattr(target_class, name_64, _get_property_64(name_64))\n            setattr(target_class, name_32, _get_property_32(name_64))\n            setattr(target_class, name_16, _get_property_16(name_64))\n            setattr(target_class, name_8l, _get_property_8l(name_64))\n            setattr(target_class, name_8h, _get_property_8h(name_64))\n\n        for name in AMD64_BASE_REGS:\n            name_64 = \"r\" + name\n            name_32 = \"e\" + name\n            name_16 = name\n            name_8l = name + \"l\"\n\n            setattr(target_class, name_64, _get_property_64(name_64))\n            setattr(target_class, name_32, _get_property_32(name_64))\n            setattr(target_class, name_16, _get_property_16(name_64))\n            setattr(target_class, name_8l, _get_property_8l(name_64))\n\n        for name in AMD64_EXT_REGS:\n            name_64 = name\n            name_32 = name + \"d\"\n            name_16 = name + \"w\"\n            name_8l = name + \"b\"\n\n            setattr(target_class, name_64, _get_property_64(name_64))\n            setattr(target_class, name_32, _get_property_32(name_64))\n            setattr(target_class, name_16, _get_property_16(name_64))\n            setattr(target_class, name_8l, _get_property_8l(name_64))\n\n        for name in AMD64_SPECIAL_REGS:\n            setattr(target_class, name, _get_property_64(name))\n\n        # setup special registers\n        target_class.rip = _get_property_64(\"rip\")\n\n        # setup floating-point registers\n        # see libdebug/cffi/ptrace_cffi_build.py for the possible values of fp_register_file.type\n        self._handle_fp_legacy(target_class)\n\n        match self.fp_register_file.type:\n            case 0:\n                self._handle_vector_512(target_class)\n            case 1:\n                self._handle_vector_896(target_class)\n            case 2:\n                self._handle_vector_2696(target_class)\n            case _:\n                raise NotImplementedError(\n                    f\"Floating-point register file type {self.fp_register_file.type} not available.\",\n                )\n\n        Amd64PtraceRegisterHolder._vector_fp_registers = self._vector_fp_registers\n\n    def apply_on_thread(self: Amd64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the thread class.\"\"\"\n        target.register_file = self.register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"instruction_pointer\"):\n            return\n\n        # setup generic \"instruction_pointer\" property\n        target_class.instruction_pointer = _get_property_64(\"rip\")\n\n        # setup generic syscall properties\n        target_class.syscall_number = _get_property_64(\"orig_rax\")\n        target_class.syscall_return = _get_property_64(\"rax\")\n        target_class.syscall_arg0 = _get_property_64(\"rdi\")\n        target_class.syscall_arg1 = _get_property_64(\"rsi\")\n        target_class.syscall_arg2 = _get_property_64(\"rdx\")\n        target_class.syscall_arg3 = _get_property_64(\"r10\")\n        target_class.syscall_arg4 = _get_property_64(\"r8\")\n        target_class.syscall_arg5 = _get_property_64(\"r9\")\n\n    def _handle_fp_legacy(self: Amd64PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle legacy mmx and st registers.\"\"\"\n        for index in range(8):\n            name_mm = f\"mm{index}\"\n            setattr(target_class, name_mm, _get_property_fp_mmx(name_mm, index))\n\n            name_st = f\"st{index}\"\n            setattr(target_class, name_st, _get_property_fp_st(name_st, index))\n\n            self._vector_fp_registers.append((name_mm, name_st))\n\n    def _handle_vector_512(self: Amd64PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 512 bytes long, which means we just have the xmm registers.\"\"\"\n        for index in range(16):\n            name_xmm = f\"xmm{index}\"\n            setattr(target_class, name_xmm, _get_property_fp_xmm0(name_xmm, index))\n            self._vector_fp_registers.append((name_xmm,))\n\n    def _handle_vector_896(self: Amd64PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 896 bytes long, which means we have the xmm and ymm registers.\"\"\"\n        for index in range(16):\n            name_xmm = f\"xmm{index}\"\n            setattr(target_class, name_xmm, _get_property_fp_xmm0(name_xmm, index))\n\n            name_ymm = f\"ymm{index}\"\n            setattr(target_class, name_ymm, _get_property_fp_ymm0(name_ymm, index))\n\n            self._vector_fp_registers.append((name_xmm, name_ymm))\n\n    def _handle_vector_2696(self: Amd64PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 2696 bytes long, which means we have 32 zmm registers.\"\"\"\n        for index in range(16):\n            name_xmm = f\"xmm{index}\"\n            setattr(target_class, name_xmm, _get_property_fp_xmm0(name_xmm, index))\n\n            name_ymm = f\"ymm{index}\"\n            setattr(target_class, name_ymm, _get_property_fp_ymm0(name_ymm, index))\n\n            name_zmm = f\"zmm{index}\"\n            setattr(target_class, name_zmm, _get_property_fp_zmm0(name_zmm, index))\n\n            self._vector_fp_registers.append((name_xmm, name_ymm, name_zmm))\n\n        for index in range(16):\n            name_xmm = f\"xmm{index + 16}\"\n            setattr(target_class, name_xmm, _get_property_fp_xmm1(name_xmm, index))\n\n            name_ymm = f\"ymm{index + 16}\"\n            setattr(target_class, name_ymm, _get_property_fp_ymm1(name_ymm, index))\n\n            name_zmm = f\"zmm{index + 16}\"\n            setattr(target_class, name_zmm, _get_property_fp_zmm1(name_zmm, index))\n\n            self._vector_fp_registers.append((name_xmm, name_ymm, name_zmm))\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.apply_on_regs","title":"<code>apply_on_regs(target, target_class)</code>","text":"<p>Apply the register accessors to the Amd64Registers class.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def apply_on_regs(self: Amd64PtraceRegisterHolder, target: Amd64Registers, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the Amd64Registers class.\"\"\"\n    target.register_file = self.register_file\n    target._fp_register_file = self.fp_register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"rip\"):\n        return\n\n    self._vector_fp_registers = []\n\n    # setup accessors\n    for name in AMD64_GP_REGS:\n        name_64 = \"r\" + name + \"x\"\n        name_32 = \"e\" + name + \"x\"\n        name_16 = name + \"x\"\n        name_8l = name + \"l\"\n        name_8h = name + \"h\"\n\n        setattr(target_class, name_64, _get_property_64(name_64))\n        setattr(target_class, name_32, _get_property_32(name_64))\n        setattr(target_class, name_16, _get_property_16(name_64))\n        setattr(target_class, name_8l, _get_property_8l(name_64))\n        setattr(target_class, name_8h, _get_property_8h(name_64))\n\n    for name in AMD64_BASE_REGS:\n        name_64 = \"r\" + name\n        name_32 = \"e\" + name\n        name_16 = name\n        name_8l = name + \"l\"\n\n        setattr(target_class, name_64, _get_property_64(name_64))\n        setattr(target_class, name_32, _get_property_32(name_64))\n        setattr(target_class, name_16, _get_property_16(name_64))\n        setattr(target_class, name_8l, _get_property_8l(name_64))\n\n    for name in AMD64_EXT_REGS:\n        name_64 = name\n        name_32 = name + \"d\"\n        name_16 = name + \"w\"\n        name_8l = name + \"b\"\n\n        setattr(target_class, name_64, _get_property_64(name_64))\n        setattr(target_class, name_32, _get_property_32(name_64))\n        setattr(target_class, name_16, _get_property_16(name_64))\n        setattr(target_class, name_8l, _get_property_8l(name_64))\n\n    for name in AMD64_SPECIAL_REGS:\n        setattr(target_class, name, _get_property_64(name))\n\n    # setup special registers\n    target_class.rip = _get_property_64(\"rip\")\n\n    # setup floating-point registers\n    # see libdebug/cffi/ptrace_cffi_build.py for the possible values of fp_register_file.type\n    self._handle_fp_legacy(target_class)\n\n    match self.fp_register_file.type:\n        case 0:\n            self._handle_vector_512(target_class)\n        case 1:\n            self._handle_vector_896(target_class)\n        case 2:\n            self._handle_vector_2696(target_class)\n        case _:\n            raise NotImplementedError(\n                f\"Floating-point register file type {self.fp_register_file.type} not available.\",\n            )\n\n    Amd64PtraceRegisterHolder._vector_fp_registers = self._vector_fp_registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.apply_on_thread","title":"<code>apply_on_thread(target, target_class)</code>","text":"<p>Apply the register accessors to the thread class.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def apply_on_thread(self: Amd64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the thread class.\"\"\"\n    target.register_file = self.register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"instruction_pointer\"):\n        return\n\n    # setup generic \"instruction_pointer\" property\n    target_class.instruction_pointer = _get_property_64(\"rip\")\n\n    # setup generic syscall properties\n    target_class.syscall_number = _get_property_64(\"orig_rax\")\n    target_class.syscall_return = _get_property_64(\"rax\")\n    target_class.syscall_arg0 = _get_property_64(\"rdi\")\n    target_class.syscall_arg1 = _get_property_64(\"rsi\")\n    target_class.syscall_arg2 = _get_property_64(\"rdx\")\n    target_class.syscall_arg3 = _get_property_64(\"r10\")\n    target_class.syscall_arg4 = _get_property_64(\"r8\")\n    target_class.syscall_arg5 = _get_property_64(\"r9\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.provide_regs","title":"<code>provide_regs()</code>","text":"<p>Provide the list of registers, excluding the vector and fp registers.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def provide_regs(self: Amd64PtraceRegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of registers, excluding the vector and fp registers.\"\"\"\n    return AMD64_REGS\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.provide_regs_class","title":"<code>provide_regs_class()</code>","text":"<p>Provide a class to hold the register accessors.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def provide_regs_class(self: Amd64PtraceRegisterHolder) -&gt; type:\n    \"\"\"Provide a class to hold the register accessors.\"\"\"\n    return Amd64Registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.provide_special_regs","title":"<code>provide_special_regs()</code>","text":"<p>Provide the list of special registers, which are not intended for general-purpose use.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def provide_special_regs(self: Amd64PtraceRegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of special registers, which are not intended for general-purpose use.\"\"\"\n    return AMD64_SPECIAL_REGS\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_ptrace_register_holder/#libdebug.architectures.amd64.amd64_ptrace_register_holder.Amd64PtraceRegisterHolder.provide_vector_fp_regs","title":"<code>provide_vector_fp_regs()</code>","text":"<p>Provide the list of vector and floating point registers.</p> Source code in <code>libdebug/architectures/amd64/amd64_ptrace_register_holder.py</code> <pre><code>def provide_vector_fp_regs(self: Amd64PtraceRegisterHolder) -&gt; list[tuple[str]]:\n    \"\"\"Provide the list of vector and floating point registers.\"\"\"\n    return self._vector_fp_registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_registers/","title":"libdebug.architectures.amd64.amd64_registers","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_registers/#libdebug.architectures.amd64.amd64_registers.Amd64Registers","title":"<code>Amd64Registers</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Registers</code></p> <p>This class holds the state of the architectural-dependent registers of a process.</p> Source code in <code>libdebug/architectures/amd64/amd64_registers.py</code> <pre><code>class Amd64Registers(Registers):\n    \"\"\"This class holds the state of the architectural-dependent registers of a process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_stack_unwinder/","title":"libdebug.architectures.amd64.amd64_stack_unwinder","text":""},{"location":"from_pydoc/generated/architectures/amd64/amd64_stack_unwinder/#libdebug.architectures.amd64.amd64_stack_unwinder.Amd64StackUnwinder","title":"<code>Amd64StackUnwinder</code>","text":"<p>               Bases: <code>StackUnwindingManager</code></p> <p>Class that provides stack unwinding for the x86_64 architecture.</p> Source code in <code>libdebug/architectures/amd64/amd64_stack_unwinder.py</code> <pre><code>class Amd64StackUnwinder(StackUnwindingManager):\n    \"\"\"Class that provides stack unwinding for the x86_64 architecture.\"\"\"\n\n    def unwind(self: Amd64StackUnwinder, target: ThreadContext) -&gt; list:\n        \"\"\"Unwind the stack of a process.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n\n        Returns:\n            list: A list of return addresses.\n        \"\"\"\n        assert hasattr(target.regs, \"rip\")\n        assert hasattr(target.regs, \"rbp\")\n\n        current_rbp = target.regs.rbp\n        stack_trace = [target.regs.rip]\n\n        vmaps = target._internal_debugger.debugging_interface.get_maps()\n\n        while current_rbp:\n            try:\n                # Read the return address\n                return_address = int.from_bytes(target.memory[current_rbp + 8, 8, \"absolute\"], sys.byteorder)\n\n                if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n                    break\n\n                # Read the previous rbp and set it as the current one\n                current_rbp = int.from_bytes(target.memory[current_rbp, 8, \"absolute\"], sys.byteorder)\n\n                stack_trace.append(return_address)\n            except (OSError, ValueError):\n                break\n\n        # If we are in the prolouge of a function, we need to get the return address from the stack\n        # using a slightly more complex method\n        try:\n            first_return_address = self.get_return_address(target, vmaps)\n\n            if len(stack_trace) &gt; 1:\n                if first_return_address != stack_trace[1]:\n                    stack_trace.insert(1, first_return_address)\n            else:\n                stack_trace.append(first_return_address)\n        except (OSError, ValueError):\n            liblog.warning(\n                \"Failed to get the return address. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n            )\n\n        return stack_trace\n\n    def get_return_address(self: Amd64StackUnwinder, target: ThreadContext, vmaps: MemoryMapList[MemoryMap]) -&gt; int:\n        \"\"\"Get the return address of the current function.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n            vmaps (MemoryMapList[MemoryMap]): The memory maps of the process.\n\n        Returns:\n            int: The return address.\n        \"\"\"\n        instruction_window = target.memory[target.regs.rip, 4, \"absolute\"]\n\n        # Check if the instruction window is a function preamble and handle each case\n        return_address = None\n\n        if self._preamble_state(instruction_window) == 0:\n            return_address = target.memory[target.regs.rbp + 8, 8, \"absolute\"]\n        elif self._preamble_state(instruction_window) == 1:\n            return_address = target.memory[target.regs.rsp, 8, \"absolute\"]\n        else:\n            return_address = target.memory[target.regs.rsp + 8, 8, \"absolute\"]\n\n        return_address = int.from_bytes(return_address, byteorder=\"little\")\n\n        if not vmaps.filter(return_address):\n            raise ValueError(\"Return address not in memory maps.\")\n\n        return return_address\n\n    def _preamble_state(self: Amd64StackUnwinder, instruction_window: bytes) -&gt; int:\n        \"\"\"Check if the instruction window is a function preamble and if so at what stage.\n\n        Args:\n            instruction_window (bytes): The instruction window.\n\n        Returns:\n            int: 0 if not a preamble, 1 if rbp has not been pushed yet, 2 otherwise\n        \"\"\"\n        preamble_state = 0\n\n        # endbr64 and push rbp\n        if b\"\\xf3\\x0f\\x1e\\xfa\" in instruction_window or b\"\\x55\" in instruction_window:\n            preamble_state = 1\n        # mov rbp, rsp\n        elif b\"\\x48\\x89\\xe5\" in instruction_window:\n            preamble_state = 2\n\n        return preamble_state\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_stack_unwinder/#libdebug.architectures.amd64.amd64_stack_unwinder.Amd64StackUnwinder.get_return_address","title":"<code>get_return_address(target, vmaps)</code>","text":"<p>Get the return address of the current function.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <code>vmaps</code> <code>MemoryMapList[MemoryMap]</code> <p>The memory maps of the process.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The return address.</p> Source code in <code>libdebug/architectures/amd64/amd64_stack_unwinder.py</code> <pre><code>def get_return_address(self: Amd64StackUnwinder, target: ThreadContext, vmaps: MemoryMapList[MemoryMap]) -&gt; int:\n    \"\"\"Get the return address of the current function.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n        vmaps (MemoryMapList[MemoryMap]): The memory maps of the process.\n\n    Returns:\n        int: The return address.\n    \"\"\"\n    instruction_window = target.memory[target.regs.rip, 4, \"absolute\"]\n\n    # Check if the instruction window is a function preamble and handle each case\n    return_address = None\n\n    if self._preamble_state(instruction_window) == 0:\n        return_address = target.memory[target.regs.rbp + 8, 8, \"absolute\"]\n    elif self._preamble_state(instruction_window) == 1:\n        return_address = target.memory[target.regs.rsp, 8, \"absolute\"]\n    else:\n        return_address = target.memory[target.regs.rsp + 8, 8, \"absolute\"]\n\n    return_address = int.from_bytes(return_address, byteorder=\"little\")\n\n    if not vmaps.filter(return_address):\n        raise ValueError(\"Return address not in memory maps.\")\n\n    return return_address\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/amd64_stack_unwinder/#libdebug.architectures.amd64.amd64_stack_unwinder.Amd64StackUnwinder.unwind","title":"<code>unwind(target)</code>","text":"<p>Unwind the stack of a process.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of return addresses.</p> Source code in <code>libdebug/architectures/amd64/amd64_stack_unwinder.py</code> <pre><code>def unwind(self: Amd64StackUnwinder, target: ThreadContext) -&gt; list:\n    \"\"\"Unwind the stack of a process.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n\n    Returns:\n        list: A list of return addresses.\n    \"\"\"\n    assert hasattr(target.regs, \"rip\")\n    assert hasattr(target.regs, \"rbp\")\n\n    current_rbp = target.regs.rbp\n    stack_trace = [target.regs.rip]\n\n    vmaps = target._internal_debugger.debugging_interface.get_maps()\n\n    while current_rbp:\n        try:\n            # Read the return address\n            return_address = int.from_bytes(target.memory[current_rbp + 8, 8, \"absolute\"], sys.byteorder)\n\n            if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n                break\n\n            # Read the previous rbp and set it as the current one\n            current_rbp = int.from_bytes(target.memory[current_rbp, 8, \"absolute\"], sys.byteorder)\n\n            stack_trace.append(return_address)\n        except (OSError, ValueError):\n            break\n\n    # If we are in the prolouge of a function, we need to get the return address from the stack\n    # using a slightly more complex method\n    try:\n        first_return_address = self.get_return_address(target, vmaps)\n\n        if len(stack_trace) &gt; 1:\n            if first_return_address != stack_trace[1]:\n                stack_trace.insert(1, first_return_address)\n        else:\n            stack_trace.append(first_return_address)\n    except (OSError, ValueError):\n        liblog.warning(\n            \"Failed to get the return address. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n        )\n\n    return stack_trace\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder/","title":"libdebug.architectures.amd64.compat.i386_over_amd64_ptrace_register_holder","text":""},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder/#libdebug.architectures.amd64.compat.i386_over_amd64_ptrace_register_holder.I386OverAMD64PtraceRegisterHolder","title":"<code>I386OverAMD64PtraceRegisterHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>I386PtraceRegisterHolder</code></p> <p>A class that provides views and setters for the registers of an x86_64 process.</p> Source code in <code>libdebug/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder.py</code> <pre><code>@dataclass\nclass I386OverAMD64PtraceRegisterHolder(I386PtraceRegisterHolder):\n    \"\"\"A class that provides views and setters for the registers of an x86_64 process.\"\"\"\n\n    def provide_regs_class(self: I386OverAMD64PtraceRegisterHolder) -&gt; type:\n        \"\"\"Provide a class to hold the register accessors.\"\"\"\n        return I386OverAMD64Registers\n\n    def apply_on_regs(\n        self: I386OverAMD64PtraceRegisterHolder,\n        target: I386OverAMD64Registers,\n        target_class: type,\n    ) -&gt; None:\n        \"\"\"Apply the register accessors to the I386Registers class.\"\"\"\n        target.register_file = self.register_file\n        target._fp_register_file = self.fp_register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"eip\"):\n            return\n\n        self._vector_fp_registers = []\n\n        # setup accessors\n        for name in I386_GP_REGS:\n            name_64 = \"r\" + name + \"x\"\n            name_32 = \"e\" + name + \"x\"\n            name_16 = name + \"x\"\n            name_8l = name + \"l\"\n            name_8h = name + \"h\"\n\n            setattr(target_class, name_32, _get_property_32(name_64))\n            setattr(target_class, name_16, _get_property_16(name_64))\n            setattr(target_class, name_8l, _get_property_8l(name_64))\n            setattr(target_class, name_8h, _get_property_8h(name_64))\n\n        for name in I386_BASE_REGS:\n            name_64 = \"r\" + name\n            name_32 = \"e\" + name\n            name_16 = name\n            name_8l = name + \"l\"\n\n            setattr(target_class, name_32, _get_property_32(name_64))\n            setattr(target_class, name_16, _get_property_16(name_64))\n            setattr(target_class, name_8l, _get_property_8l(name_64))\n\n        for name in I386_SPECIAL_REGS:\n            setattr(target_class, name, _get_property_32(name))\n\n        # setup special registers\n        target_class.eip = _get_property_32(\"rip\")\n\n        self._handle_fp_legacy(target_class)\n\n        match self.fp_register_file.type:\n            case 0:\n                self._handle_vector_512(target_class)\n            case 1:\n                self._handle_vector_896(target_class)\n            case 2:\n                self._handle_vector_2696(target_class)\n            case _:\n                raise NotImplementedError(\n                    f\"Floating-point register file type {self.fp_register_file.type} not available.\",\n                )\n\n        I386OverAMD64PtraceRegisterHolder._vector_fp_registers = self._vector_fp_registers\n\n    def apply_on_thread(self: I386OverAMD64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the thread class.\"\"\"\n        target.register_file = self.register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"instruction_pointer\"):\n            return\n\n        # setup generic \"instruction_pointer\" property\n        target_class.instruction_pointer = _get_property_32(\"rip\")\n\n        # setup generic syscall properties\n        target_class.syscall_number = _get_property_32(\"orig_rax\")\n        target_class.syscall_return = _get_property_32(\"rax\")\n        target_class.syscall_arg0 = _get_property_32(\"rbx\")\n        target_class.syscall_arg1 = _get_property_32(\"rcx\")\n        target_class.syscall_arg2 = _get_property_32(\"rdx\")\n        target_class.syscall_arg3 = _get_property_32(\"rsi\")\n        target_class.syscall_arg4 = _get_property_32(\"rdi\")\n        target_class.syscall_arg5 = _get_property_32(\"rbp\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder/#libdebug.architectures.amd64.compat.i386_over_amd64_ptrace_register_holder.I386OverAMD64PtraceRegisterHolder.apply_on_regs","title":"<code>apply_on_regs(target, target_class)</code>","text":"<p>Apply the register accessors to the I386Registers class.</p> Source code in <code>libdebug/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder.py</code> <pre><code>def apply_on_regs(\n    self: I386OverAMD64PtraceRegisterHolder,\n    target: I386OverAMD64Registers,\n    target_class: type,\n) -&gt; None:\n    \"\"\"Apply the register accessors to the I386Registers class.\"\"\"\n    target.register_file = self.register_file\n    target._fp_register_file = self.fp_register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"eip\"):\n        return\n\n    self._vector_fp_registers = []\n\n    # setup accessors\n    for name in I386_GP_REGS:\n        name_64 = \"r\" + name + \"x\"\n        name_32 = \"e\" + name + \"x\"\n        name_16 = name + \"x\"\n        name_8l = name + \"l\"\n        name_8h = name + \"h\"\n\n        setattr(target_class, name_32, _get_property_32(name_64))\n        setattr(target_class, name_16, _get_property_16(name_64))\n        setattr(target_class, name_8l, _get_property_8l(name_64))\n        setattr(target_class, name_8h, _get_property_8h(name_64))\n\n    for name in I386_BASE_REGS:\n        name_64 = \"r\" + name\n        name_32 = \"e\" + name\n        name_16 = name\n        name_8l = name + \"l\"\n\n        setattr(target_class, name_32, _get_property_32(name_64))\n        setattr(target_class, name_16, _get_property_16(name_64))\n        setattr(target_class, name_8l, _get_property_8l(name_64))\n\n    for name in I386_SPECIAL_REGS:\n        setattr(target_class, name, _get_property_32(name))\n\n    # setup special registers\n    target_class.eip = _get_property_32(\"rip\")\n\n    self._handle_fp_legacy(target_class)\n\n    match self.fp_register_file.type:\n        case 0:\n            self._handle_vector_512(target_class)\n        case 1:\n            self._handle_vector_896(target_class)\n        case 2:\n            self._handle_vector_2696(target_class)\n        case _:\n            raise NotImplementedError(\n                f\"Floating-point register file type {self.fp_register_file.type} not available.\",\n            )\n\n    I386OverAMD64PtraceRegisterHolder._vector_fp_registers = self._vector_fp_registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder/#libdebug.architectures.amd64.compat.i386_over_amd64_ptrace_register_holder.I386OverAMD64PtraceRegisterHolder.apply_on_thread","title":"<code>apply_on_thread(target, target_class)</code>","text":"<p>Apply the register accessors to the thread class.</p> Source code in <code>libdebug/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder.py</code> <pre><code>def apply_on_thread(self: I386OverAMD64PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the thread class.\"\"\"\n    target.register_file = self.register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"instruction_pointer\"):\n        return\n\n    # setup generic \"instruction_pointer\" property\n    target_class.instruction_pointer = _get_property_32(\"rip\")\n\n    # setup generic syscall properties\n    target_class.syscall_number = _get_property_32(\"orig_rax\")\n    target_class.syscall_return = _get_property_32(\"rax\")\n    target_class.syscall_arg0 = _get_property_32(\"rbx\")\n    target_class.syscall_arg1 = _get_property_32(\"rcx\")\n    target_class.syscall_arg2 = _get_property_32(\"rdx\")\n    target_class.syscall_arg3 = _get_property_32(\"rsi\")\n    target_class.syscall_arg4 = _get_property_32(\"rdi\")\n    target_class.syscall_arg5 = _get_property_32(\"rbp\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder/#libdebug.architectures.amd64.compat.i386_over_amd64_ptrace_register_holder.I386OverAMD64PtraceRegisterHolder.provide_regs_class","title":"<code>provide_regs_class()</code>","text":"<p>Provide a class to hold the register accessors.</p> Source code in <code>libdebug/architectures/amd64/compat/i386_over_amd64_ptrace_register_holder.py</code> <pre><code>def provide_regs_class(self: I386OverAMD64PtraceRegisterHolder) -&gt; type:\n    \"\"\"Provide a class to hold the register accessors.\"\"\"\n    return I386OverAMD64Registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_registers/","title":"libdebug.architectures.amd64.compat.i386_over_amd64_registers","text":""},{"location":"from_pydoc/generated/architectures/amd64/compat/i386_over_amd64_registers/#libdebug.architectures.amd64.compat.i386_over_amd64_registers.I386OverAMD64Registers","title":"<code>I386OverAMD64Registers</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Registers</code></p> <p>This class holds the state of the architectural-dependent registers of a process.</p> Source code in <code>libdebug/architectures/amd64/compat/i386_over_amd64_registers.py</code> <pre><code>class I386OverAMD64Registers(Registers):\n    \"\"\"This class holds the state of the architectural-dependent registers of a process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_breakpoint_validator/","title":"libdebug.architectures.i386.i386_breakpoint_validator","text":""},{"location":"from_pydoc/generated/architectures/i386/i386_breakpoint_validator/#libdebug.architectures.i386.i386_breakpoint_validator.validate_breakpoint_i386","title":"<code>validate_breakpoint_i386(bp)</code>","text":"<p>Validate a hardware breakpoint for the i386 architecture.</p> Source code in <code>libdebug/architectures/i386/i386_breakpoint_validator.py</code> <pre><code>def validate_breakpoint_i386(bp: Breakpoint) -&gt; None:\n    \"\"\"Validate a hardware breakpoint for the i386 architecture.\"\"\"\n    if bp.condition not in [\"w\", \"rw\", \"x\"]:\n        raise ValueError(\"Invalid condition for watchpoints. Supported conditions are 'w', 'rw', 'x'.\")\n\n    if bp.length not in [1, 2, 4]:\n        raise ValueError(\"Invalid length for watchpoints. Supported lengths are 1, 2, 4.\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_call_utilities/","title":"libdebug.architectures.i386.i386_call_utilities","text":""},{"location":"from_pydoc/generated/architectures/i386/i386_call_utilities/#libdebug.architectures.i386.i386_call_utilities.I386CallUtilities","title":"<code>I386CallUtilities</code>","text":"<p>               Bases: <code>CallUtilitiesManager</code></p> <p>Class that provides call utilities for the i386 architecture.</p> Source code in <code>libdebug/architectures/i386/i386_call_utilities.py</code> <pre><code>class I386CallUtilities(CallUtilitiesManager):\n    \"\"\"Class that provides call utilities for the i386 architecture.\"\"\"\n\n    def is_call(self: I386CallUtilities, opcode_window: bytes) -&gt; bool:\n        \"\"\"Check if the current instruction is a call instruction.\"\"\"\n        # Check for direct CALL (E8 xx xx xx xx)\n        if opcode_window[0] == 0xE8:\n            return True\n\n        # Check for indirect CALL using ModR/M (FF /2)\n        if opcode_window[0] == 0xFF:\n            # Extract ModR/M byte\n            modRM = opcode_window[1]\n            reg = (modRM &gt;&gt; 3) &amp; 0x07\n\n            if reg == 2:\n                return True\n\n        return False\n\n    def compute_call_skip(self: I386CallUtilities, opcode_window: bytes) -&gt; int:\n        \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n        # Check for direct CALL (E8 xx xx xx xx)\n        if opcode_window[0] == 0xE8:\n            return 5\n\n        # Check for indirect CALL using ModR/M (FF /2)\n        if opcode_window[0] == 0xFF:\n            # Extract ModR/M byte\n            modRM = opcode_window[1]\n            mod = (modRM &gt;&gt; 6) &amp; 0x03\n            reg = (modRM &gt;&gt; 3) &amp; 0x07\n\n            if reg == 2:\n                if mod == 0:\n                    if (modRM &amp; 0x07) == 4:\n                        return 3 + (4 if opcode_window[2] == 0x25 else 0)\n                    elif (modRM &amp; 0x07) == 5:\n                        return 6\n                    return 2\n                elif mod == 1:\n                    return 3\n                elif mod == 2:\n                    return 6\n                elif mod == 3:\n                    return 2\n\n        return 0\n\n    def get_call_and_skip_amount(self: I386CallUtilities, opcode_window: bytes) -&gt; tuple[bool, int]:\n        skip = self.compute_call_skip(opcode_window)\n        return skip != 0, skip\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_call_utilities/#libdebug.architectures.i386.i386_call_utilities.I386CallUtilities.compute_call_skip","title":"<code>compute_call_skip(opcode_window)</code>","text":"<p>Compute the instruction size of the current call instruction.</p> Source code in <code>libdebug/architectures/i386/i386_call_utilities.py</code> <pre><code>def compute_call_skip(self: I386CallUtilities, opcode_window: bytes) -&gt; int:\n    \"\"\"Compute the instruction size of the current call instruction.\"\"\"\n    # Check for direct CALL (E8 xx xx xx xx)\n    if opcode_window[0] == 0xE8:\n        return 5\n\n    # Check for indirect CALL using ModR/M (FF /2)\n    if opcode_window[0] == 0xFF:\n        # Extract ModR/M byte\n        modRM = opcode_window[1]\n        mod = (modRM &gt;&gt; 6) &amp; 0x03\n        reg = (modRM &gt;&gt; 3) &amp; 0x07\n\n        if reg == 2:\n            if mod == 0:\n                if (modRM &amp; 0x07) == 4:\n                    return 3 + (4 if opcode_window[2] == 0x25 else 0)\n                elif (modRM &amp; 0x07) == 5:\n                    return 6\n                return 2\n            elif mod == 1:\n                return 3\n            elif mod == 2:\n                return 6\n            elif mod == 3:\n                return 2\n\n    return 0\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_call_utilities/#libdebug.architectures.i386.i386_call_utilities.I386CallUtilities.is_call","title":"<code>is_call(opcode_window)</code>","text":"<p>Check if the current instruction is a call instruction.</p> Source code in <code>libdebug/architectures/i386/i386_call_utilities.py</code> <pre><code>def is_call(self: I386CallUtilities, opcode_window: bytes) -&gt; bool:\n    \"\"\"Check if the current instruction is a call instruction.\"\"\"\n    # Check for direct CALL (E8 xx xx xx xx)\n    if opcode_window[0] == 0xE8:\n        return True\n\n    # Check for indirect CALL using ModR/M (FF /2)\n    if opcode_window[0] == 0xFF:\n        # Extract ModR/M byte\n        modRM = opcode_window[1]\n        reg = (modRM &gt;&gt; 3) &amp; 0x07\n\n        if reg == 2:\n            return True\n\n    return False\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_ptrace_register_holder/","title":"libdebug.architectures.i386.i386_ptrace_register_holder","text":""},{"location":"from_pydoc/generated/architectures/i386/i386_ptrace_register_holder/#libdebug.architectures.i386.i386_ptrace_register_holder.I386PtraceRegisterHolder","title":"<code>I386PtraceRegisterHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>PtraceRegisterHolder</code></p> <p>A class that provides views and setters for the registers of an i386 process.</p> Source code in <code>libdebug/architectures/i386/i386_ptrace_register_holder.py</code> <pre><code>@dataclass\nclass I386PtraceRegisterHolder(PtraceRegisterHolder):\n    \"\"\"A class that provides views and setters for the registers of an i386 process.\"\"\"\n\n    def provide_regs_class(self: I386PtraceRegisterHolder) -&gt; type:\n        \"\"\"Provide a class to hold the register accessors.\"\"\"\n        return I386Registers\n\n    def provide_regs(self: I386PtraceRegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of registers, excluding the vector and fp registers.\"\"\"\n        return I386_REGS\n\n    def provide_vector_fp_regs(self: I386PtraceRegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of vector and floating point registers.\"\"\"\n        return self._vector_fp_registers\n\n    def provide_special_regs(self: I386PtraceRegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of special registers, which are not intended for general-purpose use.\"\"\"\n        return I386_SPECIAL_REGS\n\n    def apply_on_regs(self: I386PtraceRegisterHolder, target: I386Registers, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the I386Registers class.\"\"\"\n        target.register_file = self.register_file\n        target._fp_register_file = self.fp_register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"eip\"):\n            return\n\n        self._vector_fp_registers = []\n\n        # setup accessors\n        for name in I386_GP_REGS:\n            name_32 = \"e\" + name + \"x\"\n            name_16 = name + \"x\"\n            name_8l = name + \"l\"\n            name_8h = name + \"h\"\n\n            setattr(target_class, name_32, _get_property_32(name_32))\n            setattr(target_class, name_16, _get_property_16(name_32))\n            setattr(target_class, name_8l, _get_property_8l(name_32))\n            setattr(target_class, name_8h, _get_property_8h(name_32))\n\n        for name in I386_BASE_REGS:\n            name_32 = \"e\" + name\n            name_16 = name\n            name_8l = name + \"l\"\n\n            setattr(target_class, name_32, _get_property_32(name_32))\n            setattr(target_class, name_16, _get_property_16(name_32))\n            setattr(target_class, name_8l, _get_property_8l(name_32))\n\n        for name in I386_SPECIAL_REGS:\n            setattr(target_class, name, _get_property_32(name))\n\n        # setup special registers\n        target_class.eip = _get_property_32(\"eip\")\n\n        self._handle_fp_legacy(target_class)\n\n        match self.fp_register_file.type:\n            case 0:\n                self._handle_vector_512(target_class)\n            case 1:\n                self._handle_vector_896(target_class)\n            case 2:\n                self._handle_vector_2696(target_class)\n            case _:\n                raise NotImplementedError(\n                    f\"Floating-point register file type {self.fp_register_file.type} not available.\",\n                )\n\n        I386PtraceRegisterHolder._vector_fp_registers = self._vector_fp_registers\n\n    def apply_on_thread(self: I386PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n        \"\"\"Apply the register accessors to the thread class.\"\"\"\n        target.register_file = self.register_file\n\n        # If the accessors are already defined, we don't need to redefine them\n        if hasattr(target_class, \"instruction_pointer\"):\n            return\n\n        # setup generic \"instruction_pointer\" property\n        target_class.instruction_pointer = _get_property_32(\"eip\")\n\n        # setup generic syscall properties\n        target_class.syscall_number = _get_property_32(\"orig_eax\")\n        target_class.syscall_return = _get_property_32(\"eax\")\n        target_class.syscall_arg0 = _get_property_32(\"ebx\")\n        target_class.syscall_arg1 = _get_property_32(\"ecx\")\n        target_class.syscall_arg2 = _get_property_32(\"edx\")\n        target_class.syscall_arg3 = _get_property_32(\"esi\")\n        target_class.syscall_arg4 = _get_property_32(\"edi\")\n        target_class.syscall_arg5 = _get_property_32(\"ebp\")\n\n    def _handle_fp_legacy(self: I386PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle legacy mmx and st registers.\"\"\"\n        for index in range(8):\n            name_mm = f\"mm{index}\"\n            setattr(target_class, name_mm, _get_property_fp_mmx(name_mm, index))\n\n            name_st = f\"st{index}\"\n            setattr(target_class, name_st, _get_property_fp_st(name_st, index))\n\n            self._vector_fp_registers.append((name_mm, name_st))\n\n    def _handle_vector_512(self: I386PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 512 bytes long, which means we just have the xmm registers.\"\"\"\n        # i386 only gets 8 registers\n        for index in range(8):\n            name_xmm = f\"xmm{index}\"\n            setattr(target_class, name_xmm, _get_property_fp_xmm0(name_xmm, index))\n            self._vector_fp_registers.append((name_xmm,))\n\n    def _handle_vector_896(self: I386PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 896 bytes long, which means we have the xmm and ymm registers.\"\"\"\n        # i386 only gets 8 registers\n        for index in range(8):\n            name_xmm = f\"xmm{index}\"\n            setattr(target_class, name_xmm, _get_property_fp_xmm0(name_xmm, index))\n\n            name_ymm = f\"ymm{index}\"\n            setattr(target_class, name_ymm, _get_property_fp_ymm0(name_ymm, index))\n\n            self._vector_fp_registers.append((name_xmm, name_ymm))\n\n    def _handle_vector_2696(self: I386PtraceRegisterHolder, target_class: type) -&gt; None:\n        \"\"\"Handle the case where the xsave area is 2696 bytes long, which means we have 32 zmm registers.\"\"\"\n        # i386 only gets 8 registers\n        for index in range(8):\n            name_xmm = f\"xmm{index}\"\n            setattr(target_class, name_xmm, _get_property_fp_xmm0(name_xmm, index))\n\n            name_ymm = f\"ymm{index}\"\n            setattr(target_class, name_ymm, _get_property_fp_ymm0(name_ymm, index))\n\n            name_zmm = f\"zmm{index}\"\n            setattr(target_class, name_zmm, _get_property_fp_zmm0(name_zmm, index))\n\n            self._vector_fp_registers.append((name_xmm, name_ymm, name_zmm))\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_ptrace_register_holder/#libdebug.architectures.i386.i386_ptrace_register_holder.I386PtraceRegisterHolder.apply_on_regs","title":"<code>apply_on_regs(target, target_class)</code>","text":"<p>Apply the register accessors to the I386Registers class.</p> Source code in <code>libdebug/architectures/i386/i386_ptrace_register_holder.py</code> <pre><code>def apply_on_regs(self: I386PtraceRegisterHolder, target: I386Registers, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the I386Registers class.\"\"\"\n    target.register_file = self.register_file\n    target._fp_register_file = self.fp_register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"eip\"):\n        return\n\n    self._vector_fp_registers = []\n\n    # setup accessors\n    for name in I386_GP_REGS:\n        name_32 = \"e\" + name + \"x\"\n        name_16 = name + \"x\"\n        name_8l = name + \"l\"\n        name_8h = name + \"h\"\n\n        setattr(target_class, name_32, _get_property_32(name_32))\n        setattr(target_class, name_16, _get_property_16(name_32))\n        setattr(target_class, name_8l, _get_property_8l(name_32))\n        setattr(target_class, name_8h, _get_property_8h(name_32))\n\n    for name in I386_BASE_REGS:\n        name_32 = \"e\" + name\n        name_16 = name\n        name_8l = name + \"l\"\n\n        setattr(target_class, name_32, _get_property_32(name_32))\n        setattr(target_class, name_16, _get_property_16(name_32))\n        setattr(target_class, name_8l, _get_property_8l(name_32))\n\n    for name in I386_SPECIAL_REGS:\n        setattr(target_class, name, _get_property_32(name))\n\n    # setup special registers\n    target_class.eip = _get_property_32(\"eip\")\n\n    self._handle_fp_legacy(target_class)\n\n    match self.fp_register_file.type:\n        case 0:\n            self._handle_vector_512(target_class)\n        case 1:\n            self._handle_vector_896(target_class)\n        case 2:\n            self._handle_vector_2696(target_class)\n        case _:\n            raise NotImplementedError(\n                f\"Floating-point register file type {self.fp_register_file.type} not available.\",\n            )\n\n    I386PtraceRegisterHolder._vector_fp_registers = self._vector_fp_registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_ptrace_register_holder/#libdebug.architectures.i386.i386_ptrace_register_holder.I386PtraceRegisterHolder.apply_on_thread","title":"<code>apply_on_thread(target, target_class)</code>","text":"<p>Apply the register accessors to the thread class.</p> Source code in <code>libdebug/architectures/i386/i386_ptrace_register_holder.py</code> <pre><code>def apply_on_thread(self: I386PtraceRegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n    \"\"\"Apply the register accessors to the thread class.\"\"\"\n    target.register_file = self.register_file\n\n    # If the accessors are already defined, we don't need to redefine them\n    if hasattr(target_class, \"instruction_pointer\"):\n        return\n\n    # setup generic \"instruction_pointer\" property\n    target_class.instruction_pointer = _get_property_32(\"eip\")\n\n    # setup generic syscall properties\n    target_class.syscall_number = _get_property_32(\"orig_eax\")\n    target_class.syscall_return = _get_property_32(\"eax\")\n    target_class.syscall_arg0 = _get_property_32(\"ebx\")\n    target_class.syscall_arg1 = _get_property_32(\"ecx\")\n    target_class.syscall_arg2 = _get_property_32(\"edx\")\n    target_class.syscall_arg3 = _get_property_32(\"esi\")\n    target_class.syscall_arg4 = _get_property_32(\"edi\")\n    target_class.syscall_arg5 = _get_property_32(\"ebp\")\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_ptrace_register_holder/#libdebug.architectures.i386.i386_ptrace_register_holder.I386PtraceRegisterHolder.provide_regs","title":"<code>provide_regs()</code>","text":"<p>Provide the list of registers, excluding the vector and fp registers.</p> Source code in <code>libdebug/architectures/i386/i386_ptrace_register_holder.py</code> <pre><code>def provide_regs(self: I386PtraceRegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of registers, excluding the vector and fp registers.\"\"\"\n    return I386_REGS\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_ptrace_register_holder/#libdebug.architectures.i386.i386_ptrace_register_holder.I386PtraceRegisterHolder.provide_regs_class","title":"<code>provide_regs_class()</code>","text":"<p>Provide a class to hold the register accessors.</p> Source code in <code>libdebug/architectures/i386/i386_ptrace_register_holder.py</code> <pre><code>def provide_regs_class(self: I386PtraceRegisterHolder) -&gt; type:\n    \"\"\"Provide a class to hold the register accessors.\"\"\"\n    return I386Registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_ptrace_register_holder/#libdebug.architectures.i386.i386_ptrace_register_holder.I386PtraceRegisterHolder.provide_special_regs","title":"<code>provide_special_regs()</code>","text":"<p>Provide the list of special registers, which are not intended for general-purpose use.</p> Source code in <code>libdebug/architectures/i386/i386_ptrace_register_holder.py</code> <pre><code>def provide_special_regs(self: I386PtraceRegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of special registers, which are not intended for general-purpose use.\"\"\"\n    return I386_SPECIAL_REGS\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_ptrace_register_holder/#libdebug.architectures.i386.i386_ptrace_register_holder.I386PtraceRegisterHolder.provide_vector_fp_regs","title":"<code>provide_vector_fp_regs()</code>","text":"<p>Provide the list of vector and floating point registers.</p> Source code in <code>libdebug/architectures/i386/i386_ptrace_register_holder.py</code> <pre><code>def provide_vector_fp_regs(self: I386PtraceRegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of vector and floating point registers.\"\"\"\n    return self._vector_fp_registers\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_registers/","title":"libdebug.architectures.i386.i386_registers","text":""},{"location":"from_pydoc/generated/architectures/i386/i386_registers/#libdebug.architectures.i386.i386_registers.I386Registers","title":"<code>I386Registers</code>  <code>dataclass</code>","text":"<p>               Bases: <code>Registers</code></p> <p>This class holds the state of the architectural-dependent registers of a process.</p> Source code in <code>libdebug/architectures/i386/i386_registers.py</code> <pre><code>class I386Registers(Registers):\n    \"\"\"This class holds the state of the architectural-dependent registers of a process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_stack_unwinder/","title":"libdebug.architectures.i386.i386_stack_unwinder","text":""},{"location":"from_pydoc/generated/architectures/i386/i386_stack_unwinder/#libdebug.architectures.i386.i386_stack_unwinder.I386StackUnwinder","title":"<code>I386StackUnwinder</code>","text":"<p>               Bases: <code>StackUnwindingManager</code></p> <p>Class that provides stack unwinding for the i386 architecture.</p> Source code in <code>libdebug/architectures/i386/i386_stack_unwinder.py</code> <pre><code>class I386StackUnwinder(StackUnwindingManager):\n    \"\"\"Class that provides stack unwinding for the i386 architecture.\"\"\"\n\n    def unwind(self: I386StackUnwinder, target: ThreadContext) -&gt; list:\n        \"\"\"Unwind the stack of a process.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n\n        Returns:\n            list: A list of return addresses.\n        \"\"\"\n        assert hasattr(target.regs, \"eip\")\n        assert hasattr(target.regs, \"ebp\")\n\n        current_ebp = target.regs.ebp\n        stack_trace = [target.regs.eip]\n\n        vmaps = target._internal_debugger.debugging_interface.get_maps()\n\n        while current_ebp:\n            try:\n                # Read the return address\n                return_address = int.from_bytes(target.memory[current_ebp + 4, 4], byteorder=\"little\")\n\n                if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n                    break\n\n                # Read the previous ebp and set it as the current one\n                current_ebp = int.from_bytes(target.memory[current_ebp, 4], byteorder=\"little\")\n\n                stack_trace.append(return_address)\n            except (OSError, ValueError):\n                break\n\n        # If we are in the prologue of a function, we need to get the return address from the stack\n        # using a slightly more complex method\n        try:\n            first_return_address = self.get_return_address(target, vmaps)\n\n            if len(stack_trace) &gt; 1:\n                if first_return_address != stack_trace[1]:\n                    stack_trace.insert(1, first_return_address)\n            else:\n                stack_trace.append(first_return_address)\n        except (OSError, ValueError):\n            liblog.WARNING(\n                \"Failed to get the return address from the stack. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n            )\n\n        return stack_trace\n\n    def get_return_address(self: I386StackUnwinder, target: ThreadContext, vmaps: MemoryMapList[MemoryMap]) -&gt; int:\n        \"\"\"Get the return address of the current function.\n\n        Args:\n            target (ThreadContext): The target ThreadContext.\n            vmaps (list[MemoryMap]): The memory maps of the process.\n\n        Returns:\n            int: The return address.\n        \"\"\"\n        instruction_window = target.memory[target.regs.eip, 4]\n\n        # Check if the instruction window is a function preamble and handle each case\n        return_address = None\n\n        if self._preamble_state(instruction_window) == 0:\n            return_address = target.memory[target.regs.ebp + 4, 4]\n        elif self._preamble_state(instruction_window) == 1:\n            return_address = target.memory[target.regs.esp, 4]\n        else:\n            return_address = target.memory[target.regs.esp + 4, 4]\n\n        return_address = int.from_bytes(return_address, byteorder=\"little\")\n\n        if not vmaps.filter(return_address):\n            raise ValueError(\"Return address is not in any memory map.\")\n\n        return return_address\n\n    def _preamble_state(self: I386StackUnwinder, instruction_window: bytes) -&gt; int:\n        \"\"\"Check if the instruction window is a function preamble and, if so, at what stage.\n\n        Args:\n            instruction_window (bytes): The instruction window.\n\n        Returns:\n            int: 0 if not a preamble, 1 if ebp has not been pushed yet, 2 otherwise\n        \"\"\"\n        preamble_state = 0\n\n        # push ebp\n        if b\"\\x55\" in instruction_window:\n            preamble_state = 1\n\n        # mov ebp, esp\n        elif b\"\\x89\\xe5\" in instruction_window:\n            preamble_state = 2\n\n        return preamble_state\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_stack_unwinder/#libdebug.architectures.i386.i386_stack_unwinder.I386StackUnwinder.get_return_address","title":"<code>get_return_address(target, vmaps)</code>","text":"<p>Get the return address of the current function.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <code>vmaps</code> <code>list[MemoryMap]</code> <p>The memory maps of the process.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The return address.</p> Source code in <code>libdebug/architectures/i386/i386_stack_unwinder.py</code> <pre><code>def get_return_address(self: I386StackUnwinder, target: ThreadContext, vmaps: MemoryMapList[MemoryMap]) -&gt; int:\n    \"\"\"Get the return address of the current function.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n        vmaps (list[MemoryMap]): The memory maps of the process.\n\n    Returns:\n        int: The return address.\n    \"\"\"\n    instruction_window = target.memory[target.regs.eip, 4]\n\n    # Check if the instruction window is a function preamble and handle each case\n    return_address = None\n\n    if self._preamble_state(instruction_window) == 0:\n        return_address = target.memory[target.regs.ebp + 4, 4]\n    elif self._preamble_state(instruction_window) == 1:\n        return_address = target.memory[target.regs.esp, 4]\n    else:\n        return_address = target.memory[target.regs.esp + 4, 4]\n\n    return_address = int.from_bytes(return_address, byteorder=\"little\")\n\n    if not vmaps.filter(return_address):\n        raise ValueError(\"Return address is not in any memory map.\")\n\n    return return_address\n</code></pre>"},{"location":"from_pydoc/generated/architectures/i386/i386_stack_unwinder/#libdebug.architectures.i386.i386_stack_unwinder.I386StackUnwinder.unwind","title":"<code>unwind(target)</code>","text":"<p>Unwind the stack of a process.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The target ThreadContext.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of return addresses.</p> Source code in <code>libdebug/architectures/i386/i386_stack_unwinder.py</code> <pre><code>def unwind(self: I386StackUnwinder, target: ThreadContext) -&gt; list:\n    \"\"\"Unwind the stack of a process.\n\n    Args:\n        target (ThreadContext): The target ThreadContext.\n\n    Returns:\n        list: A list of return addresses.\n    \"\"\"\n    assert hasattr(target.regs, \"eip\")\n    assert hasattr(target.regs, \"ebp\")\n\n    current_ebp = target.regs.ebp\n    stack_trace = [target.regs.eip]\n\n    vmaps = target._internal_debugger.debugging_interface.get_maps()\n\n    while current_ebp:\n        try:\n            # Read the return address\n            return_address = int.from_bytes(target.memory[current_ebp + 4, 4], byteorder=\"little\")\n\n            if not any(vmap.start &lt;= return_address &lt; vmap.end for vmap in vmaps):\n                break\n\n            # Read the previous ebp and set it as the current one\n            current_ebp = int.from_bytes(target.memory[current_ebp, 4], byteorder=\"little\")\n\n            stack_trace.append(return_address)\n        except (OSError, ValueError):\n            break\n\n    # If we are in the prologue of a function, we need to get the return address from the stack\n    # using a slightly more complex method\n    try:\n        first_return_address = self.get_return_address(target, vmaps)\n\n        if len(stack_trace) &gt; 1:\n            if first_return_address != stack_trace[1]:\n                stack_trace.insert(1, first_return_address)\n        else:\n            stack_trace.append(first_return_address)\n    except (OSError, ValueError):\n        liblog.WARNING(\n            \"Failed to get the return address from the stack. Check stack frame registers (e.g., base pointer). The stack trace may be incomplete.\",\n        )\n\n    return stack_trace\n</code></pre>"},{"location":"from_pydoc/generated/builtin/antidebug_syscall_handler/","title":"libdebug.builtin.antidebug_syscall_handler","text":""},{"location":"from_pydoc/generated/builtin/antidebug_syscall_handler/#libdebug.builtin.antidebug_syscall_handler.on_enter_ptrace","title":"<code>on_enter_ptrace(t, handler)</code>","text":"<p>Callback for ptrace syscall onenter.</p> Source code in <code>libdebug/builtin/antidebug_syscall_handler.py</code> <pre><code>def on_enter_ptrace(t: ThreadContext, handler: SyscallHandler) -&gt; None:\n    \"\"\"Callback for ptrace syscall onenter.\"\"\"\n    handler._command = t.syscall_arg0\n\n    command = Commands(t.syscall_arg0)\n    liblog.debugger(f\"entered ptrace syscall with request: {command.name}\")\n</code></pre>"},{"location":"from_pydoc/generated/builtin/antidebug_syscall_handler/#libdebug.builtin.antidebug_syscall_handler.on_exit_ptrace","title":"<code>on_exit_ptrace(t, handler)</code>","text":"<p>Callback for ptrace syscall onexit.</p> Source code in <code>libdebug/builtin/antidebug_syscall_handler.py</code> <pre><code>def on_exit_ptrace(t: ThreadContext, handler: SyscallHandler) -&gt; None:\n    \"\"\"Callback for ptrace syscall onexit.\"\"\"\n    if handler._command is None:\n        liblog.error(\"ptrace onexit called without corresponding onenter. This should not happen.\")\n        return\n\n    match handler._command:\n        case Commands.PTRACE_TRACEME:\n            if not handler._traceme_called:\n                handler._traceme_called = True\n                t.syscall_return = 0\n        case _:\n            liblog.error(f\"ptrace syscall with request {handler._command} not supported\")\n</code></pre>"},{"location":"from_pydoc/generated/builtin/pretty_print_syscall_handler/","title":"libdebug.builtin.pretty_print_syscall_handler","text":""},{"location":"from_pydoc/generated/builtin/pretty_print_syscall_handler/#libdebug.builtin.pretty_print_syscall_handler.pprint_on_enter","title":"<code>pprint_on_enter(t, syscall_number, **kwargs)</code>","text":"<p>Function that will be called when a syscall is entered in pretty print mode.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ThreadContext</code> <p>the thread context.</p> required <code>syscall_number</code> <code>int</code> <p>the syscall number.</p> required <code>**kwargs</code> <code>bool</code> <p>the keyword arguments.</p> <code>{}</code> Source code in <code>libdebug/builtin/pretty_print_syscall_handler.py</code> <pre><code>def pprint_on_enter(t: ThreadContext, syscall_number: int, **kwargs: int) -&gt; None:\n    \"\"\"Function that will be called when a syscall is entered in pretty print mode.\n\n    Args:\n        t (ThreadContext): the thread context.\n        syscall_number (int): the syscall number.\n        **kwargs (bool): the keyword arguments.\n    \"\"\"\n    syscall_name = resolve_syscall_name(t._internal_debugger.arch, syscall_number)\n    syscall_args = resolve_syscall_arguments(t._internal_debugger.arch, syscall_number)\n\n    values = [\n        t.syscall_arg0,\n        t.syscall_arg1,\n        t.syscall_arg2,\n        t.syscall_arg3,\n        t.syscall_arg4,\n        t.syscall_arg5,\n    ]\n\n    # Print the thread id\n    header = f\"{ANSIColors.BOLD}{t.tid}{ANSIColors.RESET} \"\n\n    if \"old_args\" in kwargs:\n        old_args = kwargs[\"old_args\"]\n        entries = [\n            f\"{arg} = {ANSIColors.BRIGHT_YELLOW}0x{value:x}{ANSIColors.DEFAULT_COLOR}\"\n            if old_value == value\n            else f\"{arg} = {ANSIColors.STRIKE}{ANSIColors.BRIGHT_YELLOW}0x{old_value:x}{ANSIColors.RESET} {ANSIColors.BRIGHT_YELLOW}0x{value:x}{ANSIColors.DEFAULT_COLOR}\"\n            for arg, value, old_value in zip(syscall_args, values, old_args, strict=False)\n            if arg is not None\n        ]\n    else:\n        entries = [\n            f\"{arg} = {ANSIColors.BRIGHT_YELLOW}0x{value:x}{ANSIColors.DEFAULT_COLOR}\"\n            for arg, value in zip(syscall_args, values, strict=False)\n            if arg is not None\n        ]\n\n    hijacked = kwargs.get(\"hijacked\", False)\n    user_handled = kwargs.get(\"callback\", False)\n    hijacker = kwargs.get(\"hijacker\", None)\n    if hijacked:\n        print(\n            f\"{header}{ANSIColors.RED}(hijacked) {ANSIColors.STRIKE}{ANSIColors.BLUE}{syscall_name}{ANSIColors.DEFAULT_COLOR}({', '.join(entries)}){ANSIColors.RESET}\",\n        )\n    elif user_handled:\n        print(\n            f\"{header}{ANSIColors.RED}(callback) {ANSIColors.BLUE}{syscall_name}{ANSIColors.DEFAULT_COLOR}({', '.join(entries)}) = \",\n            end=\"\",\n        )\n    elif hijacker:\n        print(\n            f\"{header}{ANSIColors.RED}(executed) {ANSIColors.BLUE}{syscall_name}{ANSIColors.DEFAULT_COLOR}({', '.join(entries)}) = \",\n            end=\"\",\n        )\n    else:\n        print(\n            f\"{header}{ANSIColors.BLUE}{syscall_name}{ANSIColors.DEFAULT_COLOR}({', '.join(entries)}) = \",\n            end=\"\",\n        )\n</code></pre>"},{"location":"from_pydoc/generated/builtin/pretty_print_syscall_handler/#libdebug.builtin.pretty_print_syscall_handler.pprint_on_exit","title":"<code>pprint_on_exit(syscall_return)</code>","text":"<p>Function that will be called when a syscall is exited in pretty print mode.</p> <p>Parameters:</p> Name Type Description Default <code>syscall_return</code> <code>int | list[int]</code> <p>the syscall return value.</p> required Source code in <code>libdebug/builtin/pretty_print_syscall_handler.py</code> <pre><code>def pprint_on_exit(syscall_return: int | tuple[int, int]) -&gt; None:\n    \"\"\"Function that will be called when a syscall is exited in pretty print mode.\n\n    Args:\n        syscall_return (int | list[int]): the syscall return value.\n    \"\"\"\n    if isinstance(syscall_return, tuple):\n        print(\n            f\"{ANSIColors.YELLOW}{ANSIColors.STRIKE}0x{syscall_return[0]:x}{ANSIColors.RESET} {ANSIColors.YELLOW}0x{syscall_return[1]:x}{ANSIColors.RESET}\",\n        )\n    else:\n        print(f\"{ANSIColors.YELLOW}0x{syscall_return:x}{ANSIColors.RESET}\")\n</code></pre>"},{"location":"from_pydoc/generated/cffi/debug_sym_cffi_build/","title":"libdebug.cffi.debug_sym_cffi_build","text":""},{"location":"from_pydoc/generated/cffi/debug_sym_cffi_build_legacy/","title":"libdebug.cffi.debug_sym_cffi_build_legacy","text":""},{"location":"from_pydoc/generated/cffi/personality_cffi_build/","title":"libdebug.cffi.personality_cffi_build","text":""},{"location":"from_pydoc/generated/cffi/ptrace_cffi_build/","title":"libdebug.cffi.ptrace_cffi_build","text":""},{"location":"from_pydoc/generated/commlink/buffer_data/","title":"libdebug.commlink.buffer_data","text":""},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData","title":"<code>BufferData</code>","text":"<p>Class that represents a buffer to store data coming from stdout and stderr.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>class BufferData:\n    \"\"\"Class that represents a buffer to store data coming from stdout and stderr.\"\"\"\n\n    def __init__(self: BufferData, data: bytes) -&gt; None:\n        \"\"\"Initializes the BufferData object.\"\"\"\n        self.data = data\n\n    def clear(self: BufferData) -&gt; None:\n        \"\"\"Clears the buffer.\"\"\"\n        self.data = b\"\"\n\n    def get_data(self: BufferData) -&gt; bytes:\n        \"\"\"Returns the data stored in the buffer.\"\"\"\n        return self.data\n\n    def append(self, data: bytes) -&gt; None:\n        \"\"\"Appends data to the buffer.\"\"\"\n        self.data += data\n\n    def overwrite(self, data: bytes) -&gt; None:\n        \"\"\"Overwrites the buffer with the given data.\"\"\"\n        self.data = data\n\n    def find(self: BufferData, pattern: bytes) -&gt; int:\n        \"\"\"Finds the first occurrence of the given pattern in the buffer.\"\"\"\n        return self.data.find(pattern)\n\n    def __len__(self: BufferData) -&gt; int:\n        \"\"\"Returns the length of the buffer.\"\"\"\n        return len(self.data)\n\n    def __repr__(self: BufferData) -&gt; str:\n        \"\"\"Returns a string representation of the buffer.\"\"\"\n        return self.data.__repr__()\n\n    def __getitem__(self: BufferData, key: int) -&gt; bytes:\n        \"\"\"Returns the item at the given index.\"\"\"\n        return self.data[key]\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Returns the item at the given index.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def __getitem__(self: BufferData, key: int) -&gt; bytes:\n    \"\"\"Returns the item at the given index.\"\"\"\n    return self.data[key]\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.__init__","title":"<code>__init__(data)</code>","text":"<p>Initializes the BufferData object.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def __init__(self: BufferData, data: bytes) -&gt; None:\n    \"\"\"Initializes the BufferData object.\"\"\"\n    self.data = data\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.__len__","title":"<code>__len__()</code>","text":"<p>Returns the length of the buffer.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def __len__(self: BufferData) -&gt; int:\n    \"\"\"Returns the length of the buffer.\"\"\"\n    return len(self.data)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the buffer.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def __repr__(self: BufferData) -&gt; str:\n    \"\"\"Returns a string representation of the buffer.\"\"\"\n    return self.data.__repr__()\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.append","title":"<code>append(data)</code>","text":"<p>Appends data to the buffer.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def append(self, data: bytes) -&gt; None:\n    \"\"\"Appends data to the buffer.\"\"\"\n    self.data += data\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.clear","title":"<code>clear()</code>","text":"<p>Clears the buffer.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def clear(self: BufferData) -&gt; None:\n    \"\"\"Clears the buffer.\"\"\"\n    self.data = b\"\"\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.find","title":"<code>find(pattern)</code>","text":"<p>Finds the first occurrence of the given pattern in the buffer.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def find(self: BufferData, pattern: bytes) -&gt; int:\n    \"\"\"Finds the first occurrence of the given pattern in the buffer.\"\"\"\n    return self.data.find(pattern)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.get_data","title":"<code>get_data()</code>","text":"<p>Returns the data stored in the buffer.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def get_data(self: BufferData) -&gt; bytes:\n    \"\"\"Returns the data stored in the buffer.\"\"\"\n    return self.data\n</code></pre>"},{"location":"from_pydoc/generated/commlink/buffer_data/#libdebug.commlink.buffer_data.BufferData.overwrite","title":"<code>overwrite(data)</code>","text":"<p>Overwrites the buffer with the given data.</p> Source code in <code>libdebug/commlink/buffer_data.py</code> <pre><code>def overwrite(self, data: bytes) -&gt; None:\n    \"\"\"Overwrites the buffer with the given data.\"\"\"\n    self.data = data\n</code></pre>"},{"location":"from_pydoc/generated/commlink/libterminal/","title":"libdebug.commlink.libterminal","text":""},{"location":"from_pydoc/generated/commlink/libterminal/#libdebug.commlink.libterminal.LibTerminal","title":"<code>LibTerminal</code>","text":"<p>Class that represents a terminal to interact with the child process.</p> Source code in <code>libdebug/commlink/libterminal.py</code> <pre><code>class LibTerminal:\n    \"\"\"Class that represents a terminal to interact with the child process.\"\"\"\n\n    def __init__(\n        self: LibTerminal,\n        prompt: str,\n        sendline: callable,\n        end_interactive_event: Event,\n        auto_quit: bool,\n    ) -&gt; None:\n        \"\"\"Initializes the LibTerminal object.\"\"\"\n        # Provide the internal debugger instance\n        self._internal_debugger = provide_internal_debugger(self)\n\n        # Function to send a line to the child process\n        self._sendline: callable = sendline\n\n        # Event to signal the end of the interactive session\n        self.__end_interactive_event: Event = end_interactive_event\n\n        # Flag to indicate if the terminal should automatically quit when the debugged process stops\n        self._auto_quit: bool = auto_quit\n\n        # Initialize the message queue for the prompt_toolkit application\n        self._app_message_queue: Queue = Queue()\n\n        # Initialize the thread reference for the prompt_toolkit application\n        self._app_thread: threading.Thread | None = None\n\n        # Flag to indicate if the terminal has warned the user about the stop of the debugged process\n        self._has_warned_stop: bool = False\n\n        # Backup the original stdout and stderr\n        self._stdout_backup: object = sys.stdout\n        self._stderr_backup: object = sys.stderr\n\n        # Redirect stdout and stderr to the terminal\n        sys.stdout = StdWrapper(self._stdout_backup, self)\n        sys.stderr = StdWrapper(self._stderr_backup, self)\n\n        # Redirect the loggers to the terminal\n        for handler in liblog.general_logger.handlers:\n            if isinstance(handler, StreamHandler):\n                handler.stream = sys.stderr\n\n        for handler in liblog.pipe_logger.handlers:\n            if isinstance(handler, StreamHandler):\n                handler.stream = sys.stderr\n\n        for handler in liblog.debugger_logger.handlers:\n            if isinstance(handler, StreamHandler):\n                handler.stream = sys.stderr\n\n        # Save the original stdin settings, if needed. Just in case\n        if not self._internal_debugger.stdin_settings_backup:\n            self._internal_debugger.stdin_settings_backup = tcgetattr(sys.stdin.fileno())\n\n        # Create the history file, if it does not exist\n        if not PATH_HISTORY.exists():\n            PATH_HISTORY.parent.mkdir(parents=True, exist_ok=True)\n            PATH_HISTORY.touch()\n\n        self._run_prompt(prompt)\n\n    def _run_prompt(self: LibTerminal, prompt: str) -&gt; None:\n        \"\"\"Run the prompt_toolkit application.\"\"\"\n        input_field = TextArea(\n            height=3,\n            prompt=prompt,\n            style=\"class:input-field\",\n            history=FileHistory(str(PATH_HISTORY)),\n            auto_suggest=AutoSuggestFromHistory(),\n        )\n\n        kb = KeyBindings()\n\n        @kb.add(\"enter\")\n        def on_enter(event: KeyPressEvent) -&gt; None:\n            \"\"\"Send the user input to the child process.\"\"\"\n            buffer = event.app.current_buffer\n            cmd = buffer.text\n            if cmd:\n                try:\n                    self._sendline(cmd.encode(\"utf-8\"))\n                    buffer.history.append_string(cmd)\n                except RuntimeError:\n                    liblog.warning(\"The stdin pipe of the child process is not available anymore\")\n                finally:\n                    buffer.reset()\n\n        @kb.add(\"c-c\")\n        @kb.add(\"c-d\")\n        def app_exit(event: KeyPressEvent) -&gt; None:\n            \"\"\"Manage the key bindings for the exit of the application.\"\"\"\n            # Flush the output field\n            update_output(event.app)\n            # Signal the end of the interactive session\n            self.__end_interactive_event.set()\n            while self.__end_interactive_event.is_set():\n                # Wait to be sure that the other thread is not polling from the child process's\n                # stderr and stdout pipes anymore\n                pass\n            event.app.exit()\n\n        @kb.add(\"tab\")\n        def accept_suggestion(event: KeyPressEvent) -&gt; None:\n            \"\"\"Accept the auto-suggestion.\"\"\"\n            buffer = event.current_buffer\n            suggestion = buffer.suggestion\n            if suggestion:\n                buffer.insert_text(suggestion.text)\n\n        layout = Layout(input_field)\n\n        # Note: The refresh_interval is set to 0.5 seconds is an arbitrary trade-off between the\n        # responsiveness of the terminal and the CPU usage. Little values also cause difficulties\n        # in the management of the copy-paste. We might consider to change the value in the future or\n        # to make it dynamic/configurable.\n        app = Application(\n            layout=layout,\n            key_bindings=kb,\n            full_screen=False,\n            refresh_interval=0.5,\n        )\n\n        def update_output(app: Application) -&gt; None:\n            \"\"\"Update the output field with the messages in the queue.\"\"\"\n            if (\n                not self._internal_debugger.running\n                and (event_type := self._internal_debugger.resume_context.get_event_type())\n                and not self._has_warned_stop\n            ):\n                liblog.warning(\n                    f\"The debugged process has stopped due to the following event(s). {event_type}\",\n                )\n                self._has_warned_stop = True\n                if self._auto_quit:\n                    # Flush the output field and exit the application\n                    self.__end_interactive_event.set()\n\n                    while self.__end_interactive_event.is_set():\n                        # Wait to be sure that the other thread is not polling from the child process\n                        # stderr and stdout pipes anymore\n                        pass\n\n            # Update the output field with the messages in the queue\n            msg = b\"\"\n            if not self._app_message_queue.empty():\n                msg += self._app_message_queue.get()\n\n            if msg:\n                if not msg.endswith(b\"\\n\"):\n                    # Add a newline character at the end of the message\n                    # to avoid the prompt_toolkit bug that causes the last line to be\n                    # overwritten by the prompt\n                    msg += b\"\\n\"\n                run_in_terminal(lambda: sys.stdout.buffer.write(msg))\n                run_in_terminal(lambda: sys.stdout.buffer.flush())\n\n            if self._has_warned_stop and self._auto_quit:\n                app.exit()\n\n        # Add the update_output function to the event loop\n        app.on_invalidate.add_handler(update_output)\n\n        # Run in another thread\n        self._app_thread = threading.Thread(target=app.run, daemon=True)\n        self._app_thread.start()\n\n    def _write_manager(self, payload: bytes) -&gt; int:\n        \"\"\"Put the payload in the message queue for the prompt_toolkit application.\"\"\"\n        if isinstance(payload, bytes):\n            # We want the special characters to be displayed correctly\n            self._app_message_queue.put(payload.decode(\"utf-8\", errors=\"backslashreplace\").encode(\"utf-8\"))\n        else:\n            # We need to encode the payload to bytes\n            self._app_message_queue.put(payload.encode(\"utf-8\"))\n\n    def reset(self: LibTerminal) -&gt; None:\n        \"\"\"Reset the terminal to its original state.\"\"\"\n        # Wait for the prompt_toolkit application to finish\n        # This (included the timeout) is necessary to avoid race conditions and deadlocks\n        while self._app_thread.join(0.1):\n            pass\n\n        # Restore the original stdout and stderr\n        sys.stdout = self._stdout_backup\n        sys.stderr = self._stderr_backup\n\n        # Restore the loggers\n        for handler in liblog.general_logger.handlers:\n            if isinstance(handler, StreamHandler):\n                handler.stream = sys.stderr\n\n        for handler in liblog.pipe_logger.handlers:\n            if isinstance(handler, StreamHandler):\n                handler.stream = sys.stderr\n\n        for handler in liblog.debugger_logger.handlers:\n            if isinstance(handler, StreamHandler):\n                handler.stream = sys.stderr\n\n        # Restore the original stdin settings\n        tcsetattr(sys.stdin.fileno(), TCSANOW, self._internal_debugger.stdin_settings_backup)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/libterminal/#libdebug.commlink.libterminal.LibTerminal.__init__","title":"<code>__init__(prompt, sendline, end_interactive_event, auto_quit)</code>","text":"<p>Initializes the LibTerminal object.</p> Source code in <code>libdebug/commlink/libterminal.py</code> <pre><code>def __init__(\n    self: LibTerminal,\n    prompt: str,\n    sendline: callable,\n    end_interactive_event: Event,\n    auto_quit: bool,\n) -&gt; None:\n    \"\"\"Initializes the LibTerminal object.\"\"\"\n    # Provide the internal debugger instance\n    self._internal_debugger = provide_internal_debugger(self)\n\n    # Function to send a line to the child process\n    self._sendline: callable = sendline\n\n    # Event to signal the end of the interactive session\n    self.__end_interactive_event: Event = end_interactive_event\n\n    # Flag to indicate if the terminal should automatically quit when the debugged process stops\n    self._auto_quit: bool = auto_quit\n\n    # Initialize the message queue for the prompt_toolkit application\n    self._app_message_queue: Queue = Queue()\n\n    # Initialize the thread reference for the prompt_toolkit application\n    self._app_thread: threading.Thread | None = None\n\n    # Flag to indicate if the terminal has warned the user about the stop of the debugged process\n    self._has_warned_stop: bool = False\n\n    # Backup the original stdout and stderr\n    self._stdout_backup: object = sys.stdout\n    self._stderr_backup: object = sys.stderr\n\n    # Redirect stdout and stderr to the terminal\n    sys.stdout = StdWrapper(self._stdout_backup, self)\n    sys.stderr = StdWrapper(self._stderr_backup, self)\n\n    # Redirect the loggers to the terminal\n    for handler in liblog.general_logger.handlers:\n        if isinstance(handler, StreamHandler):\n            handler.stream = sys.stderr\n\n    for handler in liblog.pipe_logger.handlers:\n        if isinstance(handler, StreamHandler):\n            handler.stream = sys.stderr\n\n    for handler in liblog.debugger_logger.handlers:\n        if isinstance(handler, StreamHandler):\n            handler.stream = sys.stderr\n\n    # Save the original stdin settings, if needed. Just in case\n    if not self._internal_debugger.stdin_settings_backup:\n        self._internal_debugger.stdin_settings_backup = tcgetattr(sys.stdin.fileno())\n\n    # Create the history file, if it does not exist\n    if not PATH_HISTORY.exists():\n        PATH_HISTORY.parent.mkdir(parents=True, exist_ok=True)\n        PATH_HISTORY.touch()\n\n    self._run_prompt(prompt)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/libterminal/#libdebug.commlink.libterminal.LibTerminal.reset","title":"<code>reset()</code>","text":"<p>Reset the terminal to its original state.</p> Source code in <code>libdebug/commlink/libterminal.py</code> <pre><code>def reset(self: LibTerminal) -&gt; None:\n    \"\"\"Reset the terminal to its original state.\"\"\"\n    # Wait for the prompt_toolkit application to finish\n    # This (included the timeout) is necessary to avoid race conditions and deadlocks\n    while self._app_thread.join(0.1):\n        pass\n\n    # Restore the original stdout and stderr\n    sys.stdout = self._stdout_backup\n    sys.stderr = self._stderr_backup\n\n    # Restore the loggers\n    for handler in liblog.general_logger.handlers:\n        if isinstance(handler, StreamHandler):\n            handler.stream = sys.stderr\n\n    for handler in liblog.pipe_logger.handlers:\n        if isinstance(handler, StreamHandler):\n            handler.stream = sys.stderr\n\n    for handler in liblog.debugger_logger.handlers:\n        if isinstance(handler, StreamHandler):\n            handler.stream = sys.stderr\n\n    # Restore the original stdin settings\n    tcsetattr(sys.stdin.fileno(), TCSANOW, self._internal_debugger.stdin_settings_backup)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/","title":"libdebug.commlink.pipe_manager","text":""},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager","title":"<code>PipeManager</code>","text":"<p>Class for managing pipes of the child process.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>class PipeManager:\n    \"\"\"Class for managing pipes of the child process.\"\"\"\n\n    timeout_default: int = 2\n    prompt_default: str = \"$ \"\n\n    def __init__(self: PipeManager, stdin_write: int, stdout_read: int, stderr_read: int) -&gt; None:\n        \"\"\"Initializes the PipeManager class.\n\n        Args:\n            stdin_write (int): file descriptor for stdin write.\n            stdout_read (int): file descriptor for stdout read.\n            stderr_read (int): file descriptor for stderr read.\n        \"\"\"\n        self._stdin_write: int = stdin_write\n        self._stdout_read: int = stdout_read\n        self._stderr_read: int = stderr_read\n        self._stderr_is_open: bool = True\n        self._stdout_is_open: bool = True\n        self._internal_debugger: InternalDebugger = provide_internal_debugger(self)\n\n        self.__stdout_buffer: BufferData = BufferData(b\"\")\n        self.__stderr_buffer: BufferData = BufferData(b\"\")\n\n        self.__end_interactive_event: Event = Event()\n\n    def _raw_recv(\n        self: PipeManager,\n        numb: int | None = None,\n        timeout: float | None = None,\n        stderr: bool = False,\n    ) -&gt; int:\n        \"\"\"Receives at most numb bytes from the child process.\n\n        Args:\n            numb (int | None, optional): number of bytes to receive. Defaults to None.\n            timeout (float, optional): timeout in seconds. Defaults to None.\n            stderr (bool, optional): receive from stderr. Defaults to False.\n\n        Returns:\n            int: number of bytes received.\n        \"\"\"\n        pipe_read: int = self._stderr_read if stderr else self._stdout_read\n\n        if not pipe_read:\n            raise RuntimeError(\"No pipe of the child process\")\n\n        data_buffer = self.__stderr_buffer if stderr else self.__stdout_buffer\n\n        received_numb = 0\n\n        if numb is not None and timeout is not None:\n            # Checking the numb\n            if numb &lt; 0:\n                raise ValueError(\"The number of bytes to receive must be positive\")\n\n            # Setting the alarm\n            end_time = time.time() + timeout\n\n            while numb &gt; received_numb:\n                if (remaining_time := max(0, end_time - time.time())) == 0:\n                    # Timeout reached\n                    break\n\n                try:\n                    ready, _, _ = select.select([pipe_read], [], [], remaining_time)\n                    if ready:\n                        data = os.read(pipe_read, 4096)\n                        received_numb += len(data)\n                        data_buffer.append(data)\n                    else:\n                        # No more data available in the pipe at the moment\n                        break\n                except OSError as e:\n                    if e.errno != EAGAIN:\n                        if stderr:\n                            self._stderr_is_open = False\n                        else:\n                            self._stdout_is_open = False\n        elif timeout is not None:\n            try:\n                ready, _, _ = select.select([pipe_read], [], [], timeout)\n                if ready:\n                    data = os.read(pipe_read, 4096)\n                    received_numb += len(data)\n                    data_buffer.append(data)\n            except OSError as e:\n                if e.errno != EAGAIN:\n                    if stderr:\n                        self._stderr_is_open = False\n                    else:\n                        self._stdout_is_open = False\n        else:\n            try:\n                data = os.read(pipe_read, 4096)\n                if data:\n                    received_numb += len(data)\n                    data_buffer.append(data)\n            except OSError as e:\n                if e.errno != EAGAIN:\n                    if stderr:\n                        self._stderr_is_open = False\n                    else:\n                        self._stdout_is_open = False\n\n        if received_numb:\n            liblog.pipe(f\"{'stderr' if stderr else 'stdout'} {received_numb}B: {data_buffer[:received_numb]!r}\")\n        return received_numb\n\n    def close(self: PipeManager) -&gt; None:\n        \"\"\"Closes all the pipes of the child process.\"\"\"\n        os.close(self._stdin_write)\n        os.close(self._stdout_read)\n        os.close(self._stderr_read)\n\n    def _buffered_recv(self: PipeManager, numb: int, timeout: int, stderr: bool) -&gt; bytes:\n        \"\"\"Receives at most numb bytes from the child process stdout or stderr.\n\n        Args:\n            numb (int): number of bytes to receive.\n            timeout (int): timeout in seconds.\n            stderr (bool): receive from stderr.\n\n        Returns:\n            bytes: received bytes from the child process stdout or stderr.\n        \"\"\"\n        data_buffer = self.__stderr_buffer if stderr else self.__stdout_buffer\n        open_flag = self._stderr_is_open if stderr else self._stdout_is_open\n\n        data_buffer_len = len(data_buffer)\n\n        if data_buffer_len &gt;= numb:\n            # We have enough data in the buffer\n            received = data_buffer[:numb]\n            data_buffer.overwrite(data_buffer[numb:])\n        elif open_flag:\n            # We can receive more data\n            remaining = numb - data_buffer_len\n            self._raw_recv(numb=remaining, timeout=timeout, stderr=stderr)\n            received = data_buffer[:numb]\n            data_buffer.overwrite(data_buffer[numb:])\n        elif data_buffer_len != 0:\n            # The pipe is not available but we have some data in the buffer. We will return just that\n            received = data_buffer.get_data()\n            data_buffer.clear()\n        else:\n            # The pipe is not available and no data is buffered\n            raise RuntimeError(f\"Broken {'stderr' if stderr else 'stdout'} pipe. Is the child process still alive?\")\n        return received\n\n    def recv(\n        self: PipeManager,\n        numb: int = 4096,\n        timeout: int = timeout_default,\n    ) -&gt; bytes:\n        \"\"\"Receives at most numb bytes from the child process stdout.\n\n        Args:\n            numb (int, optional): number of bytes to receive. Defaults to 4096.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received bytes from the child process stdout.\n        \"\"\"\n        return self._buffered_recv(numb=numb, timeout=timeout, stderr=False)\n\n    def recverr(\n        self: PipeManager,\n        numb: int = 4096,\n        timeout: int = timeout_default,\n    ) -&gt; bytes:\n        \"\"\"Receives at most numb bytes from the child process stderr.\n\n        Args:\n            numb (int, optional): number of bytes to receive. Defaults to 4096.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n        Returns:\n            bytes: received bytes from the child process stderr.\n        \"\"\"\n        return self._buffered_recv(numb=numb, timeout=timeout, stderr=True)\n\n    def _recvonceuntil(\n        self: PipeManager,\n        delims: bytes,\n        drop: bool = False,\n        timeout: float = timeout_default,\n        stderr: bool = False,\n        optional: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives data from the child process until the delimiters are found.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (float, optional): timeout in seconds. Defaults to timeout_default.\n            stderr (bool, optional): receive from stderr. Defaults to False.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stdout.\n        \"\"\"\n        if isinstance(delims, str):\n            liblog.warning(\"The delimiters are a string, converting to bytes\")\n            delims = delims.encode()\n\n        # Buffer for the received data\n        data_buffer = self.__stderr_buffer if stderr else self.__stdout_buffer\n\n        # Setting the alarm\n        end_time = time.time() + timeout\n        while True:\n            open_flag = self._stderr_is_open if stderr else self._stdout_is_open\n\n            if (until := data_buffer.find(delims)) != -1:\n                break\n\n            if (remaining_time := max(0, end_time - time.time())) == 0:\n                raise TimeoutError(\"Timeout reached\")\n\n            if not open_flag:\n                # The delimiters are not in the buffer and the pipe is not available\n                raise RuntimeError(f\"Broken {'stderr' if stderr else 'stdout'} pipe. Is the child process still alive?\")\n\n            received_numb = self._raw_recv(stderr=stderr, timeout=remaining_time)\n\n            if (\n                received_numb == 0\n                and not self._internal_debugger.running\n                and self._internal_debugger.is_debugging\n                and (event := self._internal_debugger.resume_context.get_event_type())\n            ):\n                # We will not receive more data, the child process is not running\n                if optional:\n                    return b\"\"\n                event = self._internal_debugger.resume_context.get_event_type()\n                raise RuntimeError(\n                    f\"Receive until error. The debugged process has stopped due to the following event(s). {event}\",\n                )\n        received_data = data_buffer[:until]\n        if not drop:\n            # Include the delimiters in the received data\n            received_data += data_buffer[until : until + len(delims)]\n        remaining_data = data_buffer[until + len(delims) :]\n        data_buffer.overwrite(remaining_data)\n        return received_data\n\n    def _recvuntil(\n        self: PipeManager,\n        delims: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: float = timeout_default,\n        stderr: bool = False,\n        optional: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives data from the child process until the delimiters are found occurences time.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (float, optional): timeout in seconds. Defaults to timeout_default.\n            stderr (bool, optional): receive from stderr. Defaults to False.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stdout.\n        \"\"\"\n        if occurences &lt;= 0:\n            raise ValueError(\"The number of occurences to receive must be positive\")\n\n        # Buffer for the received data\n        data_buffer = b\"\"\n\n        # Setting the alarm\n        end_time = time.time() + timeout\n\n        for _ in range(occurences):\n            # Adjust the timeout for select to the remaining time\n            remaining_time = None if end_time is None else max(0, end_time - time.time())\n\n            data_buffer += self._recvonceuntil(\n                delims=delims,\n                drop=drop,\n                timeout=remaining_time,\n                stderr=stderr,\n                optional=optional,\n            )\n\n        return data_buffer\n\n    def recvuntil(\n        self: PipeManager,\n        delims: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n        optional: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives data from the child process stdout until the delimiters are found.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stdout.\n        \"\"\"\n        return self._recvuntil(\n            delims=delims,\n            occurences=occurences,\n            drop=drop,\n            timeout=timeout,\n            stderr=False,\n            optional=optional,\n        )\n\n    def recverruntil(\n        self: PipeManager,\n        delims: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n        optional: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives data from the child process stderr until the delimiters are found.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stderr.\n        \"\"\"\n        return self._recvuntil(\n            delims=delims,\n            occurences=occurences,\n            drop=drop,\n            timeout=timeout,\n            stderr=True,\n            optional=optional,\n        )\n\n    def recvline(\n        self: PipeManager,\n        numlines: int = 1,\n        drop: bool = True,\n        timeout: int = timeout_default,\n        optional: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives numlines lines from the child process stdout.\n\n        Args:\n            numlines (int, optional): number of lines to receive. Defaults to 1.\n            drop (bool, optional): drop the line ending. Defaults to True.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received lines from the child process stdout.\n        \"\"\"\n        return self.recvuntil(delims=b\"\\n\", occurences=numlines, drop=drop, timeout=timeout, optional=optional)\n\n    def recverrline(\n        self: PipeManager,\n        numlines: int = 1,\n        drop: bool = True,\n        timeout: int = timeout_default,\n        optional: bool = False,\n    ) -&gt; bytes:\n        \"\"\"Receives numlines lines from the child process stderr.\n\n        Args:\n            numlines (int, optional): number of lines to receive. Defaults to 1.\n            drop (bool, optional): drop the line ending. Defaults to True.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received lines from the child process stdout.\n        \"\"\"\n        return self.recverruntil(delims=b\"\\n\", occurences=numlines, drop=drop, timeout=timeout, optional=optional)\n\n    def send(self: PipeManager, data: bytes) -&gt; int:\n        \"\"\"Sends data to the child process stdin.\n\n        Args:\n            data (bytes): data to send.\n\n        Returns:\n            int: number of bytes sent.\n\n        Raises:\n            RuntimeError: no stdin pipe of the child process.\n        \"\"\"\n        if not self._stdin_write:\n            raise RuntimeError(\"No stdin pipe of the child process\")\n\n        liblog.pipe(f\"Sending {len(data)} bytes to the child process: {data!r}\")\n\n        if isinstance(data, str):\n            liblog.warning(\"The input data is a string, converting to bytes\")\n            data = data.encode()\n\n        try:\n            number_bytes = os.write(self._stdin_write, data)\n        except OSError as e:\n            raise RuntimeError(\"Broken pipe. Is the child process still running?\") from e\n\n        return number_bytes\n\n    def sendline(self: PipeManager, data: bytes) -&gt; int:\n        \"\"\"Sends data to the child process stdin and append a newline.\n\n        Args:\n            data (bytes): data to send.\n\n        Returns:\n            int: number of bytes sent.\n        \"\"\"\n        if isinstance(data, str):\n            liblog.warning(\"The input data is a string, converting to bytes\")\n            data = data.encode()\n        return self.send(data=data + b\"\\n\")\n\n    def sendafter(\n        self: PipeManager,\n        delims: bytes,\n        data: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n        optional: bool = False,\n    ) -&gt; tuple[bytes, int]:\n        \"\"\"Sends data to the child process stdin after the delimiters are found in the stdout.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            data (bytes): data to send.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stdout.\n            int: number of bytes sent.\n        \"\"\"\n        received = self.recvuntil(delims=delims, occurences=occurences, drop=drop, timeout=timeout, optional=optional)\n        sent = self.send(data)\n        return (received, sent)\n\n    def sendaftererr(\n        self: PipeManager,\n        delims: bytes,\n        data: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n        optional: bool = False,\n    ) -&gt; tuple[bytes, int]:\n        \"\"\"Sends data to the child process stdin after the delimiters are found in stderr.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            data (bytes): data to send.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stderr.\n            int: number of bytes sent.\n        \"\"\"\n        received = self.recverruntil(\n            delims=delims,\n            occurences=occurences,\n            drop=drop,\n            timeout=timeout,\n            optional=optional,\n        )\n        sent = self.send(data)\n        return (received, sent)\n\n    def sendlineafter(\n        self: PipeManager,\n        delims: bytes,\n        data: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n        optional: bool = False,\n    ) -&gt; tuple[bytes, int]:\n        \"\"\"Sends line to the child process stdin after the delimiters are found in the stdout.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            data (bytes): data to send.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stdout.\n            int: number of bytes sent.\n        \"\"\"\n        received = self.recvuntil(delims=delims, occurences=occurences, drop=drop, timeout=timeout, optional=optional)\n        sent = self.sendline(data)\n        return (received, sent)\n\n    def sendlineaftererr(\n        self: PipeManager,\n        delims: bytes,\n        data: bytes,\n        occurences: int = 1,\n        drop: bool = False,\n        timeout: int = timeout_default,\n        optional: bool = False,\n    ) -&gt; tuple[bytes, int]:\n        \"\"\"Sends line to the child process stdin after the delimiters are found in the stderr.\n\n        Args:\n            delims (bytes): delimiters where to stop.\n            data (bytes): data to send.\n            occurences (int, optional): number of delimiters to find. Defaults to 1.\n            drop (bool, optional): drop the delimiter. Defaults to False.\n            timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n            optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n        Returns:\n            bytes: received data from the child process stderr.\n            int: number of bytes sent.\n        \"\"\"\n        received = self.recverruntil(\n            delims=delims,\n            occurences=occurences,\n            drop=drop,\n            timeout=timeout,\n            optional=optional,\n        )\n        sent = self.sendline(data)\n        return (received, sent)\n\n    def _recv_for_interactive(self: PipeManager) -&gt; None:\n        \"\"\"Receives data from the child process.\"\"\"\n        stdout_has_warned = False\n        stderr_has_warned = False\n\n        while not (self.__end_interactive_event.is_set() or (stdout_has_warned and stderr_has_warned)):\n            # We can afford to treat stdout and stderr sequentially. This approach should also prevent\n            # messing up the order of the information printed by the child process.\n            # To avoid starvation, we switch between pipes upon receiving a bunch of data from one of them.\n            if self._stdout_is_open:\n                while True:\n                    new_recv = self._raw_recv()\n                    payload = self.__stdout_buffer.get_data()\n\n                    if not (new_recv or payload):\n                        # No more data available in the stdout pipe at the moment\n                        break\n\n                    sys.stdout.write(payload)\n                    self.__stdout_buffer.clear()\n            elif not stdout_has_warned:\n                # The child process has closed the stdout pipe and we have to print the warning message\n                liblog.warning(\"The stdout pipe of the child process is not available anymore\")\n                stdout_has_warned = True\n            if self._stderr_is_open:\n                while True:\n                    new_recv = self._raw_recv(stderr=True)\n                    payload = self.__stderr_buffer.get_data()\n\n                    if not (new_recv or payload):\n                        # No more data available in the stderr pipe at the moment\n                        break\n\n                    sys.stderr.write(payload)\n                    self.__stderr_buffer.clear()\n            elif not stderr_has_warned:\n                # The child process has closed the stderr pipe\n                liblog.warning(\"The stderr pipe of the child process is not available anymore\")\n                stderr_has_warned = True\n\n    def interactive(self: PipeManager, prompt: str = prompt_default, auto_quit: bool = False) -&gt; None:\n        \"\"\"Manually interact with the child process.\n\n        Args:\n            prompt (str, optional): prompt for the interactive mode. Defaults to \"$ \" (prompt_default).\n            auto_quit (bool, optional): whether to automatically quit the interactive mode when the child process is not running. Defaults to False.\n        \"\"\"\n        liblog.info(\"Calling interactive mode\")\n\n        # Set up and run the terminal\n        with extend_internal_debugger(self):\n            libterminal = LibTerminal(prompt, self.sendline, self.__end_interactive_event, auto_quit)\n\n        # Receive data from the child process's stdout and stderr pipes\n        self._recv_for_interactive()\n\n        # Be sure that the interactive mode has ended\n        # If the the stderr and stdout pipes are closed, the interactive mode will continue until the user manually\n        # stops it\n        self.__end_interactive_event.wait()\n\n        # Unset the interactive mode event\n        self.__end_interactive_event.clear()\n\n        # Reset the terminal\n        libterminal.reset()\n\n        liblog.info(\"Exiting interactive mode\")\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.__init__","title":"<code>__init__(stdin_write, stdout_read, stderr_read)</code>","text":"<p>Initializes the PipeManager class.</p> <p>Parameters:</p> Name Type Description Default <code>stdin_write</code> <code>int</code> <p>file descriptor for stdin write.</p> required <code>stdout_read</code> <code>int</code> <p>file descriptor for stdout read.</p> required <code>stderr_read</code> <code>int</code> <p>file descriptor for stderr read.</p> required Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def __init__(self: PipeManager, stdin_write: int, stdout_read: int, stderr_read: int) -&gt; None:\n    \"\"\"Initializes the PipeManager class.\n\n    Args:\n        stdin_write (int): file descriptor for stdin write.\n        stdout_read (int): file descriptor for stdout read.\n        stderr_read (int): file descriptor for stderr read.\n    \"\"\"\n    self._stdin_write: int = stdin_write\n    self._stdout_read: int = stdout_read\n    self._stderr_read: int = stderr_read\n    self._stderr_is_open: bool = True\n    self._stdout_is_open: bool = True\n    self._internal_debugger: InternalDebugger = provide_internal_debugger(self)\n\n    self.__stdout_buffer: BufferData = BufferData(b\"\")\n    self.__stderr_buffer: BufferData = BufferData(b\"\")\n\n    self.__end_interactive_event: Event = Event()\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.close","title":"<code>close()</code>","text":"<p>Closes all the pipes of the child process.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def close(self: PipeManager) -&gt; None:\n    \"\"\"Closes all the pipes of the child process.\"\"\"\n    os.close(self._stdin_write)\n    os.close(self._stdout_read)\n    os.close(self._stderr_read)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.interactive","title":"<code>interactive(prompt=prompt_default, auto_quit=False)</code>","text":"<p>Manually interact with the child process.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>prompt for the interactive mode. Defaults to \"$ \" (prompt_default).</p> <code>prompt_default</code> <code>auto_quit</code> <code>bool</code> <p>whether to automatically quit the interactive mode when the child process is not running. Defaults to False.</p> <code>False</code> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def interactive(self: PipeManager, prompt: str = prompt_default, auto_quit: bool = False) -&gt; None:\n    \"\"\"Manually interact with the child process.\n\n    Args:\n        prompt (str, optional): prompt for the interactive mode. Defaults to \"$ \" (prompt_default).\n        auto_quit (bool, optional): whether to automatically quit the interactive mode when the child process is not running. Defaults to False.\n    \"\"\"\n    liblog.info(\"Calling interactive mode\")\n\n    # Set up and run the terminal\n    with extend_internal_debugger(self):\n        libterminal = LibTerminal(prompt, self.sendline, self.__end_interactive_event, auto_quit)\n\n    # Receive data from the child process's stdout and stderr pipes\n    self._recv_for_interactive()\n\n    # Be sure that the interactive mode has ended\n    # If the the stderr and stdout pipes are closed, the interactive mode will continue until the user manually\n    # stops it\n    self.__end_interactive_event.wait()\n\n    # Unset the interactive mode event\n    self.__end_interactive_event.clear()\n\n    # Reset the terminal\n    libterminal.reset()\n\n    liblog.info(\"Exiting interactive mode\")\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.recv","title":"<code>recv(numb=4096, timeout=timeout_default)</code>","text":"<p>Receives at most numb bytes from the child process stdout.</p> <p>Parameters:</p> Name Type Description Default <code>numb</code> <code>int</code> <p>number of bytes to receive. Defaults to 4096.</p> <code>4096</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received bytes from the child process stdout.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def recv(\n    self: PipeManager,\n    numb: int = 4096,\n    timeout: int = timeout_default,\n) -&gt; bytes:\n    \"\"\"Receives at most numb bytes from the child process stdout.\n\n    Args:\n        numb (int, optional): number of bytes to receive. Defaults to 4096.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received bytes from the child process stdout.\n    \"\"\"\n    return self._buffered_recv(numb=numb, timeout=timeout, stderr=False)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.recverr","title":"<code>recverr(numb=4096, timeout=timeout_default)</code>","text":"<p>Receives at most numb bytes from the child process stderr.</p> <p>Parameters:</p> Name Type Description Default <code>numb</code> <code>int</code> <p>number of bytes to receive. Defaults to 4096.</p> <code>4096</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received bytes from the child process stderr.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def recverr(\n    self: PipeManager,\n    numb: int = 4096,\n    timeout: int = timeout_default,\n) -&gt; bytes:\n    \"\"\"Receives at most numb bytes from the child process stderr.\n\n    Args:\n        numb (int, optional): number of bytes to receive. Defaults to 4096.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n\n    Returns:\n        bytes: received bytes from the child process stderr.\n    \"\"\"\n    return self._buffered_recv(numb=numb, timeout=timeout, stderr=True)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.recverrline","title":"<code>recverrline(numlines=1, drop=True, timeout=timeout_default, optional=False)</code>","text":"<p>Receives numlines lines from the child process stderr.</p> <p>Parameters:</p> Name Type Description Default <code>numlines</code> <code>int</code> <p>number of lines to receive. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the line ending. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <code>optional</code> <code>bool</code> <p>whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received lines from the child process stdout.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def recverrline(\n    self: PipeManager,\n    numlines: int = 1,\n    drop: bool = True,\n    timeout: int = timeout_default,\n    optional: bool = False,\n) -&gt; bytes:\n    \"\"\"Receives numlines lines from the child process stderr.\n\n    Args:\n        numlines (int, optional): number of lines to receive. Defaults to 1.\n        drop (bool, optional): drop the line ending. Defaults to True.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n        optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n    Returns:\n        bytes: received lines from the child process stdout.\n    \"\"\"\n    return self.recverruntil(delims=b\"\\n\", occurences=numlines, drop=drop, timeout=timeout, optional=optional)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.recverruntil","title":"<code>recverruntil(delims, occurences=1, drop=False, timeout=timeout_default, optional=False)</code>","text":"<p>Receives data from the child process stderr until the delimiters are found.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <code>optional</code> <code>bool</code> <p>whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stderr.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def recverruntil(\n    self: PipeManager,\n    delims: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n    optional: bool = False,\n) -&gt; bytes:\n    \"\"\"Receives data from the child process stderr until the delimiters are found.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n        optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n    Returns:\n        bytes: received data from the child process stderr.\n    \"\"\"\n    return self._recvuntil(\n        delims=delims,\n        occurences=occurences,\n        drop=drop,\n        timeout=timeout,\n        stderr=True,\n        optional=optional,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.recvline","title":"<code>recvline(numlines=1, drop=True, timeout=timeout_default, optional=False)</code>","text":"<p>Receives numlines lines from the child process stdout.</p> <p>Parameters:</p> Name Type Description Default <code>numlines</code> <code>int</code> <p>number of lines to receive. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the line ending. Defaults to True.</p> <code>True</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <code>optional</code> <code>bool</code> <p>whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received lines from the child process stdout.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def recvline(\n    self: PipeManager,\n    numlines: int = 1,\n    drop: bool = True,\n    timeout: int = timeout_default,\n    optional: bool = False,\n) -&gt; bytes:\n    \"\"\"Receives numlines lines from the child process stdout.\n\n    Args:\n        numlines (int, optional): number of lines to receive. Defaults to 1.\n        drop (bool, optional): drop the line ending. Defaults to True.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n        optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n    Returns:\n        bytes: received lines from the child process stdout.\n    \"\"\"\n    return self.recvuntil(delims=b\"\\n\", occurences=numlines, drop=drop, timeout=timeout, optional=optional)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.recvuntil","title":"<code>recvuntil(delims, occurences=1, drop=False, timeout=timeout_default, optional=False)</code>","text":"<p>Receives data from the child process stdout until the delimiters are found.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <code>optional</code> <code>bool</code> <p>whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stdout.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def recvuntil(\n    self: PipeManager,\n    delims: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n    optional: bool = False,\n) -&gt; bytes:\n    \"\"\"Receives data from the child process stdout until the delimiters are found.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n        optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n    Returns:\n        bytes: received data from the child process stdout.\n    \"\"\"\n    return self._recvuntil(\n        delims=delims,\n        occurences=occurences,\n        drop=drop,\n        timeout=timeout,\n        stderr=False,\n        optional=optional,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.send","title":"<code>send(data)</code>","text":"<p>Sends data to the child process stdin.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to send.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of bytes sent.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>no stdin pipe of the child process.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def send(self: PipeManager, data: bytes) -&gt; int:\n    \"\"\"Sends data to the child process stdin.\n\n    Args:\n        data (bytes): data to send.\n\n    Returns:\n        int: number of bytes sent.\n\n    Raises:\n        RuntimeError: no stdin pipe of the child process.\n    \"\"\"\n    if not self._stdin_write:\n        raise RuntimeError(\"No stdin pipe of the child process\")\n\n    liblog.pipe(f\"Sending {len(data)} bytes to the child process: {data!r}\")\n\n    if isinstance(data, str):\n        liblog.warning(\"The input data is a string, converting to bytes\")\n        data = data.encode()\n\n    try:\n        number_bytes = os.write(self._stdin_write, data)\n    except OSError as e:\n        raise RuntimeError(\"Broken pipe. Is the child process still running?\") from e\n\n    return number_bytes\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.sendafter","title":"<code>sendafter(delims, data, occurences=1, drop=False, timeout=timeout_default, optional=False)</code>","text":"<p>Sends data to the child process stdin after the delimiters are found in the stdout.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>data</code> <code>bytes</code> <p>data to send.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <code>optional</code> <code>bool</code> <p>whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stdout.</p> <code>int</code> <code>int</code> <p>number of bytes sent.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def sendafter(\n    self: PipeManager,\n    delims: bytes,\n    data: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n    optional: bool = False,\n) -&gt; tuple[bytes, int]:\n    \"\"\"Sends data to the child process stdin after the delimiters are found in the stdout.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        data (bytes): data to send.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n        optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n    Returns:\n        bytes: received data from the child process stdout.\n        int: number of bytes sent.\n    \"\"\"\n    received = self.recvuntil(delims=delims, occurences=occurences, drop=drop, timeout=timeout, optional=optional)\n    sent = self.send(data)\n    return (received, sent)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.sendaftererr","title":"<code>sendaftererr(delims, data, occurences=1, drop=False, timeout=timeout_default, optional=False)</code>","text":"<p>Sends data to the child process stdin after the delimiters are found in stderr.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>data</code> <code>bytes</code> <p>data to send.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <code>optional</code> <code>bool</code> <p>whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stderr.</p> <code>int</code> <code>int</code> <p>number of bytes sent.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def sendaftererr(\n    self: PipeManager,\n    delims: bytes,\n    data: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n    optional: bool = False,\n) -&gt; tuple[bytes, int]:\n    \"\"\"Sends data to the child process stdin after the delimiters are found in stderr.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        data (bytes): data to send.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n        optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n    Returns:\n        bytes: received data from the child process stderr.\n        int: number of bytes sent.\n    \"\"\"\n    received = self.recverruntil(\n        delims=delims,\n        occurences=occurences,\n        drop=drop,\n        timeout=timeout,\n        optional=optional,\n    )\n    sent = self.send(data)\n    return (received, sent)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.sendline","title":"<code>sendline(data)</code>","text":"<p>Sends data to the child process stdin and append a newline.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>data to send.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>number of bytes sent.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def sendline(self: PipeManager, data: bytes) -&gt; int:\n    \"\"\"Sends data to the child process stdin and append a newline.\n\n    Args:\n        data (bytes): data to send.\n\n    Returns:\n        int: number of bytes sent.\n    \"\"\"\n    if isinstance(data, str):\n        liblog.warning(\"The input data is a string, converting to bytes\")\n        data = data.encode()\n    return self.send(data=data + b\"\\n\")\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.sendlineafter","title":"<code>sendlineafter(delims, data, occurences=1, drop=False, timeout=timeout_default, optional=False)</code>","text":"<p>Sends line to the child process stdin after the delimiters are found in the stdout.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>data</code> <code>bytes</code> <p>data to send.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <code>optional</code> <code>bool</code> <p>whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stdout.</p> <code>int</code> <code>int</code> <p>number of bytes sent.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def sendlineafter(\n    self: PipeManager,\n    delims: bytes,\n    data: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n    optional: bool = False,\n) -&gt; tuple[bytes, int]:\n    \"\"\"Sends line to the child process stdin after the delimiters are found in the stdout.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        data (bytes): data to send.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n        optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n    Returns:\n        bytes: received data from the child process stdout.\n        int: number of bytes sent.\n    \"\"\"\n    received = self.recvuntil(delims=delims, occurences=occurences, drop=drop, timeout=timeout, optional=optional)\n    sent = self.sendline(data)\n    return (received, sent)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/pipe_manager/#libdebug.commlink.pipe_manager.PipeManager.sendlineaftererr","title":"<code>sendlineaftererr(delims, data, occurences=1, drop=False, timeout=timeout_default, optional=False)</code>","text":"<p>Sends line to the child process stdin after the delimiters are found in the stderr.</p> <p>Parameters:</p> Name Type Description Default <code>delims</code> <code>bytes</code> <p>delimiters where to stop.</p> required <code>data</code> <code>bytes</code> <p>data to send.</p> required <code>occurences</code> <code>int</code> <p>number of delimiters to find. Defaults to 1.</p> <code>1</code> <code>drop</code> <code>bool</code> <p>drop the delimiter. Defaults to False.</p> <code>False</code> <code>timeout</code> <code>int</code> <p>timeout in seconds. Defaults to timeout_default.</p> <code>timeout_default</code> <code>optional</code> <code>bool</code> <p>whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>received data from the child process stderr.</p> <code>int</code> <code>int</code> <p>number of bytes sent.</p> Source code in <code>libdebug/commlink/pipe_manager.py</code> <pre><code>def sendlineaftererr(\n    self: PipeManager,\n    delims: bytes,\n    data: bytes,\n    occurences: int = 1,\n    drop: bool = False,\n    timeout: int = timeout_default,\n    optional: bool = False,\n) -&gt; tuple[bytes, int]:\n    \"\"\"Sends line to the child process stdin after the delimiters are found in the stderr.\n\n    Args:\n        delims (bytes): delimiters where to stop.\n        data (bytes): data to send.\n        occurences (int, optional): number of delimiters to find. Defaults to 1.\n        drop (bool, optional): drop the delimiter. Defaults to False.\n        timeout (int, optional): timeout in seconds. Defaults to timeout_default.\n        optional (bool, optional): whether to ignore the wait for the received input if the command is executed when the process is stopped. Defaults to False.\n\n    Returns:\n        bytes: received data from the child process stderr.\n        int: number of bytes sent.\n    \"\"\"\n    received = self.recverruntil(\n        delims=delims,\n        occurences=occurences,\n        drop=drop,\n        timeout=timeout,\n        optional=optional,\n    )\n    sent = self.sendline(data)\n    return (received, sent)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/std_wrapper/","title":"libdebug.commlink.std_wrapper","text":""},{"location":"from_pydoc/generated/commlink/std_wrapper/#libdebug.commlink.std_wrapper.StdWrapper","title":"<code>StdWrapper</code>","text":"<p>Wrapper around stderr/stdout to allow for custom write method.</p> Source code in <code>libdebug/commlink/std_wrapper.py</code> <pre><code>class StdWrapper:\n    \"\"\"Wrapper around stderr/stdout to allow for custom write method.\"\"\"\n\n    def __init__(self: StdWrapper, fd: object, terminal: LibTerminal) -&gt; None:\n        \"\"\"Initializes the StderrWrapper object.\"\"\"\n        self._fd: object = fd\n        self._terminal: LibTerminal = terminal\n\n    def write(self, payload: bytes | str) -&gt; int:\n        \"\"\"Overloads the write method to allow for custom behavior.\"\"\"\n        return self._terminal._write_manager(payload)\n\n    def __getattr__(self, k: any) -&gt; any:\n        \"\"\"Ensure that all other attributes are forwarded to the original file descriptor.\"\"\"\n        return getattr(self._fd, k)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/std_wrapper/#libdebug.commlink.std_wrapper.StdWrapper.__getattr__","title":"<code>__getattr__(k)</code>","text":"<p>Ensure that all other attributes are forwarded to the original file descriptor.</p> Source code in <code>libdebug/commlink/std_wrapper.py</code> <pre><code>def __getattr__(self, k: any) -&gt; any:\n    \"\"\"Ensure that all other attributes are forwarded to the original file descriptor.\"\"\"\n    return getattr(self._fd, k)\n</code></pre>"},{"location":"from_pydoc/generated/commlink/std_wrapper/#libdebug.commlink.std_wrapper.StdWrapper.__init__","title":"<code>__init__(fd, terminal)</code>","text":"<p>Initializes the StderrWrapper object.</p> Source code in <code>libdebug/commlink/std_wrapper.py</code> <pre><code>def __init__(self: StdWrapper, fd: object, terminal: LibTerminal) -&gt; None:\n    \"\"\"Initializes the StderrWrapper object.\"\"\"\n    self._fd: object = fd\n    self._terminal: LibTerminal = terminal\n</code></pre>"},{"location":"from_pydoc/generated/commlink/std_wrapper/#libdebug.commlink.std_wrapper.StdWrapper.write","title":"<code>write(payload)</code>","text":"<p>Overloads the write method to allow for custom behavior.</p> Source code in <code>libdebug/commlink/std_wrapper.py</code> <pre><code>def write(self, payload: bytes | str) -&gt; int:\n    \"\"\"Overloads the write method to allow for custom behavior.\"\"\"\n    return self._terminal._write_manager(payload)\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/","title":"libdebug.data.breakpoint","text":""},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint","title":"<code>Breakpoint</code>  <code>dataclass</code>","text":"<p>A breakpoint in the target process.</p> <p>Attributes:</p> Name Type Description <code>address</code> <code>int</code> <p>The address of the breakpoint in the target process.</p> <code>symbol</code> <code>str</code> <p>The symbol, if available, of the breakpoint in the target process.</p> <code>hit_count</code> <code>int</code> <p>The number of times this specific breakpoint has been hit.</p> <code>hardware</code> <code>bool</code> <p>Whether the breakpoint is a hardware breakpoint or not.</p> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>The callback defined by the user to execute when the breakpoint is hit.</p> <code>condition</code> <code>str</code> <p>The breakpoint condition. Available values are \"X\", \"W\", \"RW\". Supported only for hardware breakpoints.</p> <code>length</code> <code>int</code> <p>The length of the breakpoint area. Supported only for hardware breakpoints.</p> <code>enabled</code> <code>bool</code> <p>Whether the breakpoint is enabled or not.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>@dataclass\nclass Breakpoint:\n    \"\"\"A breakpoint in the target process.\n\n    Attributes:\n        address (int): The address of the breakpoint in the target process.\n        symbol (str): The symbol, if available, of the breakpoint in the target process.\n        hit_count (int): The number of times this specific breakpoint has been hit.\n        hardware (bool): Whether the breakpoint is a hardware breakpoint or not.\n        callback (Callable[[ThreadContext, Breakpoint], None]): The callback defined by the user to execute when the breakpoint is hit.\n        condition (str): The breakpoint condition. Available values are \"X\", \"W\", \"RW\". Supported only for hardware breakpoints.\n        length (int): The length of the breakpoint area. Supported only for hardware breakpoints.\n        enabled (bool): Whether the breakpoint is enabled or not.\n    \"\"\"\n\n    address: int = 0\n    symbol: str = \"\"\n    hit_count: int = 0\n    hardware: bool = False\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None\n    condition: str = \"x\"\n    length: int = 1\n    enabled: bool = True\n\n    _linked_thread_ids: list[int] = field(default_factory=list)\n    # The thread ID that hit the breakpoint\n\n    _disabled_for_step: bool = False\n    _changed: bool = False\n\n    def enable(self: Breakpoint) -&gt; None:\n        \"\"\"Enable the breakpoint.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = True\n        self._changed = True\n\n    def disable(self: Breakpoint) -&gt; None:\n        \"\"\"Disable the breakpoint.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = False\n        self._changed = True\n\n    def hit_on(self: Breakpoint, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the breakpoint has been hit on the given thread context.\"\"\"\n        if not self.enabled:\n            return False\n\n        internal_debugger = provide_internal_debugger(self)\n        internal_debugger._ensure_process_stopped()\n        return internal_debugger.resume_context.event_hit_ref.get(thread_context.thread_id) == self\n\n    def __hash__(self: Breakpoint) -&gt; int:\n        \"\"\"Hash the breakpoint by its address, so that it can be used in sets and maps correctly.\"\"\"\n        return hash(self.address)\n\n    def __eq__(self: Breakpoint, other: object) -&gt; bool:\n        \"\"\"Check if two breakpoints are equal.\"\"\"\n        return id(self) == id(other)\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two breakpoints are equal.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def __eq__(self: Breakpoint, other: object) -&gt; bool:\n    \"\"\"Check if two breakpoints are equal.\"\"\"\n    return id(self) == id(other)\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.__hash__","title":"<code>__hash__()</code>","text":"<p>Hash the breakpoint by its address, so that it can be used in sets and maps correctly.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def __hash__(self: Breakpoint) -&gt; int:\n    \"\"\"Hash the breakpoint by its address, so that it can be used in sets and maps correctly.\"\"\"\n    return hash(self.address)\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.disable","title":"<code>disable()</code>","text":"<p>Disable the breakpoint.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def disable(self: Breakpoint) -&gt; None:\n    \"\"\"Disable the breakpoint.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = False\n    self._changed = True\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.enable","title":"<code>enable()</code>","text":"<p>Enable the breakpoint.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def enable(self: Breakpoint) -&gt; None:\n    \"\"\"Enable the breakpoint.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = True\n    self._changed = True\n</code></pre>"},{"location":"from_pydoc/generated/data/breakpoint/#libdebug.data.breakpoint.Breakpoint.hit_on","title":"<code>hit_on(thread_context)</code>","text":"<p>Returns whether the breakpoint has been hit on the given thread context.</p> Source code in <code>libdebug/data/breakpoint.py</code> <pre><code>def hit_on(self: Breakpoint, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the breakpoint has been hit on the given thread context.\"\"\"\n    if not self.enabled:\n        return False\n\n    internal_debugger = provide_internal_debugger(self)\n    internal_debugger._ensure_process_stopped()\n    return internal_debugger.resume_context.event_hit_ref.get(thread_context.thread_id) == self\n</code></pre>"},{"location":"from_pydoc/generated/data/gdb_resume_event/","title":"libdebug.data.gdb_resume_event","text":""},{"location":"from_pydoc/generated/data/gdb_resume_event/#libdebug.data.gdb_resume_event.GdbResumeEvent","title":"<code>GdbResumeEvent</code>","text":"<p>This class handles the actions needed to resume the debugging session, after returning from GDB.</p> Source code in <code>libdebug/data/gdb_resume_event.py</code> <pre><code>class GdbResumeEvent:\n    \"\"\"This class handles the actions needed to resume the debugging session, after returning from GDB.\"\"\"\n\n    def __init__(\n        self: GdbResumeEvent,\n        internal_debugger: InternalDebugger,\n        lambda_function: callable[[], None],\n    ) -&gt; None:\n        \"\"\"Initializes the GdbResumeEvent.\n\n        Args:\n            internal_debugger (InternalDebugger): The internal debugger instance.\n            lambda_function (callable[[], None]): The blocking lambda function to wait on.\n        \"\"\"\n        self._internal_debugger = internal_debugger\n        self._lambda_function = lambda_function\n        self._joined = False\n\n    def join(self: GdbResumeEvent) -&gt; None:\n        \"\"\"Resumes the debugging session, blocking the script until GDB terminate and libdebug reattaches.\"\"\"\n        if self._joined:\n            raise RuntimeError(\"GdbResumeEvent already joined\")\n\n        self._lambda_function()\n        self._internal_debugger._resume_from_gdb()\n        self._joined = True\n</code></pre>"},{"location":"from_pydoc/generated/data/gdb_resume_event/#libdebug.data.gdb_resume_event.GdbResumeEvent.__init__","title":"<code>__init__(internal_debugger, lambda_function)</code>","text":"<p>Initializes the GdbResumeEvent.</p> <p>Parameters:</p> Name Type Description Default <code>internal_debugger</code> <code>InternalDebugger</code> <p>The internal debugger instance.</p> required <code>lambda_function</code> <code>callable[[], None]</code> <p>The blocking lambda function to wait on.</p> required Source code in <code>libdebug/data/gdb_resume_event.py</code> <pre><code>def __init__(\n    self: GdbResumeEvent,\n    internal_debugger: InternalDebugger,\n    lambda_function: callable[[], None],\n) -&gt; None:\n    \"\"\"Initializes the GdbResumeEvent.\n\n    Args:\n        internal_debugger (InternalDebugger): The internal debugger instance.\n        lambda_function (callable[[], None]): The blocking lambda function to wait on.\n    \"\"\"\n    self._internal_debugger = internal_debugger\n    self._lambda_function = lambda_function\n    self._joined = False\n</code></pre>"},{"location":"from_pydoc/generated/data/gdb_resume_event/#libdebug.data.gdb_resume_event.GdbResumeEvent.join","title":"<code>join()</code>","text":"<p>Resumes the debugging session, blocking the script until GDB terminate and libdebug reattaches.</p> Source code in <code>libdebug/data/gdb_resume_event.py</code> <pre><code>def join(self: GdbResumeEvent) -&gt; None:\n    \"\"\"Resumes the debugging session, blocking the script until GDB terminate and libdebug reattaches.\"\"\"\n    if self._joined:\n        raise RuntimeError(\"GdbResumeEvent already joined\")\n\n    self._lambda_function()\n    self._internal_debugger._resume_from_gdb()\n    self._joined = True\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map/","title":"libdebug.data.memory_map","text":""},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap","title":"<code>MemoryMap</code>  <code>dataclass</code>","text":"<p>A memory map of the target process.</p> <p>Attributes:</p> Name Type Description <code>start</code> <code>int</code> <p>The start address of the memory map.</p> <code>end</code> <code>int</code> <p>The end address of the memory map.</p> <code>permissions</code> <code>str</code> <p>The permissions of the memory map.</p> <code>size</code> <code>int</code> <p>The size of the memory map.</p> <code>offset</code> <code>int</code> <p>The relative offset of the memory map.</p> <code>backing_file</code> <code>str</code> <p>The backing file of the memory map, or the symbolic name of the memory map.</p> Source code in <code>libdebug/data/memory_map.py</code> <pre><code>@dataclass(frozen=True)\nclass MemoryMap:\n    \"\"\"A memory map of the target process.\n\n    Attributes:\n        start (int): The start address of the memory map.\n        end (int): The end address of the memory map.\n        permissions (str): The permissions of the memory map.\n        size (int): The size of the memory map.\n        offset (int): The relative offset of the memory map.\n        backing_file (str): The backing file of the memory map, or the symbolic name of the memory map.\n    \"\"\"\n\n    start: int = 0\n    end: int = 0\n    permissions: str = \"\"\n    size: int = 0\n\n    offset: int = 0\n    \"\"\"The relative offset of the memory map inside the backing file, if any.\"\"\"\n\n    backing_file: str = \"\"\n    \"\"\"The backing file of the memory map, such as 'libc.so.6', or the symbolic name of the memory map, such as '[stack]'.\"\"\"\n\n    @staticmethod\n    def parse(vmap: str) -&gt; MemoryMap:\n        \"\"\"Parses a memory map from a /proc/pid/maps string representation.\n\n        Args:\n            vmap (str): The string containing the memory map.\n\n        Returns:\n            MemoryMap: The parsed memory map.\n        \"\"\"\n        try:\n            address, permissions, offset, *_, backing_file = vmap.split(\" \", 6)\n            start = int(address.split(\"-\")[0], 16)\n            end = int(address.split(\"-\")[1], 16)\n            size = end - start\n            int_offset = int(offset, 16)\n            backing_file = backing_file.strip()\n            if not backing_file:\n                backing_file = f\"anon_{start:x}\"\n        except ValueError as e:\n            raise ValueError(\n                f\"Invalid memory map: {vmap}. Please specify a valid memory map.\",\n            ) from e\n\n        return MemoryMap(start, end, permissions, size, int_offset, backing_file)\n\n    @property\n    def base(self: MemoryMap) -&gt; int:\n        \"\"\"Alias for the start address of the memory map.\"\"\"\n        return self.start\n\n    def __repr__(self: MemoryMap) -&gt; str:\n        \"\"\"Return the string representation of the memory map.\"\"\"\n        return f\"MemoryMap(start={hex(self.start)}, end={hex(self.end)}, permissions={self.permissions}, size={hex(self.size)}, offset={hex(self.offset)}, backing_file={self.backing_file})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.backing_file","title":"<code>backing_file: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The backing file of the memory map, such as 'libc.so.6', or the symbolic name of the memory map, such as '[stack]'.</p>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.base","title":"<code>base: int</code>  <code>property</code>","text":"<p>Alias for the start address of the memory map.</p>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.offset","title":"<code>offset: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The relative offset of the memory map inside the backing file, if any.</p>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the string representation of the memory map.</p> Source code in <code>libdebug/data/memory_map.py</code> <pre><code>def __repr__(self: MemoryMap) -&gt; str:\n    \"\"\"Return the string representation of the memory map.\"\"\"\n    return f\"MemoryMap(start={hex(self.start)}, end={hex(self.end)}, permissions={self.permissions}, size={hex(self.size)}, offset={hex(self.offset)}, backing_file={self.backing_file})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map/#libdebug.data.memory_map.MemoryMap.parse","title":"<code>parse(vmap)</code>  <code>staticmethod</code>","text":"<p>Parses a memory map from a /proc/pid/maps string representation.</p> <p>Parameters:</p> Name Type Description Default <code>vmap</code> <code>str</code> <p>The string containing the memory map.</p> required <p>Returns:</p> Name Type Description <code>MemoryMap</code> <code>MemoryMap</code> <p>The parsed memory map.</p> Source code in <code>libdebug/data/memory_map.py</code> <pre><code>@staticmethod\ndef parse(vmap: str) -&gt; MemoryMap:\n    \"\"\"Parses a memory map from a /proc/pid/maps string representation.\n\n    Args:\n        vmap (str): The string containing the memory map.\n\n    Returns:\n        MemoryMap: The parsed memory map.\n    \"\"\"\n    try:\n        address, permissions, offset, *_, backing_file = vmap.split(\" \", 6)\n        start = int(address.split(\"-\")[0], 16)\n        end = int(address.split(\"-\")[1], 16)\n        size = end - start\n        int_offset = int(offset, 16)\n        backing_file = backing_file.strip()\n        if not backing_file:\n            backing_file = f\"anon_{start:x}\"\n    except ValueError as e:\n        raise ValueError(\n            f\"Invalid memory map: {vmap}. Please specify a valid memory map.\",\n        ) from e\n\n    return MemoryMap(start, end, permissions, size, int_offset, backing_file)\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map_list/","title":"libdebug.data.memory_map_list","text":""},{"location":"from_pydoc/generated/data/memory_map_list/#libdebug.data.memory_map_list.MemoryMapList","title":"<code>MemoryMapList</code>","text":"<p>               Bases: <code>list</code></p> <p>A list of memory maps of the target process.</p> Source code in <code>libdebug/data/memory_map_list.py</code> <pre><code>class MemoryMapList(list):\n    \"\"\"A list of memory maps of the target process.\"\"\"\n\n    def __init__(self: MemoryMapList, memory_maps: list[MemoryMap]) -&gt; None:\n        \"\"\"Initializes the MemoryMapList.\"\"\"\n        super().__init__(memory_maps)\n        self._internal_debugger = provide_internal_debugger(self)\n\n    def _search_by_address(self: MemoryMapList, address: int) -&gt; list[MemoryMap]:\n        for vmap in self:\n            if vmap.start &lt;= address &lt; vmap.end:\n                return [vmap]\n        return []\n\n    def _search_by_backing_file(self: MemoryMapList, backing_file: str) -&gt; list[MemoryMap]:\n        if backing_file in [\"binary\", self._internal_debugger._process_name]:\n            backing_file = self._internal_debugger._process_full_path\n\n        filtered_maps = []\n        unique_files = set()\n\n        for vmap in self:\n            if backing_file in vmap.backing_file:\n                filtered_maps.append(vmap)\n                unique_files.add(vmap.backing_file)\n\n        if len(unique_files) &gt; 1:\n            liblog.warning(\n                f\"The substring {backing_file} is present in multiple, different backing files. The address resolution cannot be accurate. The matching backing files are: {', '.join(unique_files)}.\",\n            )\n\n        return filtered_maps\n\n    def filter(self: MemoryMapList, value: int | str) -&gt; MemoryMapList[MemoryMap]:\n        \"\"\"Filters the memory maps according to the specified value.\n\n        If the value is an integer, it is treated as an address.\n        If the value is a string, it is treated as a backing file.\n\n        Args:\n            value (int | str): The value to search for.\n\n        Returns:\n            MemoryMapList[MemoryMap]: The memory maps matching the specified value.\n        \"\"\"\n        if isinstance(value, int):\n            filtered_maps = self._search_by_address(value)\n        elif isinstance(value, str):\n            filtered_maps = self._search_by_backing_file(value)\n        else:\n            raise TypeError(\"The value must be an integer or a string.\")\n\n        with extend_internal_debugger(self._internal_debugger):\n            return MemoryMapList(filtered_maps)\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the memory map list.\"\"\"\n        return hash(id(self))\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check if the memory map list is equal to another object.\"\"\"\n        return super().__eq__(other)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return the string representation of the memory map list.\"\"\"\n        return f\"MemoryMapList({super().__repr__()})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map_list/#libdebug.data.memory_map_list.MemoryMapList.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if the memory map list is equal to another object.</p> Source code in <code>libdebug/data/memory_map_list.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check if the memory map list is equal to another object.\"\"\"\n    return super().__eq__(other)\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map_list/#libdebug.data.memory_map_list.MemoryMapList.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the memory map list.</p> Source code in <code>libdebug/data/memory_map_list.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the memory map list.\"\"\"\n    return hash(id(self))\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map_list/#libdebug.data.memory_map_list.MemoryMapList.__init__","title":"<code>__init__(memory_maps)</code>","text":"<p>Initializes the MemoryMapList.</p> Source code in <code>libdebug/data/memory_map_list.py</code> <pre><code>def __init__(self: MemoryMapList, memory_maps: list[MemoryMap]) -&gt; None:\n    \"\"\"Initializes the MemoryMapList.\"\"\"\n    super().__init__(memory_maps)\n    self._internal_debugger = provide_internal_debugger(self)\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map_list/#libdebug.data.memory_map_list.MemoryMapList.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the string representation of the memory map list.</p> Source code in <code>libdebug/data/memory_map_list.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return the string representation of the memory map list.\"\"\"\n    return f\"MemoryMapList({super().__repr__()})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/memory_map_list/#libdebug.data.memory_map_list.MemoryMapList.filter","title":"<code>filter(value)</code>","text":"<p>Filters the memory maps according to the specified value.</p> <p>If the value is an integer, it is treated as an address. If the value is a string, it is treated as a backing file.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int | str</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>MemoryMapList[MemoryMap]</code> <p>MemoryMapList[MemoryMap]: The memory maps matching the specified value.</p> Source code in <code>libdebug/data/memory_map_list.py</code> <pre><code>def filter(self: MemoryMapList, value: int | str) -&gt; MemoryMapList[MemoryMap]:\n    \"\"\"Filters the memory maps according to the specified value.\n\n    If the value is an integer, it is treated as an address.\n    If the value is a string, it is treated as a backing file.\n\n    Args:\n        value (int | str): The value to search for.\n\n    Returns:\n        MemoryMapList[MemoryMap]: The memory maps matching the specified value.\n    \"\"\"\n    if isinstance(value, int):\n        filtered_maps = self._search_by_address(value)\n    elif isinstance(value, str):\n        filtered_maps = self._search_by_backing_file(value)\n    else:\n        raise TypeError(\"The value must be an integer or a string.\")\n\n    with extend_internal_debugger(self._internal_debugger):\n        return MemoryMapList(filtered_maps)\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/","title":"libdebug.data.register_holder","text":""},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder","title":"<code>RegisterHolder</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract class that holds the state of the registers of a process, providing setters and getters for them.</p> Source code in <code>libdebug/data/register_holder.py</code> <pre><code>class RegisterHolder(ABC):\n    \"\"\"An abstract class that holds the state of the registers of a process, providing setters and getters for them.\"\"\"\n\n    @abstractmethod\n    def apply_on_thread(self: RegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n        \"\"\"Applies the current register values to the specified thread target.\n\n        Args:\n            target (ThreadContext): The object to which the register values should be applied.\n            target_class (type): The class of the target object, needed to set the attributes.\n        \"\"\"\n\n    @abstractmethod\n    def apply_on_regs(self: RegisterHolder, target: object, target_class: type) -&gt; None:\n        \"\"\"Applies the current register values to the specified regs target.\n\n        Args:\n            target (object): The object to which the register values should be applied.\n            target_class (type): The class of the target object, needed to set the attributes.\n        \"\"\"\n\n    @abstractmethod\n    def poll(self: RegisterHolder, target: ThreadContext) -&gt; None:\n        \"\"\"Polls the register values from the specified target.\n\n        Args:\n            target (ThreadContext): The object from which the register values should be polled.\n        \"\"\"\n\n    @abstractmethod\n    def flush(self: RegisterHolder, source: ThreadContext) -&gt; None:\n        \"\"\"Flushes the register values from the specified source.\n\n        Args:\n            source (ThreadContext): The object from which the register values should be flushed.\n        \"\"\"\n\n    @abstractmethod\n    def provide_regs(self: RegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of registers, excluding the vector and fp registers.\"\"\"\n\n    @abstractmethod\n    def provide_vector_fp_regs(self: RegisterHolder) -&gt; list[tuple[str]]:\n        \"\"\"Provide the list of vector and floating point registers.\"\"\"\n\n    @abstractmethod\n    def provide_special_regs(self: RegisterHolder) -&gt; list[str]:\n        \"\"\"Provide the list of special registers, which are not intended for general-purpose use.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.apply_on_regs","title":"<code>apply_on_regs(target, target_class)</code>  <code>abstractmethod</code>","text":"<p>Applies the current register values to the specified regs target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>object</code> <p>The object to which the register values should be applied.</p> required <code>target_class</code> <code>type</code> <p>The class of the target object, needed to set the attributes.</p> required Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef apply_on_regs(self: RegisterHolder, target: object, target_class: type) -&gt; None:\n    \"\"\"Applies the current register values to the specified regs target.\n\n    Args:\n        target (object): The object to which the register values should be applied.\n        target_class (type): The class of the target object, needed to set the attributes.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.apply_on_thread","title":"<code>apply_on_thread(target, target_class)</code>  <code>abstractmethod</code>","text":"<p>Applies the current register values to the specified thread target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The object to which the register values should be applied.</p> required <code>target_class</code> <code>type</code> <p>The class of the target object, needed to set the attributes.</p> required Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef apply_on_thread(self: RegisterHolder, target: ThreadContext, target_class: type) -&gt; None:\n    \"\"\"Applies the current register values to the specified thread target.\n\n    Args:\n        target (ThreadContext): The object to which the register values should be applied.\n        target_class (type): The class of the target object, needed to set the attributes.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.flush","title":"<code>flush(source)</code>  <code>abstractmethod</code>","text":"<p>Flushes the register values from the specified source.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>ThreadContext</code> <p>The object from which the register values should be flushed.</p> required Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef flush(self: RegisterHolder, source: ThreadContext) -&gt; None:\n    \"\"\"Flushes the register values from the specified source.\n\n    Args:\n        source (ThreadContext): The object from which the register values should be flushed.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.poll","title":"<code>poll(target)</code>  <code>abstractmethod</code>","text":"<p>Polls the register values from the specified target.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>ThreadContext</code> <p>The object from which the register values should be polled.</p> required Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef poll(self: RegisterHolder, target: ThreadContext) -&gt; None:\n    \"\"\"Polls the register values from the specified target.\n\n    Args:\n        target (ThreadContext): The object from which the register values should be polled.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.provide_regs","title":"<code>provide_regs()</code>  <code>abstractmethod</code>","text":"<p>Provide the list of registers, excluding the vector and fp registers.</p> Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef provide_regs(self: RegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of registers, excluding the vector and fp registers.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.provide_special_regs","title":"<code>provide_special_regs()</code>  <code>abstractmethod</code>","text":"<p>Provide the list of special registers, which are not intended for general-purpose use.</p> Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef provide_special_regs(self: RegisterHolder) -&gt; list[str]:\n    \"\"\"Provide the list of special registers, which are not intended for general-purpose use.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/register_holder/#libdebug.data.register_holder.RegisterHolder.provide_vector_fp_regs","title":"<code>provide_vector_fp_regs()</code>  <code>abstractmethod</code>","text":"<p>Provide the list of vector and floating point registers.</p> Source code in <code>libdebug/data/register_holder.py</code> <pre><code>@abstractmethod\ndef provide_vector_fp_regs(self: RegisterHolder) -&gt; list[tuple[str]]:\n    \"\"\"Provide the list of vector and floating point registers.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/data/registers/","title":"libdebug.data.registers","text":""},{"location":"from_pydoc/generated/data/registers/#libdebug.data.registers.Registers","title":"<code>Registers</code>  <code>dataclass</code>","text":"<p>Abtract class that holds the state of the architectural-dependent registers of a process.</p> Source code in <code>libdebug/data/registers.py</code> <pre><code>@dataclass\nclass Registers:\n    \"\"\"Abtract class that holds the state of the architectural-dependent registers of a process.\"\"\"\n\n    def __init__(self: Registers, thread_id: int, generic_regs: list[str]) -&gt; None:\n        \"\"\"Initializes the Registers object.\"\"\"\n        self._internal_debugger = get_global_internal_debugger()\n        self._thread_id = thread_id\n        self._generic_regs = generic_regs\n\n    def __repr__(self: Registers) -&gt; str:\n        \"\"\"Returns a string representation of the object.\"\"\"\n        repr_str = f\"Registers(thread_id={self._thread_id})\"\n\n        attributes = self._generic_regs\n        max_len = max(len(attr) for attr in attributes) + 1\n\n        repr_str += \"\".join(f\"\\n  {attr + ':':&lt;{max_len}} {getattr(self, attr):#x}\" for attr in attributes)\n\n        return repr_str\n\n    def filter(self: Registers, value: float) -&gt; list[str]:\n        \"\"\"Filters the registers by value.\n\n        Args:\n            value (float): The value to search for.\n\n        Returns:\n            list[str]: A list of names of the registers containing the value.\n        \"\"\"\n        attributes = self.__class__.__dict__\n        return [attr for attr in attributes if getattr(self, attr) == value]\n</code></pre>"},{"location":"from_pydoc/generated/data/registers/#libdebug.data.registers.Registers.__init__","title":"<code>__init__(thread_id, generic_regs)</code>","text":"<p>Initializes the Registers object.</p> Source code in <code>libdebug/data/registers.py</code> <pre><code>def __init__(self: Registers, thread_id: int, generic_regs: list[str]) -&gt; None:\n    \"\"\"Initializes the Registers object.\"\"\"\n    self._internal_debugger = get_global_internal_debugger()\n    self._thread_id = thread_id\n    self._generic_regs = generic_regs\n</code></pre>"},{"location":"from_pydoc/generated/data/registers/#libdebug.data.registers.Registers.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the object.</p> Source code in <code>libdebug/data/registers.py</code> <pre><code>def __repr__(self: Registers) -&gt; str:\n    \"\"\"Returns a string representation of the object.\"\"\"\n    repr_str = f\"Registers(thread_id={self._thread_id})\"\n\n    attributes = self._generic_regs\n    max_len = max(len(attr) for attr in attributes) + 1\n\n    repr_str += \"\".join(f\"\\n  {attr + ':':&lt;{max_len}} {getattr(self, attr):#x}\" for attr in attributes)\n\n    return repr_str\n</code></pre>"},{"location":"from_pydoc/generated/data/registers/#libdebug.data.registers.Registers.filter","title":"<code>filter(value)</code>","text":"<p>Filters the registers by value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to search for.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: A list of names of the registers containing the value.</p> Source code in <code>libdebug/data/registers.py</code> <pre><code>def filter(self: Registers, value: float) -&gt; list[str]:\n    \"\"\"Filters the registers by value.\n\n    Args:\n        value (float): The value to search for.\n\n    Returns:\n        list[str]: A list of names of the registers containing the value.\n    \"\"\"\n    attributes = self.__class__.__dict__\n    return [attr for attr in attributes if getattr(self, attr) == value]\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/","title":"libdebug.data.signal_catcher","text":""},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher","title":"<code>SignalCatcher</code>  <code>dataclass</code>","text":"<p>Catch a signal raised by the target process.</p> <p>Attributes:</p> Name Type Description <code>signal_number</code> <code>int</code> <p>The signal number to catch.</p> <code>callback</code> <code>Callable[[ThreadContext, CaughtSignal], None]</code> <p>The callback defined by the user to execute when the signal is caught.</p> <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.</p> <code>enabled</code> <code>bool</code> <p>Whether the signal will be caught or not.</p> <code>hit_count</code> <code>int</code> <p>The number of times the signal has been caught.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>@dataclass\nclass SignalCatcher:\n    \"\"\"Catch a signal raised by the target process.\n\n    Attributes:\n        signal_number (int): The signal number to catch.\n        callback (Callable[[ThreadContext, CaughtSignal], None]): The callback defined by the user to execute when the signal is caught.\n        recursive (bool): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n        enabled (bool): Whether the signal will be caught or not.\n        hit_count (int): The number of times the signal has been caught.\n    \"\"\"\n\n    signal_number: int\n    callback: Callable[[ThreadContext, SignalCatcher], None]\n    recursive: bool = True\n    enabled: bool = True\n    hit_count: int = 0\n\n    def enable(self: SignalCatcher) -&gt; None:\n        \"\"\"Enable the signal catcher.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = True\n\n    def disable(self: SignalCatcher) -&gt; None:\n        \"\"\"Disable the signal catcher.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = False\n\n    def hit_on(self: SignalCatcher, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the signal catcher has been hit on the given thread context.\"\"\"\n        return self.enabled and thread_context.signal_number == self.signal_number\n\n    def __hash__(self: SignalCatcher) -&gt; int:\n        \"\"\"Return the hash of the signal catcher, based just on the signal number.\"\"\"\n        return hash(self.signal_number)\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the signal catcher, based just on the signal number.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>def __hash__(self: SignalCatcher) -&gt; int:\n    \"\"\"Return the hash of the signal catcher, based just on the signal number.\"\"\"\n    return hash(self.signal_number)\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher.disable","title":"<code>disable()</code>","text":"<p>Disable the signal catcher.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>def disable(self: SignalCatcher) -&gt; None:\n    \"\"\"Disable the signal catcher.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = False\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher.enable","title":"<code>enable()</code>","text":"<p>Enable the signal catcher.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>def enable(self: SignalCatcher) -&gt; None:\n    \"\"\"Enable the signal catcher.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = True\n</code></pre>"},{"location":"from_pydoc/generated/data/signal_catcher/#libdebug.data.signal_catcher.SignalCatcher.hit_on","title":"<code>hit_on(thread_context)</code>","text":"<p>Returns whether the signal catcher has been hit on the given thread context.</p> Source code in <code>libdebug/data/signal_catcher.py</code> <pre><code>def hit_on(self: SignalCatcher, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the signal catcher has been hit on the given thread context.\"\"\"\n    return self.enabled and thread_context.signal_number == self.signal_number\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol/","title":"libdebug.data.symbol","text":""},{"location":"from_pydoc/generated/data/symbol/#libdebug.data.symbol.Symbol","title":"<code>Symbol</code>  <code>dataclass</code>","text":"<p>A symbol in the target process.</p> <p>start (int): The start address of the symbol in the target process. end (int): The end address of the symbol in the target process. name (str): The name of the symbol in the target process. backing_file (str): The backing file of the symbol in the target process.</p> Source code in <code>libdebug/data/symbol.py</code> <pre><code>@dataclass\nclass Symbol:\n    \"\"\"A symbol in the target process.\n\n    start (int): The start address of the symbol in the target process.\n    end (int): The end address of the symbol in the target process.\n    name (str): The name of the symbol in the target process.\n    backing_file (str): The backing file of the symbol in the target process.\n    \"\"\"\n\n    start: int\n    end: int\n    name: str\n    backing_file: str\n\n    def __hash__(self: Symbol) -&gt; int:\n        \"\"\"Returns the hash of the symbol.\"\"\"\n        return hash((self.start, self.end, self.name, self.backing_file))\n\n    def __repr__(self: Symbol) -&gt; str:\n        \"\"\"Returns the string representation of the symbol.\"\"\"\n        return f\"Symbol(start={self.start:#x}, end={self.end:#x}, name={self.name}, backing_file={self.backing_file})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol/#libdebug.data.symbol.Symbol.__hash__","title":"<code>__hash__()</code>","text":"<p>Returns the hash of the symbol.</p> Source code in <code>libdebug/data/symbol.py</code> <pre><code>def __hash__(self: Symbol) -&gt; int:\n    \"\"\"Returns the hash of the symbol.\"\"\"\n    return hash((self.start, self.end, self.name, self.backing_file))\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol/#libdebug.data.symbol.Symbol.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the symbol.</p> Source code in <code>libdebug/data/symbol.py</code> <pre><code>def __repr__(self: Symbol) -&gt; str:\n    \"\"\"Returns the string representation of the symbol.\"\"\"\n    return f\"Symbol(start={self.start:#x}, end={self.end:#x}, name={self.name}, backing_file={self.backing_file})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol_list/","title":"libdebug.data.symbol_list","text":""},{"location":"from_pydoc/generated/data/symbol_list/#libdebug.data.symbol_list.SymbolList","title":"<code>SymbolList</code>","text":"<p>               Bases: <code>list</code></p> <p>A list of symbols in the target process.</p> Source code in <code>libdebug/data/symbol_list.py</code> <pre><code>class SymbolList(list):\n    \"\"\"A list of symbols in the target process.\"\"\"\n\n    def __init__(self: SymbolList, symbols: list[Symbol]) -&gt; None:\n        \"\"\"Initializes the SymbolDict.\"\"\"\n        super().__init__(symbols)\n\n    def _search_by_address(self: SymbolList, address: int) -&gt; list[Symbol]:\n        \"\"\"Searches for a symbol by address.\n\n        Args:\n            address (int): The address of the symbol to search for.\n\n        Returns:\n            list[Symbol]: The list of symbols that match the specified address.\n        \"\"\"\n        # Find the memory map that contains the address\n        if maps := get_global_internal_debugger().maps.filter(address):\n            address -= maps[0].start\n        else:\n            raise ValueError(\n                f\"Address {address:#x} does not belong to any memory map. You must specify an absolute address.\"\n            )\n        return [symbol for symbol in self if symbol.start &lt;= address &lt; symbol.end]\n\n    def _search_by_name(self: SymbolList, name: str) -&gt; list[Symbol]:\n        \"\"\"Searches for a symbol by name.\n\n        Args:\n            name (str): The name of the symbol to search for.\n\n        Returns:\n            list[Symbol]: The list of symbols that match the specified name.\n        \"\"\"\n        exact_match = []\n        no_exact_match = []\n        # We first want to list the symbols that exactly match the name\n        for symbol in self:\n            if symbol.name == name:\n                exact_match.append(symbol)\n            elif name in symbol.name:\n                no_exact_match.append(symbol)\n        return exact_match + no_exact_match\n\n    def filter(self: SymbolList, value: int | str) -&gt; SymbolList[Symbol]:\n        \"\"\"Filters the symbols according to the specified value.\n\n        If the value is an integer, it is treated as an address.\n        If the value is a string, it is treated as a symbol name.\n\n        Args:\n            value (int | str): The address or name of the symbol to find.\n\n        Returns:\n            SymbolList[Symbol]: The symbols matching the specified value.\n        \"\"\"\n        if isinstance(value, int):\n            filtered_symbols = self._search_by_address(value)\n        elif isinstance(value, str):\n            filtered_symbols = self._search_by_name(value)\n        else:\n            raise TypeError(\"The value must be an integer or a string.\")\n\n        return SymbolList(filtered_symbols)\n\n    def __getitem__(self: SymbolList, key: str) -&gt; Symbol:\n        \"\"\"Returns the symbol with the specified name.\"\"\"\n        symbols = [symbol for symbol in self if symbol.name == key]\n        if not symbols:\n            raise KeyError(f\"Symbol '{key}' not found.\")\n        return symbols\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the symbol list.\"\"\"\n        return hash(id(self))\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Check if the symbol list is equal to another object.\"\"\"\n        return super().__eq__(other)\n\n    def __repr__(self: SymbolList) -&gt; str:\n        \"\"\"Returns the string representation of the SymbolDict without the default factory.\"\"\"\n        return f\"SymbolList({super().__repr__()})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol_list/#libdebug.data.symbol_list.SymbolList.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if the symbol list is equal to another object.</p> Source code in <code>libdebug/data/symbol_list.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Check if the symbol list is equal to another object.\"\"\"\n    return super().__eq__(other)\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol_list/#libdebug.data.symbol_list.SymbolList.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Returns the symbol with the specified name.</p> Source code in <code>libdebug/data/symbol_list.py</code> <pre><code>def __getitem__(self: SymbolList, key: str) -&gt; Symbol:\n    \"\"\"Returns the symbol with the specified name.\"\"\"\n    symbols = [symbol for symbol in self if symbol.name == key]\n    if not symbols:\n        raise KeyError(f\"Symbol '{key}' not found.\")\n    return symbols\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol_list/#libdebug.data.symbol_list.SymbolList.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the symbol list.</p> Source code in <code>libdebug/data/symbol_list.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the symbol list.\"\"\"\n    return hash(id(self))\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol_list/#libdebug.data.symbol_list.SymbolList.__init__","title":"<code>__init__(symbols)</code>","text":"<p>Initializes the SymbolDict.</p> Source code in <code>libdebug/data/symbol_list.py</code> <pre><code>def __init__(self: SymbolList, symbols: list[Symbol]) -&gt; None:\n    \"\"\"Initializes the SymbolDict.\"\"\"\n    super().__init__(symbols)\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol_list/#libdebug.data.symbol_list.SymbolList.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns the string representation of the SymbolDict without the default factory.</p> Source code in <code>libdebug/data/symbol_list.py</code> <pre><code>def __repr__(self: SymbolList) -&gt; str:\n    \"\"\"Returns the string representation of the SymbolDict without the default factory.\"\"\"\n    return f\"SymbolList({super().__repr__()})\"\n</code></pre>"},{"location":"from_pydoc/generated/data/symbol_list/#libdebug.data.symbol_list.SymbolList.filter","title":"<code>filter(value)</code>","text":"<p>Filters the symbols according to the specified value.</p> <p>If the value is an integer, it is treated as an address. If the value is a string, it is treated as a symbol name.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>int | str</code> <p>The address or name of the symbol to find.</p> required <p>Returns:</p> Type Description <code>SymbolList[Symbol]</code> <p>SymbolList[Symbol]: The symbols matching the specified value.</p> Source code in <code>libdebug/data/symbol_list.py</code> <pre><code>def filter(self: SymbolList, value: int | str) -&gt; SymbolList[Symbol]:\n    \"\"\"Filters the symbols according to the specified value.\n\n    If the value is an integer, it is treated as an address.\n    If the value is a string, it is treated as a symbol name.\n\n    Args:\n        value (int | str): The address or name of the symbol to find.\n\n    Returns:\n        SymbolList[Symbol]: The symbols matching the specified value.\n    \"\"\"\n    if isinstance(value, int):\n        filtered_symbols = self._search_by_address(value)\n    elif isinstance(value, str):\n        filtered_symbols = self._search_by_name(value)\n    else:\n        raise TypeError(\"The value must be an integer or a string.\")\n\n    return SymbolList(filtered_symbols)\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/","title":"libdebug.data.syscall_handler","text":""},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler","title":"<code>SyscallHandler</code>  <code>dataclass</code>","text":"<p>Handle a syscall executed by the target process.</p> <p>Attributes:</p> Name Type Description <code>syscall_number</code> <code>int</code> <p>The syscall number to handle.</p> <code>on_enter_user</code> <code>Callable[[ThreadContext, int], None]</code> <p>The callback defined by the user to execute when the syscall is entered.</p> <code>on_exit_user</code> <code>Callable[[ThreadContext, int], None]</code> <p>The callback defined by the user to execute when the syscall is exited.</p> <code>on_enter_pprint</code> <code>Callable[[ThreadContext, int], None]</code> <p>The callback defined by the pretty print to execute when the syscall is entered.</p> <code>on_exit_pprint</code> <code>Callable[[ThreadContext, int], None]</code> <p>The callback defined by the pretty print to execute when the syscall is exited.</p> <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.</p> <code>enabled</code> <code>bool</code> <p>Whether the syscall will be handled or not.</p> <code>hit_count</code> <code>int</code> <p>The number of times the syscall has been handled.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>@dataclass\nclass SyscallHandler:\n    \"\"\"Handle a syscall executed by the target process.\n\n    Attributes:\n        syscall_number (int): The syscall number to handle.\n        on_enter_user (Callable[[ThreadContext, int], None]): The callback defined by the user to execute when the syscall is entered.\n        on_exit_user (Callable[[ThreadContext, int], None]): The callback defined by the user to execute when the syscall is exited.\n        on_enter_pprint (Callable[[ThreadContext, int], None]): The callback defined by the pretty print to execute when the syscall is entered.\n        on_exit_pprint (Callable[[ThreadContext, int], None]): The callback defined by the pretty print to execute when the syscall is exited.\n        recursive (bool): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n        enabled (bool): Whether the syscall will be handled or not.\n        hit_count (int): The number of times the syscall has been handled.\n    \"\"\"\n\n    syscall_number: int\n    on_enter_user: Callable[[ThreadContext, int], None]\n    on_exit_user: Callable[[ThreadContext, int], None]\n    on_enter_pprint: Callable[[ThreadContext, int, Any], None]\n    on_exit_pprint: Callable[[int | tuple[int, int]], None]\n    recursive: bool = False\n    enabled: bool = True\n    hit_count: int = 0\n\n    _has_entered: bool = False\n    _skip_exit: bool = False\n\n    def enable(self: SyscallHandler) -&gt; None:\n        \"\"\"Handle the syscall.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = True\n        self._has_entered = False\n\n    def disable(self: SyscallHandler) -&gt; None:\n        \"\"\"Unhandle the syscall.\"\"\"\n        provide_internal_debugger(self)._ensure_process_stopped()\n        self.enabled = False\n        self._has_entered = False\n\n    def hit_on(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the syscall handler has been hit on the given thread context.\"\"\"\n        return self.enabled and thread_context.syscall_number == self.syscall_number\n\n    def hit_on_enter(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the syscall handler has been hit during the syscall entry on the given thread context.\"\"\"\n        return self.enabled and thread_context.syscall_number == self.syscall_number and self._has_entered\n\n    def hit_on_exit(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n        \"\"\"Returns whether the syscall handler has been hit during the syscall exit on the given thread context.\"\"\"\n        return self.enabled and thread_context.syscall_number == self.syscall_number and not self._has_entered\n\n    def __hash__(self: SyscallHandler) -&gt; int:\n        \"\"\"Return the hash of the syscall handler, based just on the syscall number.\"\"\"\n        return hash(self.syscall_number)\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the syscall handler, based just on the syscall number.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def __hash__(self: SyscallHandler) -&gt; int:\n    \"\"\"Return the hash of the syscall handler, based just on the syscall number.\"\"\"\n    return hash(self.syscall_number)\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.disable","title":"<code>disable()</code>","text":"<p>Unhandle the syscall.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def disable(self: SyscallHandler) -&gt; None:\n    \"\"\"Unhandle the syscall.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = False\n    self._has_entered = False\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.enable","title":"<code>enable()</code>","text":"<p>Handle the syscall.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def enable(self: SyscallHandler) -&gt; None:\n    \"\"\"Handle the syscall.\"\"\"\n    provide_internal_debugger(self)._ensure_process_stopped()\n    self.enabled = True\n    self._has_entered = False\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.hit_on","title":"<code>hit_on(thread_context)</code>","text":"<p>Returns whether the syscall handler has been hit on the given thread context.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def hit_on(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the syscall handler has been hit on the given thread context.\"\"\"\n    return self.enabled and thread_context.syscall_number == self.syscall_number\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.hit_on_enter","title":"<code>hit_on_enter(thread_context)</code>","text":"<p>Returns whether the syscall handler has been hit during the syscall entry on the given thread context.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def hit_on_enter(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the syscall handler has been hit during the syscall entry on the given thread context.\"\"\"\n    return self.enabled and thread_context.syscall_number == self.syscall_number and self._has_entered\n</code></pre>"},{"location":"from_pydoc/generated/data/syscall_handler/#libdebug.data.syscall_handler.SyscallHandler.hit_on_exit","title":"<code>hit_on_exit(thread_context)</code>","text":"<p>Returns whether the syscall handler has been hit during the syscall exit on the given thread context.</p> Source code in <code>libdebug/data/syscall_handler.py</code> <pre><code>def hit_on_exit(self: SyscallHandler, thread_context: ThreadContext) -&gt; bool:\n    \"\"\"Returns whether the syscall handler has been hit during the syscall exit on the given thread context.\"\"\"\n    return self.enabled and thread_context.syscall_number == self.syscall_number and not self._has_entered\n</code></pre>"},{"location":"from_pydoc/generated/data/terminals/","title":"libdebug.data.terminals","text":""},{"location":"from_pydoc/generated/data/terminals/#libdebug.data.terminals.TerminalTypes","title":"<code>TerminalTypes</code>  <code>dataclass</code>","text":"<p>Terminal class for launching terminal emulators with predefined commands.</p> Source code in <code>libdebug/data/terminals.py</code> <pre><code>@dataclass\nclass TerminalTypes:\n    \"\"\"Terminal class for launching terminal emulators with predefined commands.\"\"\"\n\n    terminals: ClassVar[dict[str, list[str]]] = {\n        \"gnome-terminal-server\": [\"gnome-terminal\", \"--tab\", \"--\"],\n        \"konsole\": [\"konsole\", \"--new-tab\", \"-e\"],\n        \"xterm\": [\"xterm\", \"-e\"],\n        \"lxterminal\": [\"lxterminal\", \"-e\"],\n        \"mate-terminal\": [\"mate-terminal\", \"--tab\", \"-e\"],\n        \"tilix\": [\"tilix\", \"--action=app-new-session\", \"-e\"],\n        \"kgx\": [\"kgx\", \"--tab\", \"-e\"],\n        \"alacritty\": [\"alacritty\", \"-e\"],\n        \"kitty\": [\"kitty\", \"-e\"],\n        \"urxvt\": [\"urxvt\", \"-e\"],\n        \"tmux: server\": [\"tmux\", \"split-window\", \"-h\"],\n        \"xfce4-terminal\": [\"xfce4-terminal\", \"--tab\", \"-e\"],\n        \"terminator\": [\"terminator\", \"--new-tab\", \"-e\"],\n    }\n\n    @staticmethod\n    def get_command(terminal_name: str) -&gt; list[str]:\n        \"\"\"Retrieve the command list for a given terminal emulator name.\n\n        Args:\n        terminal_name (str): the name of the terminal emulator.\n\n        Returns:\n        list[str]: the command list for the terminal emulator, or an empty list if not found.\n        \"\"\"\n        return TerminalTypes.terminals.get(terminal_name, [])\n</code></pre>"},{"location":"from_pydoc/generated/data/terminals/#libdebug.data.terminals.TerminalTypes.get_command","title":"<code>get_command(terminal_name)</code>  <code>staticmethod</code>","text":"<p>Retrieve the command list for a given terminal emulator name.</p> <p>Args: terminal_name (str): the name of the terminal emulator.</p> <p>Returns: list[str]: the command list for the terminal emulator, or an empty list if not found.</p> Source code in <code>libdebug/data/terminals.py</code> <pre><code>@staticmethod\ndef get_command(terminal_name: str) -&gt; list[str]:\n    \"\"\"Retrieve the command list for a given terminal emulator name.\n\n    Args:\n    terminal_name (str): the name of the terminal emulator.\n\n    Returns:\n    list[str]: the command list for the terminal emulator, or an empty list if not found.\n    \"\"\"\n    return TerminalTypes.terminals.get(terminal_name, [])\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/","title":"libdebug.debugger.debugger","text":""},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger","title":"<code>Debugger</code>","text":"<p>The Debugger class is the main class of <code>libdebug</code>. It contains all the methods needed to run and interact with the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>class Debugger:\n    \"\"\"The Debugger class is the main class of `libdebug`. It contains all the methods needed to run and interact with the process.\"\"\"\n\n    _sentinel: object = object()\n    \"\"\"A sentinel object.\"\"\"\n\n    _internal_debugger: InternalDebugger\n    \"\"\"The internal debugger object.\"\"\"\n\n    def __init__(self: Debugger) -&gt; None:\n        pass\n\n    def post_init_(self: Debugger, internal_debugger: InternalDebugger) -&gt; None:\n        \"\"\"Do not use this constructor directly. Use the `debugger` function instead.\"\"\"\n        self._internal_debugger = internal_debugger\n        self._internal_debugger.start_up()\n\n    def run(self: Debugger, redirect_pipes: bool = True) -&gt; PipeManager | None:\n        \"\"\"Starts the process and waits for it to stop.\n\n        Args:\n            redirect_pipes (bool): Whether to hook and redirect the pipes of the process to a PipeManager.\n        \"\"\"\n        return self._internal_debugger.run(redirect_pipes)\n\n    def attach(self: Debugger, pid: int) -&gt; None:\n        \"\"\"Attaches to an existing process.\"\"\"\n        self._internal_debugger.attach(pid)\n\n    def detach(self: Debugger) -&gt; None:\n        \"\"\"Detaches from the process.\"\"\"\n        self._internal_debugger.detach()\n\n    def kill(self: Debugger) -&gt; None:\n        \"\"\"Kills the process.\"\"\"\n        self._internal_debugger.kill()\n\n    def terminate(self: Debugger) -&gt; None:\n        \"\"\"Interrupts the process, kills it and then terminates the background thread.\n\n        The debugger object will not be usable after this method is called.\n        This method should only be called to free up resources when the debugger object is no longer needed.\n        \"\"\"\n        self._internal_debugger.terminate()\n\n    def cont(self: Debugger) -&gt; None:\n        \"\"\"Continues the process.\"\"\"\n        self._internal_debugger.cont()\n\n    def interrupt(self: Debugger) -&gt; None:\n        \"\"\"Interrupts the process.\"\"\"\n        self._internal_debugger.interrupt()\n\n    def wait(self: Debugger) -&gt; None:\n        \"\"\"Waits for the process to stop.\"\"\"\n        self._internal_debugger.wait()\n\n    def print_maps(self: Debugger) -&gt; None:\n        \"\"\"Prints the memory maps of the process.\"\"\"\n        liblog.warning(\"The `print_maps` method is deprecated. Use `d.pprint_maps` instead.\")\n        self._internal_debugger.pprint_maps()\n\n    def pprint_maps(self: Debugger) -&gt; None:\n        \"\"\"Prints the memory maps of the process.\"\"\"\n        self._internal_debugger.pprint_maps()\n\n    def resolve_symbol(self: Debugger, symbol: str, file: str = \"binary\") -&gt; int:\n        \"\"\"Resolves the address of the specified symbol.\n\n        Args:\n            symbol (str): The symbol to resolve.\n            file (str): The backing file to resolve the symbol in. Defaults to \"binary\"\n\n        Returns:\n            int: The address of the symbol.\n        \"\"\"\n        return self._internal_debugger.resolve_symbol(symbol, file)\n\n    @property\n    def symbols(self: Debugger) -&gt; SymbolList[Symbol]:\n        \"\"\"Get the symbols of the process.\"\"\"\n        return self._internal_debugger.symbols\n\n    def breakpoint(\n        self: Debugger,\n        position: int | str,\n        hardware: bool = False,\n        condition: str = \"x\",\n        length: int = 1,\n        callback: None | bool | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Sets a breakpoint at the specified location.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.\n            condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n            length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n            callback (None | bool | Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the breakpoint is hit. If True, an empty callback will be set. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        return self._internal_debugger.breakpoint(position, hardware, condition, length, callback, file)\n\n    def watchpoint(\n        self: Debugger,\n        position: int | str,\n        condition: str = \"w\",\n        length: int = 1,\n        callback: None | bool | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            condition (str, optional): The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\"). Defaults to \"w\".\n            length (int, optional): The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.\n            callback (None | bool | Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the watchpoint is hit. If True, an empty callback will be set. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        return self._internal_debugger.breakpoint(\n            position,\n            hardware=True,\n            condition=condition,\n            length=length,\n            callback=callback,\n            file=file,\n        )\n\n    def catch_signal(\n        self: Debugger,\n        signal: int | str,\n        callback: None | bool | Callable[[ThreadContext, SignalCatcher], None] = None,\n        recursive: bool = False,\n    ) -&gt; SignalCatcher:\n        \"\"\"Catch a signal in the target process.\n\n        Args:\n            signal (int | str): The signal to catch. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be caught.\n            callback (None | bool | Callable[[ThreadContext, SignalCatcher], None], optional): A callback to be called when the signal is caught. If True, an empty callback will be set. Defaults to None.\n            recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n\n        Returns:\n            SignalCatcher: The SignalCatcher object.\n        \"\"\"\n        return self._internal_debugger.catch_signal(signal, callback, recursive)\n\n    def hijack_signal(\n        self: Debugger,\n        original_signal: int | str,\n        new_signal: int | str,\n        recursive: bool = False,\n    ) -&gt; SyscallHandler:\n        \"\"\"Hijack a signal in the target process.\n\n        Args:\n            original_signal (int | str): The signal to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be hijacked.\n            new_signal (int | str): The signal to hijack the original signal with.\n            recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n\n        Returns:\n            SignalCatcher: The SignalCatcher object.\n        \"\"\"\n        return self._internal_debugger.hijack_signal(original_signal, new_signal, recursive)\n\n    def handle_syscall(\n        self: Debugger,\n        syscall: int | str,\n        on_enter: None | bool | Callable[[ThreadContext, SyscallHandler], None] = None,\n        on_exit: None | bool | Callable[[ThreadContext, SyscallHandler], None] = None,\n        recursive: bool = False,\n    ) -&gt; SyscallHandler:\n        \"\"\"Handle a syscall in the target process.\n\n        Args:\n            syscall (int | str): The syscall name or number to handle. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be handled.\n            on_enter (None | bool |Callable[[ThreadContext, SyscallHandler], None], optional): The callback to execute when the syscall is entered. If True, an empty callback will be set. Defaults to None.\n            on_exit (None | bool | Callable[[ThreadContext, SyscallHandler], None], optional): The callback to execute when the syscall is exited. If True, an empty callback will be set. Defaults to None.\n            recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n\n        Returns:\n            SyscallHandler: The SyscallHandler object.\n        \"\"\"\n        return self._internal_debugger.handle_syscall(syscall, on_enter, on_exit, recursive)\n\n    def hijack_syscall(\n        self: Debugger,\n        original_syscall: int | str,\n        new_syscall: int | str,\n        recursive: bool = False,\n        **kwargs: int,\n    ) -&gt; SyscallHandler:\n        \"\"\"Hijacks a syscall in the target process.\n\n        Args:\n            original_syscall (int | str): The syscall name or number to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be hijacked.\n            new_syscall (int | str): The syscall name or number to hijack the original syscall with.\n            recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n            **kwargs: (int, optional): The arguments to pass to the new syscall.\n\n        Returns:\n            SyscallHandler: The SyscallHandler object.\n        \"\"\"\n        return self._internal_debugger.hijack_syscall(original_syscall, new_syscall, recursive, **kwargs)\n\n    def gdb(\n        self: Debugger,\n        migrate_breakpoints: bool = True,\n        open_in_new_process: bool = True,\n        blocking: bool = True,\n    ) -&gt; GdbResumeEvent:\n        \"\"\"Migrates the current debugging session to GDB.\n\n        Args:\n            migrate_breakpoints (bool): Whether to migrate over the breakpoints set in libdebug to GDB.\n            open_in_new_process (bool): Whether to attempt to open GDB in a new process instead of the current one.\n            blocking (bool): Whether to block the script until GDB is closed.\n        \"\"\"\n        return self._internal_debugger.gdb(migrate_breakpoints, open_in_new_process, blocking)\n\n    def r(self: Debugger, redirect_pipes: bool = True) -&gt; PipeManager | None:\n        \"\"\"Alias for the `run` method.\n\n        Starts the process and waits for it to stop.\n\n        Args:\n            redirect_pipes (bool): Whether to hook and redirect the pipes of the process to a PipeManager.\n        \"\"\"\n        return self._internal_debugger.run(redirect_pipes)\n\n    def c(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `cont` method.\n\n        Continues the process.\n        \"\"\"\n        self._internal_debugger.cont()\n\n    def int(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `interrupt` method.\n\n        Interrupts the process.\n        \"\"\"\n        self._internal_debugger.interrupt()\n\n    def w(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `wait` method.\n\n        Waits for the process to stop.\n        \"\"\"\n        self._internal_debugger.wait()\n\n    def bp(\n        self: Debugger,\n        position: int | str,\n        hardware: bool = False,\n        condition: str = \"x\",\n        length: int = 1,\n        callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Alias for the `breakpoint` method.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.\n            condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n            length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n            callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the breakpoint is hit. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        return self._internal_debugger.breakpoint(position, hardware, condition, length, callback, file)\n\n    def wp(\n        self: Debugger,\n        position: int | str,\n        condition: str = \"w\",\n        length: int = 1,\n        callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Alias for the `watchpoint` method.\n\n        Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            condition (str, optional): The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\"). Defaults to \"w\".\n            length (int, optional): The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.\n            callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the watchpoint is hit. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        return self._internal_debugger.breakpoint(\n            position,\n            hardware=True,\n            condition=condition,\n            length=length,\n            callback=callback,\n            file=file,\n        )\n\n    @property\n    def arch(self: Debugger) -&gt; str:\n        \"\"\"Get the architecture of the process.\"\"\"\n        return self._internal_debugger.arch\n\n    @arch.setter\n    def arch(self: Debugger, value: str) -&gt; None:\n        \"\"\"Set the architecture of the process.\"\"\"\n        self._internal_debugger.arch = map_arch(value)\n\n    @property\n    def kill_on_exit(self: Debugger) -&gt; bool:\n        \"\"\"Get whether the process will be killed when the debugger exits.\"\"\"\n        return self._internal_debugger.kill_on_exit\n\n    @kill_on_exit.setter\n    def kill_on_exit(self: Debugger, value: bool) -&gt; None:\n        if not isinstance(value, bool):\n            raise TypeError(\"kill_on_exit must be a boolean\")\n\n        self._internal_debugger.kill_on_exit = value\n\n    @property\n    def threads(self: Debugger) -&gt; list[ThreadContext]:\n        \"\"\"Get the list of threads in the process.\"\"\"\n        return self._internal_debugger.threads\n\n    @property\n    def breakpoints(self: Debugger) -&gt; dict[int, Breakpoint]:\n        \"\"\"Get the breakpoints set on the process.\"\"\"\n        return self._internal_debugger.breakpoints\n\n    @property\n    def handled_syscalls(self: InternalDebugger) -&gt; dict[int, SyscallHandler]:\n        \"\"\"Get the handled syscalls dictionary.\n\n        Returns:\n            dict[int, SyscallHandler]: the handled syscalls dictionary.\n        \"\"\"\n        return self._internal_debugger.handled_syscalls\n\n    @property\n    def caught_signals(self: InternalDebugger) -&gt; dict[int, SignalCatcher]:\n        \"\"\"Get the caught signals dictionary.\n\n        Returns:\n            dict[int, SignalCatcher]: the caught signals dictionary.\n        \"\"\"\n        return self._internal_debugger.caught_signals\n\n    @property\n    def maps(self: Debugger) -&gt; MemoryMapList[MemoryMap]:\n        \"\"\"Get the memory maps of the process.\"\"\"\n        return self._internal_debugger.maps\n\n    @property\n    def pprint_syscalls(self: Debugger) -&gt; bool:\n        \"\"\"Get the state of the pprint_syscalls flag.\n\n        Returns:\n            bool: True if the debugger should pretty print syscalls, False otherwise.\n        \"\"\"\n        return self._internal_debugger.pprint_syscalls\n\n    @pprint_syscalls.setter\n    def pprint_syscalls(self: Debugger, value: bool) -&gt; None:\n        \"\"\"Set the state of the pprint_syscalls flag.\n\n        Args:\n            value (bool): the value to set.\n        \"\"\"\n        if not isinstance(value, bool):\n            raise TypeError(\"pprint_syscalls must be a boolean\")\n        if value:\n            self._internal_debugger.enable_pretty_print()\n        else:\n            self._internal_debugger.disable_pretty_print()\n\n        self._internal_debugger.pprint_syscalls = value\n\n    @contextmanager\n    def pprint_syscalls_context(self: Debugger, value: bool) -&gt; ...:\n        \"\"\"A context manager to temporarily change the state of the pprint_syscalls flag.\n\n        Args:\n            value (bool): the value to set.\n        \"\"\"\n        old_value = self.pprint_syscalls\n        self.pprint_syscalls = value\n        yield\n        self.pprint_syscalls = old_value\n\n    @property\n    def syscalls_to_pprint(self: Debugger) -&gt; list[str] | None:\n        \"\"\"Get the syscalls to pretty print.\n\n        Returns:\n            list[str]: The syscalls to pretty print.\n        \"\"\"\n        if self._internal_debugger.syscalls_to_pprint is None:\n            return None\n        else:\n            return [\n                resolve_syscall_name(self._internal_debugger.arch, v)\n                for v in self._internal_debugger.syscalls_to_pprint\n            ]\n\n    @syscalls_to_pprint.setter\n    def syscalls_to_pprint(self: Debugger, value: list[int | str] | None) -&gt; None:\n        \"\"\"Get the syscalls to pretty print.\n\n        Args:\n            value (list[int | str] | None): The syscalls to pretty print.\n        \"\"\"\n        if value is None:\n            self._internal_debugger.syscalls_to_pprint = None\n        elif isinstance(value, list):\n            self._internal_debugger.syscalls_to_pprint = [\n                v if isinstance(v, int) else resolve_syscall_number(self._internal_debugger.arch, v) for v in value\n            ]\n        else:\n            raise ValueError(\n                \"syscalls_to_pprint must be a list of integers or strings or None.\",\n            )\n        if self._internal_debugger.pprint_syscalls:\n            self._internal_debugger.enable_pretty_print()\n\n    @property\n    def syscalls_to_not_pprint(self: Debugger) -&gt; list[str] | None:\n        \"\"\"Get the syscalls to not pretty print.\n\n        Returns:\n            list[str]: The syscalls to not pretty print.\n        \"\"\"\n        if self._internal_debugger.syscalls_to_not_pprint is None:\n            return None\n        else:\n            return [\n                resolve_syscall_name(self._internal_debugger.arch, v)\n                for v in self._internal_debugger.syscalls_to_not_pprint\n            ]\n\n    @syscalls_to_not_pprint.setter\n    def syscalls_to_not_pprint(self: Debugger, value: list[int | str] | None) -&gt; None:\n        \"\"\"Get the syscalls to not pretty print.\n\n        Args:\n            value (list[int | str] | None): The syscalls to not pretty print.\n        \"\"\"\n        if value is None:\n            self._internal_debugger.syscalls_to_not_pprint = None\n        elif isinstance(value, list):\n            self._internal_debugger.syscalls_to_not_pprint = [\n                v if isinstance(v, int) else resolve_syscall_number(self._internal_debugger.arch, v) for v in value\n            ]\n        else:\n            raise ValueError(\n                \"syscalls_to_not_pprint must be a list of integers or strings or None.\",\n            )\n        if self._internal_debugger.pprint_syscalls:\n            self._internal_debugger.enable_pretty_print()\n\n    @property\n    def signals_to_block(self: Debugger) -&gt; list[str]:\n        \"\"\"Get the signals to not forward to the process.\n\n        Returns:\n            list[str]: The signals to block.\n        \"\"\"\n        return [resolve_signal_name(v) for v in self._internal_debugger.signals_to_block]\n\n    @signals_to_block.setter\n    def signals_to_block(self: Debugger, signals: list[int | str]) -&gt; None:\n        \"\"\"Set the signal to not forward to the process.\n\n        Args:\n            signals (list[int | str]): The signals to block.\n        \"\"\"\n        if not isinstance(signals, list):\n            raise TypeError(\"signals_to_block must be a list of integers or strings\")\n\n        signals = [v if isinstance(v, int) else resolve_signal_number(v) for v in signals]\n\n        if not set(signals).issubset(get_all_signal_numbers()):\n            raise ValueError(\"Invalid signal number.\")\n\n        self._internal_debugger.signals_to_block = signals\n\n    @property\n    def fast_memory(self: Debugger) -&gt; bool:\n        \"\"\"Get the state of the fast_memory flag.\n\n        It is used to determine if the debugger should use a faster memory access method.\n\n        Returns:\n            bool: True if the debugger should use a faster memory access method, False otherwise.\n        \"\"\"\n        return self._internal_debugger.fast_memory\n\n    @fast_memory.setter\n    def fast_memory(self: Debugger, value: bool) -&gt; None:\n        \"\"\"Set the state of the fast_memory flag.\n\n        It is used to determine if the debugger should use a faster memory access method.\n\n        Args:\n            value (bool): the value to set.\n        \"\"\"\n        if not isinstance(value, bool):\n            raise TypeError(\"fast_memory must be a boolean\")\n        self._internal_debugger.fast_memory = value\n\n    @property\n    def instruction_pointer(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's instruction pointer.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].instruction_pointer\n\n    @instruction_pointer.setter\n    def instruction_pointer(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's instruction pointer.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].instruction_pointer = value\n\n    @property\n    def syscall_arg0(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's syscall argument 0.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].syscall_arg0\n\n    @syscall_arg0.setter\n    def syscall_arg0(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's syscall argument 0.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].syscall_arg0 = value\n\n    @property\n    def syscall_arg1(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's syscall argument 1.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].syscall_arg1\n\n    @syscall_arg1.setter\n    def syscall_arg1(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's syscall argument 1.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].syscall_arg1 = value\n\n    @property\n    def syscall_arg2(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's syscall argument 2.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].syscall_arg2\n\n    @syscall_arg2.setter\n    def syscall_arg2(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's syscall argument 2.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].syscall_arg2 = value\n\n    @property\n    def syscall_arg3(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's syscall argument 3.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].syscall_arg3\n\n    @syscall_arg3.setter\n    def syscall_arg3(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's syscall argument 3.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].syscall_arg3 = value\n\n    @property\n    def syscall_arg4(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's syscall argument 4.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].syscall_arg4\n\n    @syscall_arg4.setter\n    def syscall_arg4(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's syscall argument 4.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].syscall_arg4 = value\n\n    @property\n    def syscall_arg5(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's syscall argument 5.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].syscall_arg5\n\n    @syscall_arg5.setter\n    def syscall_arg5(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's syscall argument 5.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].syscall_arg5 = value\n\n    @property\n    def syscall_number(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's syscall number.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].syscall_number\n\n    @syscall_number.setter\n    def syscall_number(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's syscall number.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].syscall_number = value\n\n    @property\n    def syscall_return(self: Debugger) -&gt; int:\n        \"\"\"Get the main thread's syscall return value.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].syscall_return\n\n    @syscall_return.setter\n    def syscall_return(self: Debugger, value: int) -&gt; None:\n        \"\"\"Set the main thread's syscall return value.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].syscall_return = value\n\n    @property\n    def regs(self: Debugger) -&gt; Registers:\n        \"\"\"Get the main thread's registers.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].regs\n\n    @property\n    def dead(self: Debugger) -&gt; bool:\n        \"\"\"Whether the process is dead.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].dead\n\n    @property\n    def memory(self: Debugger) -&gt; AbstractMemoryView:\n        \"\"\"The memory view of the process.\"\"\"\n        return self._internal_debugger.memory\n\n    @property\n    def mem(self: Debugger) -&gt; AbstractMemoryView:\n        \"\"\"Alias for the `memory` property.\n\n        Get the memory view of the process.\n        \"\"\"\n        return self._internal_debugger.memory\n\n    @property\n    def process_id(self: Debugger) -&gt; int:\n        \"\"\"The process ID.\"\"\"\n        return self._internal_debugger.process_id\n\n    @property\n    def pid(self: Debugger) -&gt; int:\n        \"\"\"Alias for `process_id` property.\n\n        The process ID.\n        \"\"\"\n        return self._internal_debugger.process_id\n\n    @property\n    def thread_id(self: Debugger) -&gt; int:\n        \"\"\"The thread ID of the main thread.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].tid\n\n    @property\n    def tid(self: Debugger) -&gt; int:\n        \"\"\"Alias for `thread_id` property.\n\n        The thread ID of the main thread.\n        \"\"\"\n        return self._thread_id\n\n    @property\n    def running(self: Debugger) -&gt; bool:\n        \"\"\"Whether the process is running.\"\"\"\n        return self._internal_debugger.running\n\n    @property\n    def saved_ip(self: Debugger) -&gt; int:\n        \"\"\"Get the saved instruction pointer of the main thread.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].saved_ip\n\n    @property\n    def exit_code(self: Debugger) -&gt; int | None:\n        \"\"\"The main thread's exit code.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].exit_code\n\n    @property\n    def exit_signal(self: Debugger) -&gt; str | None:\n        \"\"\"The main thread's exit signal.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].exit_signal\n\n    @property\n    def signal(self: Debugger) -&gt; str | None:\n        \"\"\"The signal to be forwarded to the main thread.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].signal\n\n    @signal.setter\n    def signal(self: Debugger, signal: str | int) -&gt; None:\n        \"\"\"Set the signal to forward to the main thread.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].signal = signal\n\n    @property\n    def signal_number(self: Debugger) -&gt; int | None:\n        \"\"\"The signal number to be forwarded to the main thread.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].signal_number\n\n    def backtrace(self: Debugger, as_symbols: bool = False) -&gt; list:\n        \"\"\"Returns the current backtrace of the main thread.\n\n        Args:\n            as_symbols (bool, optional): Whether to return the backtrace as symbols\n        \"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        return self.threads[0].backtrace(as_symbols)\n\n    def pprint_backtrace(self: Debugger) -&gt; None:\n        \"\"\"Pretty pints the current backtrace of the main thread.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].pprint_backtrace()\n\n    def pprint_registers(self: Debugger) -&gt; None:\n        \"\"\"Pretty prints the main thread's registers.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].pprint_registers()\n\n    def pprint_regs(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `pprint_registers` method.\n\n        Pretty prints the main thread's registers.\n        \"\"\"\n        self.pprint_registers()\n\n    def pprint_registers_all(self: Debugger) -&gt; None:\n        \"\"\"Pretty prints all the main thread's registers.\"\"\"\n        if not self.threads:\n            raise ValueError(\"No threads available.\")\n        self.threads[0].pprint_registers_all()\n\n    def pprint_regs_all(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `pprint_registers_all` method.\n\n        Pretty prints all the main thread's registers.\n        \"\"\"\n        self.pprint_registers_all()\n\n    def step(self: Debugger) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\"\"\"\n        self._internal_debugger.step(self)\n\n    def step_until(\n        self: Debugger,\n        position: int | str,\n        max_steps: int = -1,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Executes instructions of the process until the specified location is reached.\n\n        Args:\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        self._internal_debugger.step_until(self, position, max_steps, file)\n\n    def finish(self: Debugger, heuristic: str = \"backtrace\") -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self._internal_debugger.finish(self, heuristic=heuristic)\n\n    def next(self: Debugger) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self._internal_debugger.next(self)\n\n    def si(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `step` method.\n\n        Executes a single instruction of the process.\n        \"\"\"\n        self._internal_debugger.step(self)\n\n    def su(\n        self: Debugger,\n        position: int | str,\n        max_steps: int = -1,\n    ) -&gt; None:\n        \"\"\"Alias for the `step_until` method.\n\n        Executes instructions of the process until the specified location is reached.\n\n        Args:\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n        \"\"\"\n        self._internal_debugger.step_until(self, position, max_steps)\n\n    def fin(self: Debugger, heuristic: str = \"backtrace\") -&gt; None:\n        \"\"\"Alias for the `finish` method. Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self._internal_debugger.finish(self, heuristic)\n\n    def ni(self: Debugger) -&gt; None:\n        \"\"\"Alias for the `next` method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self._internal_debugger.next(self)\n\n    def __repr__(self: Debugger) -&gt; str:\n        \"\"\"Return the string representation of the `Debugger` object.\"\"\"\n        repr_str = \"Debugger(\"\n        repr_str += f\"argv = {self._internal_debugger.argv}, \"\n        repr_str += f\"aslr = {self._internal_debugger.aslr_enabled}, \"\n        repr_str += f\"env = {self._internal_debugger.env}, \"\n        repr_str += f\"escape_antidebug = {self._internal_debugger.escape_antidebug}, \"\n        repr_str += f\"continue_to_binary_entrypoint = {self._internal_debugger.autoreach_entrypoint}, \"\n        repr_str += f\"auto_interrupt_on_command = {self._internal_debugger.auto_interrupt_on_command}, \"\n        repr_str += f\"fast_memory = {self._internal_debugger.fast_memory}, \"\n        repr_str += f\"kill_on_exit = {self._internal_debugger.kill_on_exit})\\n\"\n        repr_str += f\"  Architecture: {self.arch}\\n\"\n        repr_str += \"  Threads:\"\n        for thread in self.threads:\n            repr_str += f\"\\n    ({thread.tid}, {'dead' if thread.dead else 'alive'}) \"\n            repr_str += f\"ip: {thread.instruction_pointer:#x}\"\n        return repr_str\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.arch","title":"<code>arch: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the architecture of the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.breakpoints","title":"<code>breakpoints: dict[int, Breakpoint]</code>  <code>property</code>","text":"<p>Get the breakpoints set on the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.caught_signals","title":"<code>caught_signals: dict[int, SignalCatcher]</code>  <code>property</code>","text":"<p>Get the caught signals dictionary.</p> <p>Returns:</p> Type Description <code>dict[int, SignalCatcher]</code> <p>dict[int, SignalCatcher]: the caught signals dictionary.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.dead","title":"<code>dead: bool</code>  <code>property</code>","text":"<p>Whether the process is dead.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.exit_code","title":"<code>exit_code: int | None</code>  <code>property</code>","text":"<p>The main thread's exit code.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.exit_signal","title":"<code>exit_signal: str | None</code>  <code>property</code>","text":"<p>The main thread's exit signal.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.fast_memory","title":"<code>fast_memory: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get the state of the fast_memory flag.</p> <p>It is used to determine if the debugger should use a faster memory access method.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the debugger should use a faster memory access method, False otherwise.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.handled_syscalls","title":"<code>handled_syscalls: dict[int, SyscallHandler]</code>  <code>property</code>","text":"<p>Get the handled syscalls dictionary.</p> <p>Returns:</p> Type Description <code>dict[int, SyscallHandler]</code> <p>dict[int, SyscallHandler]: the handled syscalls dictionary.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.instruction_pointer","title":"<code>instruction_pointer: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's instruction pointer.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.kill_on_exit","title":"<code>kill_on_exit: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get whether the process will be killed when the debugger exits.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.maps","title":"<code>maps: MemoryMapList[MemoryMap]</code>  <code>property</code>","text":"<p>Get the memory maps of the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.mem","title":"<code>mem: AbstractMemoryView</code>  <code>property</code>","text":"<p>Alias for the <code>memory</code> property.</p> <p>Get the memory view of the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.memory","title":"<code>memory: AbstractMemoryView</code>  <code>property</code>","text":"<p>The memory view of the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pid","title":"<code>pid: int</code>  <code>property</code>","text":"<p>Alias for <code>process_id</code> property.</p> <p>The process ID.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_syscalls","title":"<code>pprint_syscalls: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get the state of the pprint_syscalls flag.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the debugger should pretty print syscalls, False otherwise.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.process_id","title":"<code>process_id: int</code>  <code>property</code>","text":"<p>The process ID.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.regs","title":"<code>regs: Registers</code>  <code>property</code>","text":"<p>Get the main thread's registers.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Whether the process is running.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.saved_ip","title":"<code>saved_ip: int</code>  <code>property</code>","text":"<p>Get the saved instruction pointer of the main thread.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.signal","title":"<code>signal: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>The signal to be forwarded to the main thread.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.signal_number","title":"<code>signal_number: int | None</code>  <code>property</code>","text":"<p>The signal number to be forwarded to the main thread.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.signals_to_block","title":"<code>signals_to_block: list[str]</code>  <code>property</code> <code>writable</code>","text":"<p>Get the signals to not forward to the process.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The signals to block.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.symbols","title":"<code>symbols: SymbolList[Symbol]</code>  <code>property</code>","text":"<p>Get the symbols of the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscall_arg0","title":"<code>syscall_arg0: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's syscall argument 0.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscall_arg1","title":"<code>syscall_arg1: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's syscall argument 1.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscall_arg2","title":"<code>syscall_arg2: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's syscall argument 2.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscall_arg3","title":"<code>syscall_arg3: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's syscall argument 3.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscall_arg4","title":"<code>syscall_arg4: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's syscall argument 4.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscall_arg5","title":"<code>syscall_arg5: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's syscall argument 5.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscall_number","title":"<code>syscall_number: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's syscall number.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscall_return","title":"<code>syscall_return: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the main thread's syscall return value.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscalls_to_not_pprint","title":"<code>syscalls_to_not_pprint: list[str] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the syscalls to not pretty print.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>list[str]: The syscalls to not pretty print.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.syscalls_to_pprint","title":"<code>syscalls_to_pprint: list[str] | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the syscalls to pretty print.</p> <p>Returns:</p> Type Description <code>list[str] | None</code> <p>list[str]: The syscalls to pretty print.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.thread_id","title":"<code>thread_id: int</code>  <code>property</code>","text":"<p>The thread ID of the main thread.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.threads","title":"<code>threads: list[ThreadContext]</code>  <code>property</code>","text":"<p>Get the list of threads in the process.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.tid","title":"<code>tid: int</code>  <code>property</code>","text":"<p>Alias for <code>thread_id</code> property.</p> <p>The thread ID of the main thread.</p>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.__repr__","title":"<code>__repr__()</code>","text":"<p>Return the string representation of the <code>Debugger</code> object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def __repr__(self: Debugger) -&gt; str:\n    \"\"\"Return the string representation of the `Debugger` object.\"\"\"\n    repr_str = \"Debugger(\"\n    repr_str += f\"argv = {self._internal_debugger.argv}, \"\n    repr_str += f\"aslr = {self._internal_debugger.aslr_enabled}, \"\n    repr_str += f\"env = {self._internal_debugger.env}, \"\n    repr_str += f\"escape_antidebug = {self._internal_debugger.escape_antidebug}, \"\n    repr_str += f\"continue_to_binary_entrypoint = {self._internal_debugger.autoreach_entrypoint}, \"\n    repr_str += f\"auto_interrupt_on_command = {self._internal_debugger.auto_interrupt_on_command}, \"\n    repr_str += f\"fast_memory = {self._internal_debugger.fast_memory}, \"\n    repr_str += f\"kill_on_exit = {self._internal_debugger.kill_on_exit})\\n\"\n    repr_str += f\"  Architecture: {self.arch}\\n\"\n    repr_str += \"  Threads:\"\n    for thread in self.threads:\n        repr_str += f\"\\n    ({thread.tid}, {'dead' if thread.dead else 'alive'}) \"\n        repr_str += f\"ip: {thread.instruction_pointer:#x}\"\n    return repr_str\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.attach","title":"<code>attach(pid)</code>","text":"<p>Attaches to an existing process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def attach(self: Debugger, pid: int) -&gt; None:\n    \"\"\"Attaches to an existing process.\"\"\"\n    self._internal_debugger.attach(pid)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.backtrace","title":"<code>backtrace(as_symbols=False)</code>","text":"<p>Returns the current backtrace of the main thread.</p> <p>Parameters:</p> Name Type Description Default <code>as_symbols</code> <code>bool</code> <p>Whether to return the backtrace as symbols</p> <code>False</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def backtrace(self: Debugger, as_symbols: bool = False) -&gt; list:\n    \"\"\"Returns the current backtrace of the main thread.\n\n    Args:\n        as_symbols (bool, optional): Whether to return the backtrace as symbols\n    \"\"\"\n    if not self.threads:\n        raise ValueError(\"No threads available.\")\n    return self.threads[0].backtrace(as_symbols)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.bp","title":"<code>bp(position, hardware=False, condition='x', length=1, callback=None, file='hybrid')</code>","text":"<p>Alias for the <code>breakpoint</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>hardware</code> <code>bool</code> <p>Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.</p> <code>False</code> <code>condition</code> <code>str</code> <p>The trigger condition for the breakpoint. Defaults to None.</p> <code>'x'</code> <code>length</code> <code>int</code> <p>The length of the breakpoint. Only for watchpoints. Defaults to 1.</p> <code>1</code> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the breakpoint is hit. Defaults to None.</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def bp(\n    self: Debugger,\n    position: int | str,\n    hardware: bool = False,\n    condition: str = \"x\",\n    length: int = 1,\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Alias for the `breakpoint` method.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.\n        condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n        length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n        callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the breakpoint is hit. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n    \"\"\"\n    return self._internal_debugger.breakpoint(position, hardware, condition, length, callback, file)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.breakpoint","title":"<code>breakpoint(position, hardware=False, condition='x', length=1, callback=None, file='hybrid')</code>","text":"<p>Sets a breakpoint at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>hardware</code> <code>bool</code> <p>Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.</p> <code>False</code> <code>condition</code> <code>str</code> <p>The trigger condition for the breakpoint. Defaults to None.</p> <code>'x'</code> <code>length</code> <code>int</code> <p>The length of the breakpoint. Only for watchpoints. Defaults to 1.</p> <code>1</code> <code>callback</code> <code>None | bool | Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the breakpoint is hit. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def breakpoint(\n    self: Debugger,\n    position: int | str,\n    hardware: bool = False,\n    condition: str = \"x\",\n    length: int = 1,\n    callback: None | bool | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Sets a breakpoint at the specified location.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.\n        condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n        length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n        callback (None | bool | Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the breakpoint is hit. If True, an empty callback will be set. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n    \"\"\"\n    return self._internal_debugger.breakpoint(position, hardware, condition, length, callback, file)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.c","title":"<code>c()</code>","text":"<p>Alias for the <code>cont</code> method.</p> <p>Continues the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def c(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `cont` method.\n\n    Continues the process.\n    \"\"\"\n    self._internal_debugger.cont()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.catch_signal","title":"<code>catch_signal(signal, callback=None, recursive=False)</code>","text":"<p>Catch a signal in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>int | str</code> <p>The signal to catch. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be caught.</p> required <code>callback</code> <code>None | bool | Callable[[ThreadContext, SignalCatcher], None]</code> <p>A callback to be called when the signal is caught. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SignalCatcher</code> <code>SignalCatcher</code> <p>The SignalCatcher object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def catch_signal(\n    self: Debugger,\n    signal: int | str,\n    callback: None | bool | Callable[[ThreadContext, SignalCatcher], None] = None,\n    recursive: bool = False,\n) -&gt; SignalCatcher:\n    \"\"\"Catch a signal in the target process.\n\n    Args:\n        signal (int | str): The signal to catch. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be caught.\n        callback (None | bool | Callable[[ThreadContext, SignalCatcher], None], optional): A callback to be called when the signal is caught. If True, an empty callback will be set. Defaults to None.\n        recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n\n    Returns:\n        SignalCatcher: The SignalCatcher object.\n    \"\"\"\n    return self._internal_debugger.catch_signal(signal, callback, recursive)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.cont","title":"<code>cont()</code>","text":"<p>Continues the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def cont(self: Debugger) -&gt; None:\n    \"\"\"Continues the process.\"\"\"\n    self._internal_debugger.cont()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.detach","title":"<code>detach()</code>","text":"<p>Detaches from the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def detach(self: Debugger) -&gt; None:\n    \"\"\"Detaches from the process.\"\"\"\n    self._internal_debugger.detach()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.fin","title":"<code>fin(heuristic='backtrace')</code>","text":"<p>Alias for the <code>finish</code> method. Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> <code>'backtrace'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def fin(self: Debugger, heuristic: str = \"backtrace\") -&gt; None:\n    \"\"\"Alias for the `finish` method. Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n    self._internal_debugger.finish(self, heuristic)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.finish","title":"<code>finish(heuristic='backtrace')</code>","text":"<p>Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> <code>'backtrace'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def finish(self: Debugger, heuristic: str = \"backtrace\") -&gt; None:\n    \"\"\"Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n    self._internal_debugger.finish(self, heuristic=heuristic)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.gdb","title":"<code>gdb(migrate_breakpoints=True, open_in_new_process=True, blocking=True)</code>","text":"<p>Migrates the current debugging session to GDB.</p> <p>Parameters:</p> Name Type Description Default <code>migrate_breakpoints</code> <code>bool</code> <p>Whether to migrate over the breakpoints set in libdebug to GDB.</p> <code>True</code> <code>open_in_new_process</code> <code>bool</code> <p>Whether to attempt to open GDB in a new process instead of the current one.</p> <code>True</code> <code>blocking</code> <code>bool</code> <p>Whether to block the script until GDB is closed.</p> <code>True</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def gdb(\n    self: Debugger,\n    migrate_breakpoints: bool = True,\n    open_in_new_process: bool = True,\n    blocking: bool = True,\n) -&gt; GdbResumeEvent:\n    \"\"\"Migrates the current debugging session to GDB.\n\n    Args:\n        migrate_breakpoints (bool): Whether to migrate over the breakpoints set in libdebug to GDB.\n        open_in_new_process (bool): Whether to attempt to open GDB in a new process instead of the current one.\n        blocking (bool): Whether to block the script until GDB is closed.\n    \"\"\"\n    return self._internal_debugger.gdb(migrate_breakpoints, open_in_new_process, blocking)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.handle_syscall","title":"<code>handle_syscall(syscall, on_enter=None, on_exit=None, recursive=False)</code>","text":"<p>Handle a syscall in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>syscall</code> <code>int | str</code> <p>The syscall name or number to handle. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be handled.</p> required <code>on_enter</code> <code>None | bool | Callable[[ThreadContext, SyscallHandler], None]</code> <p>The callback to execute when the syscall is entered. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>on_exit</code> <code>None | bool | Callable[[ThreadContext, SyscallHandler], None]</code> <p>The callback to execute when the syscall is exited. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SyscallHandler</code> <code>SyscallHandler</code> <p>The SyscallHandler object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def handle_syscall(\n    self: Debugger,\n    syscall: int | str,\n    on_enter: None | bool | Callable[[ThreadContext, SyscallHandler], None] = None,\n    on_exit: None | bool | Callable[[ThreadContext, SyscallHandler], None] = None,\n    recursive: bool = False,\n) -&gt; SyscallHandler:\n    \"\"\"Handle a syscall in the target process.\n\n    Args:\n        syscall (int | str): The syscall name or number to handle. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be handled.\n        on_enter (None | bool |Callable[[ThreadContext, SyscallHandler], None], optional): The callback to execute when the syscall is entered. If True, an empty callback will be set. Defaults to None.\n        on_exit (None | bool | Callable[[ThreadContext, SyscallHandler], None], optional): The callback to execute when the syscall is exited. If True, an empty callback will be set. Defaults to None.\n        recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n\n    Returns:\n        SyscallHandler: The SyscallHandler object.\n    \"\"\"\n    return self._internal_debugger.handle_syscall(syscall, on_enter, on_exit, recursive)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.hijack_signal","title":"<code>hijack_signal(original_signal, new_signal, recursive=False)</code>","text":"<p>Hijack a signal in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>original_signal</code> <code>int | str</code> <p>The signal to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be hijacked.</p> required <code>new_signal</code> <code>int | str</code> <p>The signal to hijack the original signal with.</p> required <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SignalCatcher</code> <code>SyscallHandler</code> <p>The SignalCatcher object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def hijack_signal(\n    self: Debugger,\n    original_signal: int | str,\n    new_signal: int | str,\n    recursive: bool = False,\n) -&gt; SyscallHandler:\n    \"\"\"Hijack a signal in the target process.\n\n    Args:\n        original_signal (int | str): The signal to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be hijacked.\n        new_signal (int | str): The signal to hijack the original signal with.\n        recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n\n    Returns:\n        SignalCatcher: The SignalCatcher object.\n    \"\"\"\n    return self._internal_debugger.hijack_signal(original_signal, new_signal, recursive)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.hijack_syscall","title":"<code>hijack_syscall(original_syscall, new_syscall, recursive=False, **kwargs)</code>","text":"<p>Hijacks a syscall in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>original_syscall</code> <code>int | str</code> <p>The syscall name or number to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be hijacked.</p> required <code>new_syscall</code> <code>int | str</code> <p>The syscall name or number to hijack the original syscall with.</p> required <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.</p> <code>False</code> <code>**kwargs</code> <code>int</code> <p>(int, optional): The arguments to pass to the new syscall.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>SyscallHandler</code> <code>SyscallHandler</code> <p>The SyscallHandler object.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def hijack_syscall(\n    self: Debugger,\n    original_syscall: int | str,\n    new_syscall: int | str,\n    recursive: bool = False,\n    **kwargs: int,\n) -&gt; SyscallHandler:\n    \"\"\"Hijacks a syscall in the target process.\n\n    Args:\n        original_syscall (int | str): The syscall name or number to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be hijacked.\n        new_syscall (int | str): The syscall name or number to hijack the original syscall with.\n        recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n        **kwargs: (int, optional): The arguments to pass to the new syscall.\n\n    Returns:\n        SyscallHandler: The SyscallHandler object.\n    \"\"\"\n    return self._internal_debugger.hijack_syscall(original_syscall, new_syscall, recursive, **kwargs)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.int","title":"<code>int()</code>","text":"<p>Alias for the <code>interrupt</code> method.</p> <p>Interrupts the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def int(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `interrupt` method.\n\n    Interrupts the process.\n    \"\"\"\n    self._internal_debugger.interrupt()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.interrupt","title":"<code>interrupt()</code>","text":"<p>Interrupts the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def interrupt(self: Debugger) -&gt; None:\n    \"\"\"Interrupts the process.\"\"\"\n    self._internal_debugger.interrupt()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.kill","title":"<code>kill()</code>","text":"<p>Kills the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def kill(self: Debugger) -&gt; None:\n    \"\"\"Kills the process.\"\"\"\n    self._internal_debugger.kill()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.next","title":"<code>next()</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def next(self: Debugger) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    self._internal_debugger.next(self)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.ni","title":"<code>ni()</code>","text":"<p>Alias for the <code>next</code> method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def ni(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `next` method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    self._internal_debugger.next(self)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.post_init_","title":"<code>post_init_(internal_debugger)</code>","text":"<p>Do not use this constructor directly. Use the <code>debugger</code> function instead.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def post_init_(self: Debugger, internal_debugger: InternalDebugger) -&gt; None:\n    \"\"\"Do not use this constructor directly. Use the `debugger` function instead.\"\"\"\n    self._internal_debugger = internal_debugger\n    self._internal_debugger.start_up()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_backtrace","title":"<code>pprint_backtrace()</code>","text":"<p>Pretty pints the current backtrace of the main thread.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def pprint_backtrace(self: Debugger) -&gt; None:\n    \"\"\"Pretty pints the current backtrace of the main thread.\"\"\"\n    if not self.threads:\n        raise ValueError(\"No threads available.\")\n    self.threads[0].pprint_backtrace()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_maps","title":"<code>pprint_maps()</code>","text":"<p>Prints the memory maps of the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def pprint_maps(self: Debugger) -&gt; None:\n    \"\"\"Prints the memory maps of the process.\"\"\"\n    self._internal_debugger.pprint_maps()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_registers","title":"<code>pprint_registers()</code>","text":"<p>Pretty prints the main thread's registers.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def pprint_registers(self: Debugger) -&gt; None:\n    \"\"\"Pretty prints the main thread's registers.\"\"\"\n    if not self.threads:\n        raise ValueError(\"No threads available.\")\n    self.threads[0].pprint_registers()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_registers_all","title":"<code>pprint_registers_all()</code>","text":"<p>Pretty prints all the main thread's registers.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def pprint_registers_all(self: Debugger) -&gt; None:\n    \"\"\"Pretty prints all the main thread's registers.\"\"\"\n    if not self.threads:\n        raise ValueError(\"No threads available.\")\n    self.threads[0].pprint_registers_all()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_regs","title":"<code>pprint_regs()</code>","text":"<p>Alias for the <code>pprint_registers</code> method.</p> <p>Pretty prints the main thread's registers.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def pprint_regs(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `pprint_registers` method.\n\n    Pretty prints the main thread's registers.\n    \"\"\"\n    self.pprint_registers()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_regs_all","title":"<code>pprint_regs_all()</code>","text":"<p>Alias for the <code>pprint_registers_all</code> method.</p> <p>Pretty prints all the main thread's registers.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def pprint_regs_all(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `pprint_registers_all` method.\n\n    Pretty prints all the main thread's registers.\n    \"\"\"\n    self.pprint_registers_all()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.pprint_syscalls_context","title":"<code>pprint_syscalls_context(value)</code>","text":"<p>A context manager to temporarily change the state of the pprint_syscalls flag.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>the value to set.</p> required Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>@contextmanager\ndef pprint_syscalls_context(self: Debugger, value: bool) -&gt; ...:\n    \"\"\"A context manager to temporarily change the state of the pprint_syscalls flag.\n\n    Args:\n        value (bool): the value to set.\n    \"\"\"\n    old_value = self.pprint_syscalls\n    self.pprint_syscalls = value\n    yield\n    self.pprint_syscalls = old_value\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.print_maps","title":"<code>print_maps()</code>","text":"<p>Prints the memory maps of the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def print_maps(self: Debugger) -&gt; None:\n    \"\"\"Prints the memory maps of the process.\"\"\"\n    liblog.warning(\"The `print_maps` method is deprecated. Use `d.pprint_maps` instead.\")\n    self._internal_debugger.pprint_maps()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.r","title":"<code>r(redirect_pipes=True)</code>","text":"<p>Alias for the <code>run</code> method.</p> <p>Starts the process and waits for it to stop.</p> <p>Parameters:</p> Name Type Description Default <code>redirect_pipes</code> <code>bool</code> <p>Whether to hook and redirect the pipes of the process to a PipeManager.</p> <code>True</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def r(self: Debugger, redirect_pipes: bool = True) -&gt; PipeManager | None:\n    \"\"\"Alias for the `run` method.\n\n    Starts the process and waits for it to stop.\n\n    Args:\n        redirect_pipes (bool): Whether to hook and redirect the pipes of the process to a PipeManager.\n    \"\"\"\n    return self._internal_debugger.run(redirect_pipes)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.resolve_symbol","title":"<code>resolve_symbol(symbol, file='binary')</code>","text":"<p>Resolves the address of the specified symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to resolve.</p> required <code>file</code> <code>str</code> <p>The backing file to resolve the symbol in. Defaults to \"binary\"</p> <code>'binary'</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The address of the symbol.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def resolve_symbol(self: Debugger, symbol: str, file: str = \"binary\") -&gt; int:\n    \"\"\"Resolves the address of the specified symbol.\n\n    Args:\n        symbol (str): The symbol to resolve.\n        file (str): The backing file to resolve the symbol in. Defaults to \"binary\"\n\n    Returns:\n        int: The address of the symbol.\n    \"\"\"\n    return self._internal_debugger.resolve_symbol(symbol, file)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.run","title":"<code>run(redirect_pipes=True)</code>","text":"<p>Starts the process and waits for it to stop.</p> <p>Parameters:</p> Name Type Description Default <code>redirect_pipes</code> <code>bool</code> <p>Whether to hook and redirect the pipes of the process to a PipeManager.</p> <code>True</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def run(self: Debugger, redirect_pipes: bool = True) -&gt; PipeManager | None:\n    \"\"\"Starts the process and waits for it to stop.\n\n    Args:\n        redirect_pipes (bool): Whether to hook and redirect the pipes of the process to a PipeManager.\n    \"\"\"\n    return self._internal_debugger.run(redirect_pipes)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.si","title":"<code>si()</code>","text":"<p>Alias for the <code>step</code> method.</p> <p>Executes a single instruction of the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def si(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `step` method.\n\n    Executes a single instruction of the process.\n    \"\"\"\n    self._internal_debugger.step(self)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.step","title":"<code>step()</code>","text":"<p>Executes a single instruction of the process.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def step(self: Debugger) -&gt; None:\n    \"\"\"Executes a single instruction of the process.\"\"\"\n    self._internal_debugger.step(self)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.step_until","title":"<code>step_until(position, max_steps=-1, file='hybrid')</code>","text":"<p>Executes instructions of the process until the specified location is reached.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute. Defaults to -1.</p> <code>-1</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def step_until(\n    self: Debugger,\n    position: int | str,\n    max_steps: int = -1,\n    file: str = \"hybrid\",\n) -&gt; None:\n    \"\"\"Executes instructions of the process until the specified location is reached.\n\n    Args:\n        position (int | bytes): The location to reach.\n        max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n    \"\"\"\n    self._internal_debugger.step_until(self, position, max_steps, file)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.su","title":"<code>su(position, max_steps=-1)</code>","text":"<p>Alias for the <code>step_until</code> method.</p> <p>Executes instructions of the process until the specified location is reached.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute. Defaults to -1.</p> <code>-1</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def su(\n    self: Debugger,\n    position: int | str,\n    max_steps: int = -1,\n) -&gt; None:\n    \"\"\"Alias for the `step_until` method.\n\n    Executes instructions of the process until the specified location is reached.\n\n    Args:\n        position (int | bytes): The location to reach.\n        max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n    \"\"\"\n    self._internal_debugger.step_until(self, position, max_steps)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.terminate","title":"<code>terminate()</code>","text":"<p>Interrupts the process, kills it and then terminates the background thread.</p> <p>The debugger object will not be usable after this method is called. This method should only be called to free up resources when the debugger object is no longer needed.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def terminate(self: Debugger) -&gt; None:\n    \"\"\"Interrupts the process, kills it and then terminates the background thread.\n\n    The debugger object will not be usable after this method is called.\n    This method should only be called to free up resources when the debugger object is no longer needed.\n    \"\"\"\n    self._internal_debugger.terminate()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.w","title":"<code>w()</code>","text":"<p>Alias for the <code>wait</code> method.</p> <p>Waits for the process to stop.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def w(self: Debugger) -&gt; None:\n    \"\"\"Alias for the `wait` method.\n\n    Waits for the process to stop.\n    \"\"\"\n    self._internal_debugger.wait()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.wait","title":"<code>wait()</code>","text":"<p>Waits for the process to stop.</p> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def wait(self: Debugger) -&gt; None:\n    \"\"\"Waits for the process to stop.\"\"\"\n    self._internal_debugger.wait()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.watchpoint","title":"<code>watchpoint(position, condition='w', length=1, callback=None, file='hybrid')</code>","text":"<p>Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>condition</code> <code>str</code> <p>The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\"). Defaults to \"w\".</p> <code>'w'</code> <code>length</code> <code>int</code> <p>The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.</p> <code>1</code> <code>callback</code> <code>None | bool | Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the watchpoint is hit. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def watchpoint(\n    self: Debugger,\n    position: int | str,\n    condition: str = \"w\",\n    length: int = 1,\n    callback: None | bool | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        condition (str, optional): The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\"). Defaults to \"w\".\n        length (int, optional): The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.\n        callback (None | bool | Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the watchpoint is hit. If True, an empty callback will be set. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n    \"\"\"\n    return self._internal_debugger.breakpoint(\n        position,\n        hardware=True,\n        condition=condition,\n        length=length,\n        callback=callback,\n        file=file,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/debugger/debugger/#libdebug.debugger.debugger.Debugger.wp","title":"<code>wp(position, condition='w', length=1, callback=None, file='hybrid')</code>","text":"<p>Alias for the <code>watchpoint</code> method.</p> <p>Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>condition</code> <code>str</code> <p>The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\"). Defaults to \"w\".</p> <code>'w'</code> <code>length</code> <code>int</code> <p>The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.</p> <code>1</code> <code>callback</code> <code>Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the watchpoint is hit. Defaults to None.</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/debugger.py</code> <pre><code>def wp(\n    self: Debugger,\n    position: int | str,\n    condition: str = \"w\",\n    length: int = 1,\n    callback: None | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Alias for the `watchpoint` method.\n\n    Sets a watchpoint at the specified location. Internally, watchpoints are implemented as breakpoints.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        condition (str, optional): The trigger condition for the watchpoint (either \"w\", \"rw\" or \"x\"). Defaults to \"w\".\n        length (int, optional): The size of the word in being watched (1, 2, 4 or 8). Defaults to 1.\n        callback (Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the watchpoint is hit. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n    \"\"\"\n    return self._internal_debugger.breakpoint(\n        position,\n        hardware=True,\n        condition=condition,\n        length=length,\n        callback=callback,\n        file=file,\n    )\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/","title":"libdebug.debugger.internal_debugger","text":""},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger","title":"<code>InternalDebugger</code>","text":"<p>A class that holds the global debugging state.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>class InternalDebugger:\n    \"\"\"A class that holds the global debugging state.\"\"\"\n\n    aslr_enabled: bool\n    \"\"\"A flag that indicates if ASLR is enabled or not.\"\"\"\n\n    arch: str\n    \"\"\"The architecture of the debugged process.\"\"\"\n\n    argv: list[str]\n    \"\"\"The command line arguments of the debugged process.\"\"\"\n\n    env: dict[str, str] | None\n    \"\"\"The environment variables of the debugged process.\"\"\"\n\n    escape_antidebug: bool\n    \"\"\"A flag that indicates if the debugger should escape anti-debugging techniques.\"\"\"\n\n    fast_memory: bool\n    \"\"\"A flag that indicates if the debugger should use a faster memory access method.\"\"\"\n\n    autoreach_entrypoint: bool\n    \"\"\"A flag that indicates if the debugger should automatically reach the entry point of the debugged process.\"\"\"\n\n    auto_interrupt_on_command: bool\n    \"\"\"A flag that indicates if the debugger should automatically interrupt the debugged process when a command is issued.\"\"\"\n\n    breakpoints: dict[int, Breakpoint]\n    \"\"\"A dictionary of all the breakpoints set on the process. Key: the address of the breakpoint.\"\"\"\n\n    handled_syscalls: dict[int, SyscallHandler]\n    \"\"\"A dictionary of all the syscall handled in the process. Key: the syscall number.\"\"\"\n\n    caught_signals: dict[int, SignalCatcher]\n    \"\"\"A dictionary of all the signals caught in the process. Key: the signal number.\"\"\"\n\n    signals_to_block: list[int]\n    \"\"\"The signals to not forward to the process.\"\"\"\n\n    syscalls_to_pprint: list[int] | None\n    \"\"\"The syscalls to pretty print.\"\"\"\n\n    syscalls_to_not_pprint: list[int] | None\n    \"\"\"The syscalls to not pretty print.\"\"\"\n\n    kill_on_exit: bool\n    \"\"\"A flag that indicates if the debugger should kill the debugged process when it exits.\"\"\"\n\n    threads: list[ThreadContext]\n    \"\"\"A list of all the threads of the debugged process.\"\"\"\n\n    process_id: int\n    \"\"\"The PID of the debugged process.\"\"\"\n\n    pipe_manager: PipeManager\n    \"\"\"The PipeManager used to communicate with the debugged process.\"\"\"\n\n    memory: AbstractMemoryView\n    \"\"\"The memory view of the debugged process.\"\"\"\n\n    debugging_interface: DebuggingInterface\n    \"\"\"The debugging interface used to communicate with the debugged process.\"\"\"\n\n    instanced: bool = False\n    \"\"\"Whether the process was started and has not been killed yet.\"\"\"\n\n    is_debugging: bool = False\n    \"\"\"Whether the debugger is currently debugging a process.\"\"\"\n\n    pprint_syscalls: bool\n    \"\"\"A flag that indicates if the debugger should pretty print syscalls.\"\"\"\n\n    resume_context: ResumeContext\n    \"\"\"Context that indicates if the debugger should resume the debugged process.\"\"\"\n\n    debugger: Debugger\n    \"\"\"The debugger object.\"\"\"\n\n    stdin_settings_backup: list[Any]\n    \"\"\"The backup of the stdin settings. Used to restore the original settings after possible conflicts due to the pipe manager interacactive mode.\"\"\"\n\n    __polling_thread: Thread | None\n    \"\"\"The background thread used to poll the process for state change.\"\"\"\n\n    __polling_thread_command_queue: Queue | None\n    \"\"\"The queue used to send commands to the background thread.\"\"\"\n\n    __polling_thread_response_queue: Queue | None\n    \"\"\"The queue used to receive responses from the background thread.\"\"\"\n\n    _is_running: bool\n    \"\"\"The overall state of the debugged process. True if the process is running, False otherwise.\"\"\"\n\n    _is_migrated_to_gdb: bool\n    \"\"\"A flag that indicates if the debuggee was migrated to GDB.\"\"\"\n\n    _fast_memory: DirectMemoryView\n    \"\"\"The memory view of the debugged process using the fast memory access method.\"\"\"\n\n    _slow_memory: ChunkedMemoryView\n    \"\"\"The memory view of the debugged process using the slow memory access method.\"\"\"\n\n    def __init__(self: InternalDebugger) -&gt; None:\n        \"\"\"Initialize the context.\"\"\"\n        # These must be reinitialized on every call to \"debugger\"\n        self.aslr_enabled = False\n        self.autoreach_entrypoint = True\n        self.argv = []\n        self.env = {}\n        self.escape_antidebug = False\n        self.breakpoints = {}\n        self.handled_syscalls = {}\n        self.caught_signals = {}\n        self.syscalls_to_pprint = None\n        self.syscalls_to_not_pprint = None\n        self.signals_to_block = []\n        self.pprint_syscalls = False\n        self.pipe_manager = None\n        self.process_id = 0\n        self.threads = []\n        self.instanced = False\n        self.is_debugging = False\n        self._is_running = False\n        self._is_migrated_to_gdb = False\n        self.resume_context = ResumeContext()\n        self.stdin_settings_backup = []\n        self.arch = map_arch(libcontext.platform)\n        self.kill_on_exit = True\n        self._process_memory_manager = ProcessMemoryManager()\n        self.fast_memory = False\n        self.__polling_thread_command_queue = Queue()\n        self.__polling_thread_response_queue = Queue()\n\n    def clear(self: InternalDebugger) -&gt; None:\n        \"\"\"Reinitializes the context, so it is ready for a new run.\"\"\"\n        # These must be reinitialized on every call to \"run\"\n        self.breakpoints.clear()\n        self.handled_syscalls.clear()\n        self.caught_signals.clear()\n        self.syscalls_to_pprint = None\n        self.syscalls_to_not_pprint = None\n        self.signals_to_block.clear()\n        self.pprint_syscalls = False\n        self.pipe_manager = None\n        self.process_id = 0\n        self.threads.clear()\n        self.instanced = False\n        self.is_debugging = False\n        self._is_running = False\n        self.resume_context.clear()\n\n    def start_up(self: InternalDebugger) -&gt; None:\n        \"\"\"Starts up the context.\"\"\"\n        # The context is linked to itself\n        link_to_internal_debugger(self, self)\n\n        self.start_processing_thread()\n        with extend_internal_debugger(self):\n            self.debugging_interface = provide_debugging_interface()\n            self._fast_memory = DirectMemoryView(self._fast_read_memory, self._fast_write_memory)\n            self._slow_memory = ChunkedMemoryView(\n                self._peek_memory,\n                self._poke_memory,\n                unit_size=get_platform_register_size(libcontext.platform),\n            )\n\n    def start_processing_thread(self: InternalDebugger) -&gt; None:\n        \"\"\"Starts the thread that will poll the traced process for state change.\"\"\"\n        # Set as daemon so that the Python interpreter can exit even if the thread is still running\n        self.__polling_thread = Thread(\n            target=self.__polling_thread_function,\n            name=\"libdebug__polling_thread\",\n            daemon=True,\n        )\n        self.__polling_thread.start()\n\n    def _background_invalid_call(self: InternalDebugger, *_: ..., **__: ...) -&gt; None:\n        \"\"\"Raises an error when an invalid call is made in background mode.\"\"\"\n        raise RuntimeError(\"This method is not available in a callback.\")\n\n    def run(self: InternalDebugger, redirect_pipes: bool = True) -&gt; PipeManager | None:\n        \"\"\"Starts the process and waits for it to stop.\n\n        Args:\n            redirect_pipes (bool): Whether to hook and redirect the pipes of the process to a PipeManager.\n        \"\"\"\n        if not self.argv:\n            raise RuntimeError(\"No binary file specified.\")\n\n        if not Path(self.argv[0]).is_file():\n            raise RuntimeError(f\"File {self.argv[0]} does not exist.\")\n\n        if not os.access(self.argv[0], os.X_OK):\n            raise RuntimeError(\n                f\"File {self.argv[0]} is not executable.\",\n            )\n\n        if self.is_debugging:\n            liblog.debugger(\"Process already running, stopping it before restarting.\")\n            self.kill()\n        if self.threads:\n            self.clear()\n            self.debugging_interface.reset()\n\n        self.instanced = True\n        self.is_debugging = True\n\n        if not self.__polling_thread_command_queue.empty():\n            raise RuntimeError(\"Polling thread command queue not empty.\")\n\n        self.__polling_thread_command_queue.put((self.__threaded_run, (redirect_pipes,)))\n\n        self._join_and_check_status()\n\n        if self.escape_antidebug:\n            liblog.debugger(\"Enabling anti-debugging escape mechanism.\")\n            self._enable_antidebug_escaping()\n\n        if redirect_pipes and not self.pipe_manager:\n            raise RuntimeError(\"Something went wrong during pipe initialization.\")\n\n        self._process_memory_manager.open(self.process_id)\n\n        return self.pipe_manager\n\n    def attach(self: InternalDebugger, pid: int) -&gt; None:\n        \"\"\"Attaches to an existing process.\"\"\"\n        if self.is_debugging:\n            liblog.debugger(\"Process already running, stopping it before restarting.\")\n            self.kill()\n        if self.threads:\n            self.clear()\n            self.debugging_interface.reset()\n\n        self.instanced = True\n        self.is_debugging = True\n\n        if not self.__polling_thread_command_queue.empty():\n            raise RuntimeError(\"Polling thread command queue not empty.\")\n\n        self.__polling_thread_command_queue.put((self.__threaded_attach, (pid,)))\n\n        self._join_and_check_status()\n\n        self._process_memory_manager.open(self.process_id)\n\n    def detach(self: InternalDebugger) -&gt; None:\n        \"\"\"Detaches from the process.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot detach.\")\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put((self.__threaded_detach, ()))\n\n        self.is_debugging = False\n\n        self._join_and_check_status()\n\n        self._process_memory_manager.close()\n\n    @background_alias(_background_invalid_call)\n    def kill(self: InternalDebugger) -&gt; None:\n        \"\"\"Kills the process.\"\"\"\n        try:\n            self._ensure_process_stopped()\n        except (OSError, RuntimeError):\n            # This exception might occur if the process has already died\n            liblog.debugger(\"OSError raised during kill\")\n\n        self._process_memory_manager.close()\n\n        self.__polling_thread_command_queue.put((self.__threaded_kill, ()))\n\n        self.instanced = False\n        self.is_debugging = False\n\n        if self.pipe_manager:\n            self.pipe_manager.close()\n\n        self._join_and_check_status()\n\n    def terminate(self: InternalDebugger) -&gt; None:\n        \"\"\"Interrupts the process, kills it and then terminates the background thread.\n\n        The debugger object will not be usable after this method is called.\n        This method should only be called to free up resources when the debugger object is no longer needed.\n        \"\"\"\n        if self.instanced and self.running:\n            try:\n                self.interrupt()\n            except ProcessLookupError:\n                # The process has already been killed by someone or something else\n                liblog.debugger(\"Interrupting process failed: already terminated\")\n\n        if self.instanced:\n            try:\n                self.kill()\n            except ProcessLookupError:\n                # The process has already been killed by someone or something else\n                liblog.debugger(\"Killing process failed: already terminated\")\n\n        self.instanced = False\n        self.is_debugging = False\n\n        if self.__polling_thread is not None:\n            self.__polling_thread_command_queue.put((THREAD_TERMINATE, ()))\n            self.__polling_thread.join()\n            del self.__polling_thread\n            self.__polling_thread = None\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def cont(self: InternalDebugger) -&gt; None:\n        \"\"\"Continues the process.\n\n        Args:\n            auto_wait (bool, optional): Whether to automatically wait for the process to stop after continuing. Defaults to True.\n        \"\"\"\n        self.__polling_thread_command_queue.put((self.__threaded_cont, ()))\n\n        self._join_and_check_status()\n\n        self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n\n    @background_alias(_background_invalid_call)\n    def interrupt(self: InternalDebugger) -&gt; None:\n        \"\"\"Interrupts the process.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot interrupt.\")\n\n        # We have to ensure that at least one thread is alive before executing the method\n        if self.threads[0].dead:\n            raise RuntimeError(\"All threads are dead.\")\n\n        if not self.running:\n            return\n\n        self.resume_context.force_interrupt = True\n        os.kill(self.process_id, SIGSTOP)\n\n        self.wait()\n\n    @background_alias(_background_invalid_call)\n    def wait(self: InternalDebugger) -&gt; None:\n        \"\"\"Waits for the process to stop.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot wait.\")\n\n        self._join_and_check_status()\n\n        if self.threads[0].dead or not self.running:\n            # Most of the time the function returns here, as there was a wait already\n            # queued by the previous command\n            return\n\n        self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n\n        self._join_and_check_status()\n\n    @property\n    def maps(self: InternalDebugger) -&gt; MemoryMapList[MemoryMap]:\n        \"\"\"Returns the memory maps of the process.\"\"\"\n        self._ensure_process_stopped()\n        return self.debugging_interface.get_maps()\n\n    @property\n    def memory(self: InternalDebugger) -&gt; AbstractMemoryView:\n        \"\"\"The memory view of the debugged process.\"\"\"\n        return self._fast_memory if self.fast_memory else self._slow_memory\n\n    def pprint_maps(self: InternalDebugger) -&gt; None:\n        \"\"\"Prints the memory maps of the process.\"\"\"\n        self._ensure_process_stopped()\n        header = (\n            f\"{'start':&gt;18}  \"\n            f\"{'end':&gt;18}  \"\n            f\"{'perm':&gt;6}  \"\n            f\"{'size':&gt;8}  \"\n            f\"{'offset':&gt;8}  \"\n            f\"{'backing_file':&lt;20}\"\n        )\n        print(header)\n        for memory_map in self.maps:\n            info = (\n                f\"{memory_map.start:#18x}  \"\n                f\"{memory_map.end:#18x}  \"\n                f\"{memory_map.permissions:&gt;6}  \"\n                f\"{memory_map.size:#8x}  \"\n                f\"{memory_map.offset:#8x}  \"\n                f\"{memory_map.backing_file}\"\n            )\n            if \"rwx\" in memory_map.permissions:\n                print(f\"{ANSIColors.RED}{ANSIColors.UNDERLINE}{info}{ANSIColors.RESET}\")\n            elif \"x\" in memory_map.permissions:\n                print(f\"{ANSIColors.RED}{info}{ANSIColors.RESET}\")\n            elif \"w\" in memory_map.permissions:\n                print(f\"{ANSIColors.YELLOW}{info}{ANSIColors.RESET}\")\n            elif \"r\" in memory_map.permissions:\n                print(f\"{ANSIColors.GREEN}{info}{ANSIColors.RESET}\")\n            else:\n                print(info)\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def breakpoint(\n        self: InternalDebugger,\n        position: int | str,\n        hardware: bool = False,\n        condition: str = \"x\",\n        length: int = 1,\n        callback: None | bool | Callable[[ThreadContext, Breakpoint], None] = None,\n        file: str = \"hybrid\",\n    ) -&gt; Breakpoint:\n        \"\"\"Sets a breakpoint at the specified location.\n\n        Args:\n            position (int | bytes): The location of the breakpoint.\n            hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.\n            condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n            length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n            callback (None | bool | Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the breakpoint is hit. If True, an empty callback will be set. Defaults to None.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        if isinstance(position, str):\n            address = self.resolve_symbol(position, file)\n        else:\n            address = self.resolve_address(position, file)\n            position = hex(address)\n\n        if condition != \"x\" and not hardware:\n            raise ValueError(\"Breakpoint condition is supported only for hardware watchpoints.\")\n\n        if callback is True:\n\n            def callback(_: ThreadContext, __: Breakpoint) -&gt; None:\n                pass\n\n        bp = Breakpoint(address, position, 0, hardware, callback, condition.lower(), length)\n\n        if hardware:\n            validate_hardware_breakpoint(self.arch, bp)\n\n        link_to_internal_debugger(bp, self)\n\n        self.__polling_thread_command_queue.put((self.__threaded_breakpoint, (bp,)))\n\n        self._join_and_check_status()\n\n        # the breakpoint should have been set by interface\n        if address not in self.breakpoints:\n            raise RuntimeError(\"Something went wrong while inserting the breakpoint.\")\n\n        return bp\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def catch_signal(\n        self: InternalDebugger,\n        signal: int | str,\n        callback: None | bool | Callable[[ThreadContext, SignalCatcher], None] = None,\n        recursive: bool = False,\n    ) -&gt; SignalCatcher:\n        \"\"\"Catch a signal in the target process.\n\n        Args:\n            signal (int | str): The signal to catch. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be caught.\n            callback (None | bool | Callable[[ThreadContext, SignalCatcher], None], optional): A callback to be called when the signal is caught. If True, an empty callback will be set. Defaults to None.\n            recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n\n        Returns:\n            SignalCatcher: The SignalCatcher object.\n        \"\"\"\n        if isinstance(signal, str):\n            signal_number = resolve_signal_number(signal)\n        elif isinstance(signal, int):\n            signal_number = signal\n        else:\n            raise TypeError(\"signal must be an int or a str\")\n\n        match signal_number:\n            case SIGKILL.value:\n                raise ValueError(\n                    f\"Cannot catch SIGKILL ({signal_number}) as it cannot be caught or ignored. This is a kernel restriction.\",\n                )\n            case SIGSTOP.value:\n                raise ValueError(\n                    f\"Cannot catch SIGSTOP ({signal_number}) as it is used by the debugger or ptrace for their internal operations.\",\n                )\n            case SIGTRAP.value:\n                raise ValueError(\n                    f\"Cannot catch SIGTRAP ({signal_number}) as it is used by the debugger or ptrace for their internal operations.\",\n                )\n\n        if signal_number in self.caught_signals:\n            liblog.warning(\n                f\"Signal {resolve_signal_name(signal_number)} ({signal_number}) has already been caught. Overriding it.\",\n            )\n\n        if not isinstance(recursive, bool):\n            raise TypeError(\"recursive must be a boolean\")\n\n        if callback is True:\n\n            def callback(_: ThreadContext, __: SignalCatcher) -&gt; None:\n                pass\n\n        catcher = SignalCatcher(signal_number, callback, recursive)\n\n        link_to_internal_debugger(catcher, self)\n\n        self.__polling_thread_command_queue.put((self.__threaded_catch_signal, (catcher,)))\n\n        self._join_and_check_status()\n\n        return catcher\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def hijack_signal(\n        self: InternalDebugger,\n        original_signal: int | str,\n        new_signal: int | str,\n        recursive: bool = False,\n    ) -&gt; SignalCatcher:\n        \"\"\"Hijack a signal in the target process.\n\n        Args:\n            original_signal (int | str): The signal to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be hijacked.\n            new_signal (int | str): The signal to hijack the original signal with.\n            recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n\n        Returns:\n            SignalCatcher: The SignalCatcher object.\n        \"\"\"\n        if isinstance(original_signal, str):\n            original_signal_number = resolve_signal_number(original_signal)\n        else:\n            original_signal_number = original_signal\n\n        new_signal_number = resolve_signal_number(new_signal) if isinstance(new_signal, str) else new_signal\n\n        if new_signal_number == -1:\n            raise ValueError(\"Cannot hijack a signal with the 'ALL' signal.\")\n\n        if original_signal_number == new_signal_number:\n            raise ValueError(\n                \"The original signal and the new signal must be different during hijacking.\",\n            )\n\n        def callback(thread: ThreadContext, _: SignalCatcher) -&gt; None:\n            \"\"\"The callback to execute when the signal is received.\"\"\"\n            thread.signal = new_signal_number\n\n        return self.catch_signal(original_signal_number, callback, recursive)\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def handle_syscall(\n        self: InternalDebugger,\n        syscall: int | str,\n        on_enter: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n        on_exit: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n        recursive: bool = False,\n    ) -&gt; SyscallHandler:\n        \"\"\"Handle a syscall in the target process.\n\n        Args:\n            syscall (int | str): The syscall name or number to handle. If \"*\", \"ALL\", \"all\", or -1 is passed, all syscalls will be handled.\n            on_enter (None | bool |Callable[[ThreadContext, SyscallHandler], None], optional): The callback to execute when the syscall is entered. If True, an empty callback will be set. Defaults to None.\n            on_exit (None | bool | Callable[[ThreadContext, SyscallHandler], None], optional): The callback to execute when the syscall is exited. If True, an empty callback will be set. Defaults to None.\n            recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n\n        Returns:\n            SyscallHandler: The SyscallHandler object.\n        \"\"\"\n        syscall_number = resolve_syscall_number(self.arch, syscall) if isinstance(syscall, str) else syscall\n\n        if not isinstance(recursive, bool):\n            raise TypeError(\"recursive must be a boolean\")\n\n        if on_enter is True:\n\n            def on_enter(_: ThreadContext, __: SyscallHandler) -&gt; None:\n                pass\n\n        if on_exit is True:\n\n            def on_exit(_: ThreadContext, __: SyscallHandler) -&gt; None:\n                pass\n\n        # Check if the syscall is already handled (by the user or by the pretty print handler)\n        if syscall_number in self.handled_syscalls:\n            handler = self.handled_syscalls[syscall_number]\n            if handler.on_enter_user or handler.on_exit_user:\n                liblog.warning(\n                    f\"Syscall {resolve_syscall_name(self.arch, syscall_number)} is already handled by a user-defined handler. Overriding it.\",\n                )\n            handler.on_enter_user = on_enter\n            handler.on_exit_user = on_exit\n            handler.recursive = recursive\n            handler.enabled = True\n        else:\n            handler = SyscallHandler(\n                syscall_number,\n                on_enter,\n                on_exit,\n                None,\n                None,\n                recursive,\n            )\n\n            link_to_internal_debugger(handler, self)\n\n            self.__polling_thread_command_queue.put(\n                (self.__threaded_handle_syscall, (handler,)),\n            )\n\n            self._join_and_check_status()\n\n        return handler\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def hijack_syscall(\n        self: InternalDebugger,\n        original_syscall: int | str,\n        new_syscall: int | str,\n        recursive: bool = True,\n        **kwargs: int,\n    ) -&gt; SyscallHandler:\n        \"\"\"Hijacks a syscall in the target process.\n\n        Args:\n            original_syscall (int | str): The syscall name or number to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be hijacked.\n            new_syscall (int | str): The syscall name or number to hijack the original syscall with.\n            recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n            **kwargs: (int, optional): The arguments to pass to the new syscall.\n\n        Returns:\n            SyscallHandler: The SyscallHandler object.\n        \"\"\"\n        if set(kwargs) - SyscallHijacker.allowed_args:\n            raise ValueError(\"Invalid keyword arguments in syscall hijack\")\n\n        if isinstance(original_syscall, str):\n            original_syscall_number = resolve_syscall_number(self.arch, original_syscall)\n        else:\n            original_syscall_number = original_syscall\n\n        new_syscall_number = (\n            resolve_syscall_number(self.arch, new_syscall) if isinstance(new_syscall, str) else new_syscall\n        )\n\n        if new_syscall_number == -1:\n            raise ValueError(\"Cannot hijack a syscall with the 'ALL' syscall.\")\n\n        if original_syscall_number == new_syscall_number:\n            raise ValueError(\n                \"The original syscall and the new syscall must be different during hijacking.\",\n            )\n\n        on_enter = SyscallHijacker().create_hijacker(\n            new_syscall_number,\n            **kwargs,\n        )\n\n        # Check if the syscall is already handled (by the user or by the pretty print handler)\n        if original_syscall_number in self.handled_syscalls:\n            handler = self.handled_syscalls[original_syscall_number]\n            if handler.on_enter_user or handler.on_exit_user:\n                liblog.warning(\n                    f\"Syscall {original_syscall_number} is already handled by a user-defined handler. Overriding it.\",\n                )\n            handler.on_enter_user = on_enter\n            handler.on_exit_user = None\n            handler.recursive = recursive\n            handler.enabled = True\n        else:\n            handler = SyscallHandler(\n                original_syscall_number,\n                on_enter,\n                None,\n                None,\n                None,\n                recursive,\n            )\n\n            link_to_internal_debugger(handler, self)\n\n            self.__polling_thread_command_queue.put(\n                (self.__threaded_handle_syscall, (handler,)),\n            )\n\n            self._join_and_check_status()\n\n        return handler\n\n    @background_alias(_background_invalid_call)\n    @change_state_function_process\n    def gdb(\n        self: InternalDebugger,\n        migrate_breakpoints: bool = True,\n        open_in_new_process: bool = True,\n        blocking: bool = True,\n    ) -&gt; GdbResumeEvent:\n        \"\"\"Migrates the current debugging session to GDB.\"\"\"\n        # TODO: not needed?\n        self.interrupt()\n\n        self.__polling_thread_command_queue.put((self.__threaded_gdb, ()))\n\n        self._join_and_check_status()\n\n        # Create the command file\n        command_file = self._craft_gdb_migration_file(migrate_breakpoints)\n\n        if open_in_new_process and libcontext.terminal:\n            lambda_fun = self._open_gdb_in_new_process(command_file)\n        elif open_in_new_process:\n            self._auto_detect_terminal()\n            if not libcontext.terminal:\n                liblog.warning(\n                    \"Cannot auto-detect terminal. Please configure the terminal in libcontext.terminal. Opening gdb in the current shell.\",\n                )\n                lambda_fun = self._open_gdb_in_shell(command_file)\n            else:\n                lambda_fun = self._open_gdb_in_new_process(command_file)\n        else:\n            lambda_fun = self._open_gdb_in_shell(command_file)\n\n        resume_event = GdbResumeEvent(self, lambda_fun)\n\n        self._is_migrated_to_gdb = True\n\n        if blocking:\n            resume_event.join()\n            return None\n        else:\n            return resume_event\n\n    def _auto_detect_terminal(self: InternalDebugger) -&gt; None:\n        \"\"\"Auto-detects the terminal.\"\"\"\n        try:\n            process = Process(self.process_id)\n            while process:\n                pname = process.name().lower()\n                if terminal_command := TerminalTypes.get_command(pname):\n                    libcontext.terminal = terminal_command\n                    liblog.debugger(f\"Auto-detected terminal: {libcontext.terminal}\")\n                process = process.parent()\n        except Error:\n            pass\n\n    def _craft_gdb_migration_command(self: InternalDebugger, migrate_breakpoints: bool) -&gt; str:\n        \"\"\"Crafts the command to migrate to GDB.\n\n        Args:\n            migrate_breakpoints (bool): Whether to migrate the breakpoints.\n\n        Returns:\n            str: The command to migrate to GDB.\n        \"\"\"\n        gdb_command = f'/bin/gdb -q --pid {self.process_id} -ex \"source {GDB_GOBACK_LOCATION} \" -ex \"ni\" -ex \"ni\"'\n\n        if not migrate_breakpoints:\n            return gdb_command\n\n        for bp in self.breakpoints.values():\n            if bp.enabled:\n                if bp.hardware and bp.condition == \"rw\":\n                    gdb_command += f' -ex \"awatch *(int{bp.length * 8}_t *) {bp.address:#x}\"'\n                elif bp.hardware and bp.condition == \"w\":\n                    gdb_command += f' -ex \"watch *(int{bp.length * 8}_t *) {bp.address:#x}\"'\n                elif bp.hardware:\n                    gdb_command += f' -ex \"hb *{bp.address:#x}\"'\n                else:\n                    gdb_command += f' -ex \"b *{bp.address:#x}\"'\n\n                if self.threads[0].instruction_pointer == bp.address and not bp.hardware:\n                    # We have to enqueue an additional continue\n                    gdb_command += ' -ex \"ni\"'\n\n        return gdb_command\n\n    def _craft_gdb_migration_file(self: InternalDebugger, migrate_breakpoints: bool) -&gt; str:\n        \"\"\"Crafts the file to migrate to GDB.\n\n        Args:\n            migrate_breakpoints (bool): Whether to migrate the breakpoints.\n\n        Returns:\n            str: The path to the file.\n        \"\"\"\n        # Different terminals accept what to run in different ways. To make this work with all terminals, we need to\n        # create a temporary script that will run the command. This script will be executed by the terminal.\n        command = self._craft_gdb_migration_command(migrate_breakpoints)\n        with NamedTemporaryFile(delete=False, mode=\"w\", suffix=\".sh\") as temp_file:\n            temp_file.write(\"#!/bin/bash\\n\")\n            temp_file.write(command)\n            script_path = temp_file.name\n\n        # Make the script executable\n        Path.chmod(Path(script_path), 0o755)\n        return script_path\n\n    def _open_gdb_in_new_process(self: InternalDebugger, script_path: str) -&gt; None:\n        \"\"\"Opens GDB in a new process following the configuration in libcontext.terminal.\n\n        Args:\n            script_path (str): The path to the script to run in the terminal.\n        \"\"\"\n        # Create the command to open the terminal and run the script\n        command = [*libcontext.terminal, script_path]\n\n        # Open GDB in a new terminal\n        terminal_pid = Popen(command).pid\n\n        # This is the command line that we are looking for\n        cmdline_target = [\"/bin/bash\", script_path]\n\n        self._wait_for_gdb(terminal_pid, cmdline_target)\n\n        def wait_for_termination() -&gt; None:\n            liblog.debugger(\"Waiting for GDB process to terminate...\")\n\n            for proc in process_iter():\n                try:\n                    cmdline = proc.cmdline()\n                except ZombieProcess:\n                    # This is a zombie process, which psutil tracks but we cannot interact with\n                    continue\n\n                if cmdline_target == cmdline:\n                    gdb_process = proc\n                    break\n            else:\n                raise RuntimeError(\"GDB process not found.\")\n\n            while gdb_process.is_running() and gdb_process.status() != STATUS_ZOMBIE:\n                # As the GDB process is in a different group, we do not have the authority to wait on it\n                # So we must keep polling it until it is no longer running\n                pass\n\n        return wait_for_termination\n\n    def _open_gdb_in_shell(self: InternalDebugger, script_path: str) -&gt; None:\n        \"\"\"Open GDB in the current shell.\n\n        Args:\n            script_path (str): The path to the script to run in the terminal.\n        \"\"\"\n        gdb_pid = os.fork()\n\n        if gdb_pid == 0:  # This is the child process.\n            os.execv(\"/bin/bash\", [\"/bin/bash\", script_path])\n            raise RuntimeError(\"Failed to execute GDB.\")\n\n        # This is the parent process.\n        # Parent ignores SIGINT, so only GDB (child) receives it\n        signal.signal(signal.SIGINT, signal.SIG_IGN)\n\n        def wait_for_termination() -&gt; None:\n            # Wait for the child process to finish\n            os.waitpid(gdb_pid, 0)\n\n            # Reset the SIGINT behavior to default handling after child exits\n            signal.signal(signal.SIGINT, signal.SIG_DFL)\n\n        return wait_for_termination\n\n    def _wait_for_gdb(self: InternalDebugger, terminal_pid: int, cmdline_target: list[str]) -&gt; None:\n        \"\"\"Waits for GDB to open in the terminal.\n\n        Args:\n            terminal_pid (int): The PID of the terminal process.\n            cmdline_target (list[str]): The command line that we are looking for.\n        \"\"\"\n        # We need to wait for GDB to open in the terminal. However, different terminals have different behaviors\n        # so we need to manually check if the terminal is still alive and if GDB has opened\n        waiting_for_gdb = True\n        terminal_alive = False\n        scan_after_terminal_death = 0\n        scan_after_terminal_death_max = 3\n        while waiting_for_gdb:\n            terminal_alive = False\n            for proc in process_iter():\n                try:\n                    cmdline = proc.cmdline()\n                    if cmdline == cmdline_target:\n                        waiting_for_gdb = False\n                    elif proc.pid == terminal_pid:\n                        terminal_alive = True\n                except ZombieProcess:\n                    # This is a zombie process, which psutil tracks but we cannot interact with\n                    continue\n            if not terminal_alive and waiting_for_gdb and scan_after_terminal_death &lt; scan_after_terminal_death_max:\n                # If the terminal has died, we need to wait a bit before we can be sure that GDB will not open.\n                # Indeed, some terminals take different steps to open GDB. We must be sure to refresh the list\n                # of processes. One extra iteration should be enough, but we will iterate more just to be sure.\n                scan_after_terminal_death += 1\n            elif not terminal_alive and waiting_for_gdb:\n                # If the terminal has died and GDB has not opened, we are sure that GDB will not open\n                raise RuntimeError(\"Failed to open GDB in terminal.\")\n\n    def _resume_from_gdb(self: InternalDebugger) -&gt; None:\n        \"\"\"Resumes the process after migrating from GDB.\"\"\"\n        self.__polling_thread_command_queue.put((self.__threaded_migrate_from_gdb, ()))\n\n        self._join_and_check_status()\n\n        self._is_migrated_to_gdb = False\n\n    def _background_step(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\n\n        Args:\n            thread (ThreadContext): The thread to step. Defaults to None.\n        \"\"\"\n        self.__threaded_step(thread)\n        self.__threaded_wait()\n\n    @background_alias(_background_step)\n    @change_state_function_thread\n    def step(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\n\n        Args:\n            thread (ThreadContext): The thread to step. Defaults to None.\n        \"\"\"\n        self._ensure_process_stopped()\n        self.__polling_thread_command_queue.put((self.__threaded_step, (thread,)))\n        self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n        self._join_and_check_status()\n\n    def _background_step_until(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        position: int | str,\n        max_steps: int = -1,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Executes instructions of the process until the specified location is reached.\n\n        Args:\n            thread (ThreadContext): The thread to step. Defaults to None.\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        if isinstance(position, str):\n            address = self.resolve_symbol(position, file)\n        else:\n            address = self.resolve_address(position, file)\n\n        self.__threaded_step_until(thread, address, max_steps)\n\n    @background_alias(_background_step_until)\n    @change_state_function_thread\n    def step_until(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        position: int | str,\n        max_steps: int = -1,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Executes instructions of the process until the specified location is reached.\n\n        Args:\n            thread (ThreadContext): The thread to step. Defaults to None.\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        if isinstance(position, str):\n            address = self.resolve_symbol(position, file)\n        else:\n            address = self.resolve_address(position, file)\n\n        arguments = (\n            thread,\n            address,\n            max_steps,\n        )\n\n        self.__polling_thread_command_queue.put((self.__threaded_step_until, arguments))\n\n        self._join_and_check_status()\n\n    def _background_finish(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        heuristic: str = \"backtrace\",\n    ) -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            thread (ThreadContext): The thread to finish.\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self.__threaded_finish(thread, heuristic)\n\n    @background_alias(_background_finish)\n    @change_state_function_thread\n    def finish(self: InternalDebugger, thread: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            thread (ThreadContext): The thread to finish.\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_finish, (thread, heuristic)),\n        )\n\n        self._join_and_check_status()\n\n    def _background_next(\n        self: InternalDebugger,\n        thread: ThreadContext,\n    ) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self.__threaded_next(thread)\n\n    @background_alias(_background_next)\n    @change_state_function_thread\n    def next(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self._ensure_process_stopped()\n        self.__polling_thread_command_queue.put((self.__threaded_next, (thread,)))\n        self._join_and_check_status()\n\n    def enable_pretty_print(\n        self: InternalDebugger,\n    ) -&gt; SyscallHandler:\n        \"\"\"Handles a syscall in the target process to pretty prints its arguments and return value.\"\"\"\n        self._ensure_process_stopped()\n\n        syscall_numbers = get_all_syscall_numbers(self.arch)\n\n        for syscall_number in syscall_numbers:\n            # Check if the syscall is already handled (by the user or by the pretty print handler)\n            if syscall_number in self.handled_syscalls:\n                handler = self.handled_syscalls[syscall_number]\n                if syscall_number not in (self.syscalls_to_not_pprint or []) and syscall_number in (\n                    self.syscalls_to_pprint or syscall_numbers\n                ):\n                    handler.on_enter_pprint = pprint_on_enter\n                    handler.on_exit_pprint = pprint_on_exit\n                else:\n                    # Remove the pretty print handler from previous pretty print calls\n                    handler.on_enter_pprint = None\n                    handler.on_exit_pprint = None\n            elif syscall_number not in (self.syscalls_to_not_pprint or []) and syscall_number in (\n                self.syscalls_to_pprint or syscall_numbers\n            ):\n                handler = SyscallHandler(\n                    syscall_number,\n                    None,\n                    None,\n                    pprint_on_enter,\n                    pprint_on_exit,\n                )\n\n                link_to_internal_debugger(handler, self)\n\n                # We have to disable the handler since it is not user-defined\n                handler.disable()\n\n                self.__polling_thread_command_queue.put(\n                    (self.__threaded_handle_syscall, (handler,)),\n                )\n\n        self._join_and_check_status()\n\n    def disable_pretty_print(self: InternalDebugger) -&gt; None:\n        \"\"\"Disable the handler for all the syscalls that are pretty printed.\"\"\"\n        self._ensure_process_stopped()\n\n        installed_handlers = list(self.handled_syscalls.values())\n        for handler in installed_handlers:\n            if handler.on_enter_pprint or handler.on_exit_pprint:\n                if handler.on_enter_user or handler.on_exit_user:\n                    handler.on_enter_pprint = None\n                    handler.on_exit_pprint = None\n                else:\n                    self.__polling_thread_command_queue.put(\n                        (self.__threaded_unhandle_syscall, (handler,)),\n                    )\n\n        self._join_and_check_status()\n\n    def insert_new_thread(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        \"\"\"Insert a new thread in the context.\n\n        Args:\n            thread (ThreadContext): the thread to insert.\n        \"\"\"\n        if thread in self.threads:\n            raise RuntimeError(\"Thread already registered.\")\n\n        self.threads.append(thread)\n\n    def set_thread_as_dead(\n        self: InternalDebugger,\n        thread_id: int,\n        exit_code: int | None,\n        exit_signal: int | None,\n    ) -&gt; None:\n        \"\"\"Set a thread as dead and update its exit code and exit signal.\n\n        Args:\n            thread_id (int): the ID of the thread to set as dead.\n            exit_code (int, optional): the exit code of the thread.\n            exit_signal (int, optional): the exit signal of the thread.\n        \"\"\"\n        for thread in self.threads:\n            if thread.thread_id == thread_id:\n                thread.set_as_dead()\n                thread._exit_code = exit_code\n                thread._exit_signal = exit_signal\n                break\n\n    def get_thread_by_id(self: InternalDebugger, thread_id: int) -&gt; ThreadContext:\n        \"\"\"Get a thread by its ID.\n\n        Args:\n            thread_id (int): the ID of the thread to get.\n\n        Returns:\n            ThreadContext: the thread with the specified ID.\n        \"\"\"\n        for thread in self.threads:\n            if thread.thread_id == thread_id and not thread.dead:\n                return thread\n\n        return None\n\n    def resolve_address(\n        self: InternalDebugger,\n        address: int,\n        backing_file: str,\n        skip_absolute_address_validation: bool = False,\n    ) -&gt; int:\n        \"\"\"Normalizes and validates the specified address.\n\n        Args:\n            address (int): The address to normalize and validate.\n            backing_file (str): The backing file to resolve the address in.\n            skip_absolute_address_validation (bool, optional): Whether to skip bounds checking for absolute addresses. Defaults to False.\n\n        Returns:\n            int: The normalized and validated address.\n\n        Raises:\n            ValueError: If the substring `backing_file` is present in multiple backing files.\n        \"\"\"\n        if skip_absolute_address_validation and backing_file == \"absolute\":\n            return address\n\n        maps = self.maps\n\n        if backing_file in [\"hybrid\", \"absolute\"]:\n            if maps.filter(address):\n                # If the address is absolute, we can return it directly\n                return address\n            elif backing_file == \"absolute\":\n                # The address is explicitly an absolute address but we did not find it\n                raise ValueError(\n                    \"The specified absolute address does not exist. Check the address or specify a backing file.\",\n                )\n            else:\n                # If the address was not found and the backing file is not \"absolute\",\n                # we have to assume it is in the main map\n                backing_file = self._process_full_path\n                liblog.warning(\n                    f\"No backing file specified and no corresponding absolute address found for {hex(address)}. Assuming {backing_file}.\",\n                )\n\n        filtered_maps = maps.filter(backing_file)\n\n        return normalize_and_validate_address(address, filtered_maps)\n\n    def resolve_symbol(self: InternalDebugger, symbol: str, backing_file: str) -&gt; int:\n        \"\"\"Resolves the address of the specified symbol.\n\n        Args:\n            symbol (str): The symbol to resolve.\n            backing_file (str): The backing file to resolve the symbol in.\n\n        Returns:\n            int: The address of the symbol.\n        \"\"\"\n        if backing_file == \"absolute\":\n            raise ValueError(\"Cannot use `absolute` backing file with symbols.\")\n\n        if backing_file == \"hybrid\":\n            # If no explicit backing file is specified, we have to assume it is in the main map\n            backing_file = self._process_full_path\n            liblog.debugger(f\"No backing file specified for the symbol {symbol}. Assuming {backing_file}.\")\n        elif backing_file in [\"binary\", self._process_name]:\n            backing_file = self._process_full_path\n\n        filtered_maps = self.maps.filter(backing_file)\n\n        return resolve_symbol_in_maps(symbol, filtered_maps)\n\n    @property\n    def symbols(self: InternalDebugger) -&gt; SymbolList[Symbol]:\n        \"\"\"Get the symbols of the process.\"\"\"\n        self._ensure_process_stopped()\n        backing_files = {vmap.backing_file for vmap in self.maps}\n        with extend_internal_debugger(self):\n            return get_all_symbols(backing_files)\n\n    def _background_ensure_process_stopped(self: InternalDebugger) -&gt; None:\n        \"\"\"Validates the state of the process.\"\"\"\n        # There is no case where this should ever happen, but...\n        if self._is_migrated_to_gdb:\n            raise RuntimeError(\"Cannot execute this command after migrating to GDB.\")\n\n    @background_alias(_background_ensure_process_stopped)\n    def _ensure_process_stopped(self: InternalDebugger) -&gt; None:\n        \"\"\"Validates the state of the process.\"\"\"\n        if self._is_migrated_to_gdb:\n            raise RuntimeError(\"Cannot execute this command after migrating to GDB.\")\n\n        if not self.running:\n            return\n\n        if self.auto_interrupt_on_command:\n            self.interrupt()\n\n        self._join_and_check_status()\n\n    def _is_in_background(self: InternalDebugger) -&gt; None:\n        return current_thread() == self.__polling_thread\n\n    def __polling_thread_function(self: InternalDebugger) -&gt; None:\n        \"\"\"This function is run in a thread. It is used to poll the process for state change.\"\"\"\n        while True:\n            # Wait for the main thread to signal a command to execute\n            command, args = self.__polling_thread_command_queue.get()\n\n            if command == THREAD_TERMINATE:\n                # Signal that the command has been executed\n                self.__polling_thread_command_queue.task_done()\n                return\n\n            # Execute the command\n            try:\n                return_value = command(*args)\n            except BaseException as e:\n                return_value = e\n\n            if return_value is not None:\n                self.__polling_thread_response_queue.put(return_value)\n\n            # Signal that the command has been executed\n            self.__polling_thread_command_queue.task_done()\n\n            if return_value is not None:\n                self.__polling_thread_response_queue.join()\n\n    def _join_and_check_status(self: InternalDebugger) -&gt; None:\n        # Wait for the background thread to signal \"task done\" before returning\n        # We don't want any asynchronous behaviour here\n        self.__polling_thread_command_queue.join()\n\n        # Check for any exceptions raised by the background thread\n        if not self.__polling_thread_response_queue.empty():\n            response = self.__polling_thread_response_queue.get()\n            self.__polling_thread_response_queue.task_done()\n            if response is not None:\n                raise response\n\n    @functools.cached_property\n    def _process_full_path(self: InternalDebugger) -&gt; str:\n        \"\"\"Get the full path of the process.\n\n        Returns:\n            str: the full path of the process.\n        \"\"\"\n        return str(Path(f\"/proc/{self.process_id}/exe\").readlink())\n\n    @functools.cached_property\n    def _process_name(self: InternalDebugger) -&gt; str:\n        \"\"\"Get the name of the process.\n\n        Returns:\n            str: the name of the process.\n        \"\"\"\n        with Path(f\"/proc/{self.process_id}/comm\").open() as f:\n            return f.read().strip()\n\n    def __threaded_run(self: InternalDebugger, redirect_pipes: bool) -&gt; None:\n        liblog.debugger(\"Starting process %s.\", self.argv[0])\n        self.debugging_interface.run(redirect_pipes)\n\n        self.set_stopped()\n\n    def __threaded_attach(self: InternalDebugger, pid: int) -&gt; None:\n        liblog.debugger(\"Attaching to process %d.\", pid)\n        self.debugging_interface.attach(pid)\n\n        self.set_stopped()\n\n    def __threaded_detach(self: InternalDebugger) -&gt; None:\n        liblog.debugger(\"Detaching from process %d.\", self.process_id)\n        self.debugging_interface.detach()\n\n        self.set_stopped()\n\n    def __threaded_kill(self: InternalDebugger) -&gt; None:\n        if self.argv:\n            liblog.debugger(\n                \"Killing process %s (%d).\",\n                self.argv[0],\n                self.process_id,\n            )\n        else:\n            liblog.debugger(\"Killing process %d.\", self.process_id)\n        self.debugging_interface.kill()\n\n    def __threaded_cont(self: InternalDebugger) -&gt; None:\n        if self.argv:\n            liblog.debugger(\n                \"Continuing process %s (%d).\",\n                self.argv[0],\n                self.process_id,\n            )\n        else:\n            liblog.debugger(\"Continuing process %d.\", self.process_id)\n\n        self.set_running()\n        self.debugging_interface.cont()\n\n    def __threaded_wait(self: InternalDebugger) -&gt; None:\n        if self.argv:\n            liblog.debugger(\n                \"Waiting for process %s (%d) to stop.\",\n                self.argv[0],\n                self.process_id,\n            )\n        else:\n            liblog.debugger(\"Waiting for process %d to stop.\", self.process_id)\n\n        while True:\n            if self.threads[0].dead:\n                # All threads are dead\n                liblog.debugger(\"All threads dead\")\n                break\n            self.resume_context.resume = True\n            self.debugging_interface.wait()\n            if self.resume_context.resume:\n                self.debugging_interface.cont()\n            else:\n                break\n        self.set_stopped()\n\n    def __threaded_breakpoint(self: InternalDebugger, bp: Breakpoint) -&gt; None:\n        liblog.debugger(\"Setting breakpoint at 0x%x.\", bp.address)\n        self.debugging_interface.set_breakpoint(bp)\n\n    def __threaded_catch_signal(self: InternalDebugger, catcher: SignalCatcher) -&gt; None:\n        liblog.debugger(\n            f\"Setting the catcher for signal {resolve_signal_name(catcher.signal_number)} ({catcher.signal_number}).\",\n        )\n        self.debugging_interface.set_signal_catcher(catcher)\n\n    def __threaded_handle_syscall(self: InternalDebugger, handler: SyscallHandler) -&gt; None:\n        liblog.debugger(f\"Setting the handler for syscall {handler.syscall_number}.\")\n        self.debugging_interface.set_syscall_handler(handler)\n\n    def __threaded_unhandle_syscall(self: InternalDebugger, handler: SyscallHandler) -&gt; None:\n        liblog.debugger(f\"Unsetting the handler for syscall {handler.syscall_number}.\")\n        self.debugging_interface.unset_syscall_handler(handler)\n\n    def __threaded_step(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        liblog.debugger(\"Stepping thread %s.\", thread.thread_id)\n        self.debugging_interface.step(thread)\n        self.set_running()\n\n    def __threaded_step_until(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        address: int,\n        max_steps: int,\n    ) -&gt; None:\n        liblog.debugger(\"Stepping thread %s until 0x%x.\", thread.thread_id, address)\n        self.debugging_interface.step_until(thread, address, max_steps)\n        self.set_stopped()\n\n    def __threaded_finish(self: InternalDebugger, thread: ThreadContext, heuristic: str) -&gt; None:\n        prefix = heuristic.capitalize()\n\n        liblog.debugger(f\"{prefix} finish on thread %s\", thread.thread_id)\n        self.debugging_interface.finish(thread, heuristic=heuristic)\n\n        self.set_stopped()\n\n    def __threaded_next(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n        liblog.debugger(\"Next on thread %s.\", thread.thread_id)\n        self.debugging_interface.next(thread)\n        self.set_stopped()\n\n    def __threaded_gdb(self: InternalDebugger) -&gt; None:\n        self.debugging_interface.migrate_to_gdb()\n\n    def __threaded_migrate_from_gdb(self: InternalDebugger) -&gt; None:\n        self.debugging_interface.migrate_from_gdb()\n\n    def __threaded_peek_memory(self: InternalDebugger, address: int) -&gt; bytes | BaseException:\n        value = self.debugging_interface.peek_memory(address)\n        return value.to_bytes(get_platform_register_size(libcontext.platform), sys.byteorder)\n\n    def __threaded_poke_memory(self: InternalDebugger, address: int, data: bytes) -&gt; None:\n        int_data = int.from_bytes(data, sys.byteorder)\n        self.debugging_interface.poke_memory(address, int_data)\n\n    def __threaded_fetch_fp_registers(self: InternalDebugger, registers: Registers) -&gt; None:\n        self.debugging_interface.fetch_fp_registers(registers)\n\n    def __threaded_flush_fp_registers(self: InternalDebugger, registers: Registers) -&gt; None:\n        self.debugging_interface.flush_fp_registers(registers)\n\n    @background_alias(__threaded_peek_memory)\n    def _peek_memory(self: InternalDebugger, address: int) -&gt; bytes:\n        \"\"\"Reads memory from the process.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot access memory.\")\n\n        if self.running:\n            # Reading memory while the process is running could lead to concurrency issues\n            # and corrupted values\n            liblog.debugger(\n                \"Process is running. Waiting for it to stop before reading memory.\",\n            )\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_peek_memory, (address,)),\n        )\n\n        # We cannot call _join_and_check_status here, as we need the return value which might not be an exception\n        self.__polling_thread_command_queue.join()\n\n        value = self.__polling_thread_response_queue.get()\n        self.__polling_thread_response_queue.task_done()\n\n        if isinstance(value, BaseException):\n            raise value\n\n        return value\n\n    def _fast_read_memory(self: InternalDebugger, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the process.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot access memory.\")\n\n        if self.running:\n            # Reading memory while the process is running could lead to concurrency issues\n            # and corrupted values\n            liblog.debugger(\n                \"Process is running. Waiting for it to stop before reading memory.\",\n            )\n\n        self._ensure_process_stopped()\n\n        return self._process_memory_manager.read(address, size)\n\n    @background_alias(__threaded_poke_memory)\n    def _poke_memory(self: InternalDebugger, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the process.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot access memory.\")\n\n        if self.running:\n            # Reading memory while the process is running could lead to concurrency issues\n            # and corrupted values\n            liblog.debugger(\n                \"Process is running. Waiting for it to stop before writing to memory.\",\n            )\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_poke_memory, (address, data)),\n        )\n\n        self._join_and_check_status()\n\n    def _fast_write_memory(self: InternalDebugger, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the process.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot access memory.\")\n\n        if self.running:\n            # Reading memory while the process is running could lead to concurrency issues\n            # and corrupted values\n            liblog.debugger(\n                \"Process is running. Waiting for it to stop before writing to memory.\",\n            )\n\n        self._ensure_process_stopped()\n\n        self._process_memory_manager.write(address, data)\n\n    @background_alias(__threaded_fetch_fp_registers)\n    def _fetch_fp_registers(self: InternalDebugger, registers: Registers) -&gt; None:\n        \"\"\"Fetches the floating point registers of a thread.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot read floating-point registers.\")\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_fetch_fp_registers, (registers,)),\n        )\n\n        self._join_and_check_status()\n\n    @background_alias(__threaded_flush_fp_registers)\n    def _flush_fp_registers(self: InternalDebugger, registers: Registers) -&gt; None:\n        \"\"\"Flushes the floating point registers of a thread.\"\"\"\n        if not self.is_debugging:\n            raise RuntimeError(\"Process not running, cannot write floating-point registers.\")\n\n        self._ensure_process_stopped()\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_flush_fp_registers, (registers,)),\n        )\n\n        self._join_and_check_status()\n\n    def _enable_antidebug_escaping(self: InternalDebugger) -&gt; None:\n        \"\"\"Enables the anti-debugging escape mechanism.\"\"\"\n        handler = SyscallHandler(\n            resolve_syscall_number(self.arch, \"ptrace\"),\n            on_enter_ptrace,\n            on_exit_ptrace,\n            None,\n            None,\n        )\n\n        link_to_internal_debugger(handler, self)\n\n        self.__polling_thread_command_queue.put((self.__threaded_handle_syscall, (handler,)))\n\n        self._join_and_check_status()\n\n        # Seutp hidden state for the handler\n        handler._traceme_called = False\n        handler._command = None\n\n    @property\n    def running(self: InternalDebugger) -&gt; bool:\n        \"\"\"Get the state of the process.\n\n        Returns:\n            bool: True if the process is running, False otherwise.\n        \"\"\"\n        return self._is_running\n\n    def set_running(self: InternalDebugger) -&gt; None:\n        \"\"\"Set the state of the process to running.\"\"\"\n        self._is_running = True\n\n    def set_stopped(self: InternalDebugger) -&gt; None:\n        \"\"\"Set the state of the process to stopped.\"\"\"\n        self._is_running = False\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__polling_thread","title":"<code>__polling_thread: Thread | None</code>  <code>instance-attribute</code>","text":"<p>The background thread used to poll the process for state change.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__polling_thread_command_queue","title":"<code>__polling_thread_command_queue: Queue | None = Queue()</code>  <code>instance-attribute</code>","text":"<p>The queue used to send commands to the background thread.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__polling_thread_response_queue","title":"<code>__polling_thread_response_queue: Queue | None = Queue()</code>  <code>instance-attribute</code>","text":"<p>The queue used to receive responses from the background thread.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.arch","title":"<code>arch: str = map_arch(libcontext.platform)</code>  <code>instance-attribute</code>","text":"<p>The architecture of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.argv","title":"<code>argv: list[str] = []</code>  <code>instance-attribute</code>","text":"<p>The command line arguments of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.aslr_enabled","title":"<code>aslr_enabled: bool = False</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if ASLR is enabled or not.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.auto_interrupt_on_command","title":"<code>auto_interrupt_on_command: bool</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should automatically interrupt the debugged process when a command is issued.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.autoreach_entrypoint","title":"<code>autoreach_entrypoint: bool = True</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should automatically reach the entry point of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.breakpoints","title":"<code>breakpoints: dict[int, Breakpoint] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of all the breakpoints set on the process. Key: the address of the breakpoint.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.caught_signals","title":"<code>caught_signals: dict[int, SignalCatcher] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of all the signals caught in the process. Key: the signal number.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.debugger","title":"<code>debugger: Debugger</code>  <code>instance-attribute</code>","text":"<p>The debugger object.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.debugging_interface","title":"<code>debugging_interface: DebuggingInterface</code>  <code>instance-attribute</code>","text":"<p>The debugging interface used to communicate with the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.env","title":"<code>env: dict[str, str] | None = {}</code>  <code>instance-attribute</code>","text":"<p>The environment variables of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.escape_antidebug","title":"<code>escape_antidebug: bool = False</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should escape anti-debugging techniques.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.fast_memory","title":"<code>fast_memory: bool = False</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should use a faster memory access method.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.handled_syscalls","title":"<code>handled_syscalls: dict[int, SyscallHandler] = {}</code>  <code>instance-attribute</code>","text":"<p>A dictionary of all the syscall handled in the process. Key: the syscall number.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.instanced","title":"<code>instanced: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the process was started and has not been killed yet.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.is_debugging","title":"<code>is_debugging: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether the debugger is currently debugging a process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.kill_on_exit","title":"<code>kill_on_exit: bool = True</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should kill the debugged process when it exits.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.maps","title":"<code>maps: MemoryMapList[MemoryMap]</code>  <code>property</code>","text":"<p>Returns the memory maps of the process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.memory","title":"<code>memory: AbstractMemoryView</code>  <code>property</code>","text":"<p>The memory view of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.pipe_manager","title":"<code>pipe_manager: PipeManager = None</code>  <code>instance-attribute</code>","text":"<p>The PipeManager used to communicate with the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.pprint_syscalls","title":"<code>pprint_syscalls: bool = False</code>  <code>instance-attribute</code>","text":"<p>A flag that indicates if the debugger should pretty print syscalls.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.process_id","title":"<code>process_id: int = 0</code>  <code>instance-attribute</code>","text":"<p>The PID of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.resume_context","title":"<code>resume_context: ResumeContext = ResumeContext()</code>  <code>instance-attribute</code>","text":"<p>Context that indicates if the debugger should resume the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Get the state of the process.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the process is running, False otherwise.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.signals_to_block","title":"<code>signals_to_block: list[int] = []</code>  <code>instance-attribute</code>","text":"<p>The signals to not forward to the process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.stdin_settings_backup","title":"<code>stdin_settings_backup: list[Any] = []</code>  <code>instance-attribute</code>","text":"<p>The backup of the stdin settings. Used to restore the original settings after possible conflicts due to the pipe manager interacactive mode.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.symbols","title":"<code>symbols: SymbolList[Symbol]</code>  <code>property</code>","text":"<p>Get the symbols of the process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.syscalls_to_not_pprint","title":"<code>syscalls_to_not_pprint: list[int] | None = None</code>  <code>instance-attribute</code>","text":"<p>The syscalls to not pretty print.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.syscalls_to_pprint","title":"<code>syscalls_to_pprint: list[int] | None = None</code>  <code>instance-attribute</code>","text":"<p>The syscalls to pretty print.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.threads","title":"<code>threads: list[ThreadContext] = []</code>  <code>instance-attribute</code>","text":"<p>A list of all the threads of the debugged process.</p>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the context.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def __init__(self: InternalDebugger) -&gt; None:\n    \"\"\"Initialize the context.\"\"\"\n    # These must be reinitialized on every call to \"debugger\"\n    self.aslr_enabled = False\n    self.autoreach_entrypoint = True\n    self.argv = []\n    self.env = {}\n    self.escape_antidebug = False\n    self.breakpoints = {}\n    self.handled_syscalls = {}\n    self.caught_signals = {}\n    self.syscalls_to_pprint = None\n    self.syscalls_to_not_pprint = None\n    self.signals_to_block = []\n    self.pprint_syscalls = False\n    self.pipe_manager = None\n    self.process_id = 0\n    self.threads = []\n    self.instanced = False\n    self.is_debugging = False\n    self._is_running = False\n    self._is_migrated_to_gdb = False\n    self.resume_context = ResumeContext()\n    self.stdin_settings_backup = []\n    self.arch = map_arch(libcontext.platform)\n    self.kill_on_exit = True\n    self._process_memory_manager = ProcessMemoryManager()\n    self.fast_memory = False\n    self.__polling_thread_command_queue = Queue()\n    self.__polling_thread_response_queue = Queue()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.__polling_thread_function","title":"<code>__polling_thread_function()</code>","text":"<p>This function is run in a thread. It is used to poll the process for state change.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def __polling_thread_function(self: InternalDebugger) -&gt; None:\n    \"\"\"This function is run in a thread. It is used to poll the process for state change.\"\"\"\n    while True:\n        # Wait for the main thread to signal a command to execute\n        command, args = self.__polling_thread_command_queue.get()\n\n        if command == THREAD_TERMINATE:\n            # Signal that the command has been executed\n            self.__polling_thread_command_queue.task_done()\n            return\n\n        # Execute the command\n        try:\n            return_value = command(*args)\n        except BaseException as e:\n            return_value = e\n\n        if return_value is not None:\n            self.__polling_thread_response_queue.put(return_value)\n\n        # Signal that the command has been executed\n        self.__polling_thread_command_queue.task_done()\n\n        if return_value is not None:\n            self.__polling_thread_response_queue.join()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.attach","title":"<code>attach(pid)</code>","text":"<p>Attaches to an existing process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def attach(self: InternalDebugger, pid: int) -&gt; None:\n    \"\"\"Attaches to an existing process.\"\"\"\n    if self.is_debugging:\n        liblog.debugger(\"Process already running, stopping it before restarting.\")\n        self.kill()\n    if self.threads:\n        self.clear()\n        self.debugging_interface.reset()\n\n    self.instanced = True\n    self.is_debugging = True\n\n    if not self.__polling_thread_command_queue.empty():\n        raise RuntimeError(\"Polling thread command queue not empty.\")\n\n    self.__polling_thread_command_queue.put((self.__threaded_attach, (pid,)))\n\n    self._join_and_check_status()\n\n    self._process_memory_manager.open(self.process_id)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.breakpoint","title":"<code>breakpoint(position, hardware=False, condition='x', length=1, callback=None, file='hybrid')</code>","text":"<p>Sets a breakpoint at the specified location.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location of the breakpoint.</p> required <code>hardware</code> <code>bool</code> <p>Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.</p> <code>False</code> <code>condition</code> <code>str</code> <p>The trigger condition for the breakpoint. Defaults to None.</p> <code>'x'</code> <code>length</code> <code>int</code> <p>The length of the breakpoint. Only for watchpoints. Defaults to 1.</p> <code>1</code> <code>callback</code> <code>None | bool | Callable[[ThreadContext, Breakpoint], None]</code> <p>A callback to be called when the breakpoint is hit. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef breakpoint(\n    self: InternalDebugger,\n    position: int | str,\n    hardware: bool = False,\n    condition: str = \"x\",\n    length: int = 1,\n    callback: None | bool | Callable[[ThreadContext, Breakpoint], None] = None,\n    file: str = \"hybrid\",\n) -&gt; Breakpoint:\n    \"\"\"Sets a breakpoint at the specified location.\n\n    Args:\n        position (int | bytes): The location of the breakpoint.\n        hardware (bool, optional): Whether the breakpoint should be hardware-assisted or purely software. Defaults to False.\n        condition (str, optional): The trigger condition for the breakpoint. Defaults to None.\n        length (int, optional): The length of the breakpoint. Only for watchpoints. Defaults to 1.\n        callback (None | bool | Callable[[ThreadContext, Breakpoint], None], optional): A callback to be called when the breakpoint is hit. If True, an empty callback will be set. Defaults to None.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n    \"\"\"\n    if isinstance(position, str):\n        address = self.resolve_symbol(position, file)\n    else:\n        address = self.resolve_address(position, file)\n        position = hex(address)\n\n    if condition != \"x\" and not hardware:\n        raise ValueError(\"Breakpoint condition is supported only for hardware watchpoints.\")\n\n    if callback is True:\n\n        def callback(_: ThreadContext, __: Breakpoint) -&gt; None:\n            pass\n\n    bp = Breakpoint(address, position, 0, hardware, callback, condition.lower(), length)\n\n    if hardware:\n        validate_hardware_breakpoint(self.arch, bp)\n\n    link_to_internal_debugger(bp, self)\n\n    self.__polling_thread_command_queue.put((self.__threaded_breakpoint, (bp,)))\n\n    self._join_and_check_status()\n\n    # the breakpoint should have been set by interface\n    if address not in self.breakpoints:\n        raise RuntimeError(\"Something went wrong while inserting the breakpoint.\")\n\n    return bp\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.catch_signal","title":"<code>catch_signal(signal, callback=None, recursive=False)</code>","text":"<p>Catch a signal in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>signal</code> <code>int | str</code> <p>The signal to catch. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be caught.</p> required <code>callback</code> <code>None | bool | Callable[[ThreadContext, SignalCatcher], None]</code> <p>A callback to be called when the signal is caught. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SignalCatcher</code> <code>SignalCatcher</code> <p>The SignalCatcher object.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef catch_signal(\n    self: InternalDebugger,\n    signal: int | str,\n    callback: None | bool | Callable[[ThreadContext, SignalCatcher], None] = None,\n    recursive: bool = False,\n) -&gt; SignalCatcher:\n    \"\"\"Catch a signal in the target process.\n\n    Args:\n        signal (int | str): The signal to catch. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be caught.\n        callback (None | bool | Callable[[ThreadContext, SignalCatcher], None], optional): A callback to be called when the signal is caught. If True, an empty callback will be set. Defaults to None.\n        recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n\n    Returns:\n        SignalCatcher: The SignalCatcher object.\n    \"\"\"\n    if isinstance(signal, str):\n        signal_number = resolve_signal_number(signal)\n    elif isinstance(signal, int):\n        signal_number = signal\n    else:\n        raise TypeError(\"signal must be an int or a str\")\n\n    match signal_number:\n        case SIGKILL.value:\n            raise ValueError(\n                f\"Cannot catch SIGKILL ({signal_number}) as it cannot be caught or ignored. This is a kernel restriction.\",\n            )\n        case SIGSTOP.value:\n            raise ValueError(\n                f\"Cannot catch SIGSTOP ({signal_number}) as it is used by the debugger or ptrace for their internal operations.\",\n            )\n        case SIGTRAP.value:\n            raise ValueError(\n                f\"Cannot catch SIGTRAP ({signal_number}) as it is used by the debugger or ptrace for their internal operations.\",\n            )\n\n    if signal_number in self.caught_signals:\n        liblog.warning(\n            f\"Signal {resolve_signal_name(signal_number)} ({signal_number}) has already been caught. Overriding it.\",\n        )\n\n    if not isinstance(recursive, bool):\n        raise TypeError(\"recursive must be a boolean\")\n\n    if callback is True:\n\n        def callback(_: ThreadContext, __: SignalCatcher) -&gt; None:\n            pass\n\n    catcher = SignalCatcher(signal_number, callback, recursive)\n\n    link_to_internal_debugger(catcher, self)\n\n    self.__polling_thread_command_queue.put((self.__threaded_catch_signal, (catcher,)))\n\n    self._join_and_check_status()\n\n    return catcher\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.clear","title":"<code>clear()</code>","text":"<p>Reinitializes the context, so it is ready for a new run.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def clear(self: InternalDebugger) -&gt; None:\n    \"\"\"Reinitializes the context, so it is ready for a new run.\"\"\"\n    # These must be reinitialized on every call to \"run\"\n    self.breakpoints.clear()\n    self.handled_syscalls.clear()\n    self.caught_signals.clear()\n    self.syscalls_to_pprint = None\n    self.syscalls_to_not_pprint = None\n    self.signals_to_block.clear()\n    self.pprint_syscalls = False\n    self.pipe_manager = None\n    self.process_id = 0\n    self.threads.clear()\n    self.instanced = False\n    self.is_debugging = False\n    self._is_running = False\n    self.resume_context.clear()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.cont","title":"<code>cont()</code>","text":"<p>Continues the process.</p> <p>Parameters:</p> Name Type Description Default <code>auto_wait</code> <code>bool</code> <p>Whether to automatically wait for the process to stop after continuing. Defaults to True.</p> required Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef cont(self: InternalDebugger) -&gt; None:\n    \"\"\"Continues the process.\n\n    Args:\n        auto_wait (bool, optional): Whether to automatically wait for the process to stop after continuing. Defaults to True.\n    \"\"\"\n    self.__polling_thread_command_queue.put((self.__threaded_cont, ()))\n\n    self._join_and_check_status()\n\n    self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.detach","title":"<code>detach()</code>","text":"<p>Detaches from the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def detach(self: InternalDebugger) -&gt; None:\n    \"\"\"Detaches from the process.\"\"\"\n    if not self.is_debugging:\n        raise RuntimeError(\"Process not running, cannot detach.\")\n\n    self._ensure_process_stopped()\n\n    self.__polling_thread_command_queue.put((self.__threaded_detach, ()))\n\n    self.is_debugging = False\n\n    self._join_and_check_status()\n\n    self._process_memory_manager.close()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.disable_pretty_print","title":"<code>disable_pretty_print()</code>","text":"<p>Disable the handler for all the syscalls that are pretty printed.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def disable_pretty_print(self: InternalDebugger) -&gt; None:\n    \"\"\"Disable the handler for all the syscalls that are pretty printed.\"\"\"\n    self._ensure_process_stopped()\n\n    installed_handlers = list(self.handled_syscalls.values())\n    for handler in installed_handlers:\n        if handler.on_enter_pprint or handler.on_exit_pprint:\n            if handler.on_enter_user or handler.on_exit_user:\n                handler.on_enter_pprint = None\n                handler.on_exit_pprint = None\n            else:\n                self.__polling_thread_command_queue.put(\n                    (self.__threaded_unhandle_syscall, (handler,)),\n                )\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.enable_pretty_print","title":"<code>enable_pretty_print()</code>","text":"<p>Handles a syscall in the target process to pretty prints its arguments and return value.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def enable_pretty_print(\n    self: InternalDebugger,\n) -&gt; SyscallHandler:\n    \"\"\"Handles a syscall in the target process to pretty prints its arguments and return value.\"\"\"\n    self._ensure_process_stopped()\n\n    syscall_numbers = get_all_syscall_numbers(self.arch)\n\n    for syscall_number in syscall_numbers:\n        # Check if the syscall is already handled (by the user or by the pretty print handler)\n        if syscall_number in self.handled_syscalls:\n            handler = self.handled_syscalls[syscall_number]\n            if syscall_number not in (self.syscalls_to_not_pprint or []) and syscall_number in (\n                self.syscalls_to_pprint or syscall_numbers\n            ):\n                handler.on_enter_pprint = pprint_on_enter\n                handler.on_exit_pprint = pprint_on_exit\n            else:\n                # Remove the pretty print handler from previous pretty print calls\n                handler.on_enter_pprint = None\n                handler.on_exit_pprint = None\n        elif syscall_number not in (self.syscalls_to_not_pprint or []) and syscall_number in (\n            self.syscalls_to_pprint or syscall_numbers\n        ):\n            handler = SyscallHandler(\n                syscall_number,\n                None,\n                None,\n                pprint_on_enter,\n                pprint_on_exit,\n            )\n\n            link_to_internal_debugger(handler, self)\n\n            # We have to disable the handler since it is not user-defined\n            handler.disable()\n\n            self.__polling_thread_command_queue.put(\n                (self.__threaded_handle_syscall, (handler,)),\n            )\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.finish","title":"<code>finish(thread, heuristic='backtrace')</code>","text":"<p>Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to finish.</p> required <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> <code>'backtrace'</code> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_finish)\n@change_state_function_thread\ndef finish(self: InternalDebugger, thread: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n    \"\"\"Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        thread (ThreadContext): The thread to finish.\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n    self.__polling_thread_command_queue.put(\n        (self.__threaded_finish, (thread, heuristic)),\n    )\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.gdb","title":"<code>gdb(migrate_breakpoints=True, open_in_new_process=True, blocking=True)</code>","text":"<p>Migrates the current debugging session to GDB.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef gdb(\n    self: InternalDebugger,\n    migrate_breakpoints: bool = True,\n    open_in_new_process: bool = True,\n    blocking: bool = True,\n) -&gt; GdbResumeEvent:\n    \"\"\"Migrates the current debugging session to GDB.\"\"\"\n    # TODO: not needed?\n    self.interrupt()\n\n    self.__polling_thread_command_queue.put((self.__threaded_gdb, ()))\n\n    self._join_and_check_status()\n\n    # Create the command file\n    command_file = self._craft_gdb_migration_file(migrate_breakpoints)\n\n    if open_in_new_process and libcontext.terminal:\n        lambda_fun = self._open_gdb_in_new_process(command_file)\n    elif open_in_new_process:\n        self._auto_detect_terminal()\n        if not libcontext.terminal:\n            liblog.warning(\n                \"Cannot auto-detect terminal. Please configure the terminal in libcontext.terminal. Opening gdb in the current shell.\",\n            )\n            lambda_fun = self._open_gdb_in_shell(command_file)\n        else:\n            lambda_fun = self._open_gdb_in_new_process(command_file)\n    else:\n        lambda_fun = self._open_gdb_in_shell(command_file)\n\n    resume_event = GdbResumeEvent(self, lambda_fun)\n\n    self._is_migrated_to_gdb = True\n\n    if blocking:\n        resume_event.join()\n        return None\n    else:\n        return resume_event\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.get_thread_by_id","title":"<code>get_thread_by_id(thread_id)</code>","text":"<p>Get a thread by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>the ID of the thread to get.</p> required <p>Returns:</p> Name Type Description <code>ThreadContext</code> <code>ThreadContext</code> <p>the thread with the specified ID.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def get_thread_by_id(self: InternalDebugger, thread_id: int) -&gt; ThreadContext:\n    \"\"\"Get a thread by its ID.\n\n    Args:\n        thread_id (int): the ID of the thread to get.\n\n    Returns:\n        ThreadContext: the thread with the specified ID.\n    \"\"\"\n    for thread in self.threads:\n        if thread.thread_id == thread_id and not thread.dead:\n            return thread\n\n    return None\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.handle_syscall","title":"<code>handle_syscall(syscall, on_enter=None, on_exit=None, recursive=False)</code>","text":"<p>Handle a syscall in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>syscall</code> <code>int | str</code> <p>The syscall name or number to handle. If \"*\", \"ALL\", \"all\", or -1 is passed, all syscalls will be handled.</p> required <code>on_enter</code> <code>None | bool | Callable[[ThreadContext, SyscallHandler], None]</code> <p>The callback to execute when the syscall is entered. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>on_exit</code> <code>None | bool | Callable[[ThreadContext, SyscallHandler], None]</code> <p>The callback to execute when the syscall is exited. If True, an empty callback will be set. Defaults to None.</p> <code>None</code> <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SyscallHandler</code> <code>SyscallHandler</code> <p>The SyscallHandler object.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef handle_syscall(\n    self: InternalDebugger,\n    syscall: int | str,\n    on_enter: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n    on_exit: Callable[[ThreadContext, SyscallHandler], None] | None = None,\n    recursive: bool = False,\n) -&gt; SyscallHandler:\n    \"\"\"Handle a syscall in the target process.\n\n    Args:\n        syscall (int | str): The syscall name or number to handle. If \"*\", \"ALL\", \"all\", or -1 is passed, all syscalls will be handled.\n        on_enter (None | bool |Callable[[ThreadContext, SyscallHandler], None], optional): The callback to execute when the syscall is entered. If True, an empty callback will be set. Defaults to None.\n        on_exit (None | bool | Callable[[ThreadContext, SyscallHandler], None], optional): The callback to execute when the syscall is exited. If True, an empty callback will be set. Defaults to None.\n        recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n\n    Returns:\n        SyscallHandler: The SyscallHandler object.\n    \"\"\"\n    syscall_number = resolve_syscall_number(self.arch, syscall) if isinstance(syscall, str) else syscall\n\n    if not isinstance(recursive, bool):\n        raise TypeError(\"recursive must be a boolean\")\n\n    if on_enter is True:\n\n        def on_enter(_: ThreadContext, __: SyscallHandler) -&gt; None:\n            pass\n\n    if on_exit is True:\n\n        def on_exit(_: ThreadContext, __: SyscallHandler) -&gt; None:\n            pass\n\n    # Check if the syscall is already handled (by the user or by the pretty print handler)\n    if syscall_number in self.handled_syscalls:\n        handler = self.handled_syscalls[syscall_number]\n        if handler.on_enter_user or handler.on_exit_user:\n            liblog.warning(\n                f\"Syscall {resolve_syscall_name(self.arch, syscall_number)} is already handled by a user-defined handler. Overriding it.\",\n            )\n        handler.on_enter_user = on_enter\n        handler.on_exit_user = on_exit\n        handler.recursive = recursive\n        handler.enabled = True\n    else:\n        handler = SyscallHandler(\n            syscall_number,\n            on_enter,\n            on_exit,\n            None,\n            None,\n            recursive,\n        )\n\n        link_to_internal_debugger(handler, self)\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_handle_syscall, (handler,)),\n        )\n\n        self._join_and_check_status()\n\n    return handler\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.hijack_signal","title":"<code>hijack_signal(original_signal, new_signal, recursive=False)</code>","text":"<p>Hijack a signal in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>original_signal</code> <code>int | str</code> <p>The signal to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be hijacked.</p> required <code>new_signal</code> <code>int | str</code> <p>The signal to hijack the original signal with.</p> required <code>recursive</code> <code>bool</code> <p>Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>SignalCatcher</code> <code>SignalCatcher</code> <p>The SignalCatcher object.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef hijack_signal(\n    self: InternalDebugger,\n    original_signal: int | str,\n    new_signal: int | str,\n    recursive: bool = False,\n) -&gt; SignalCatcher:\n    \"\"\"Hijack a signal in the target process.\n\n    Args:\n        original_signal (int | str): The signal to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all signals will be hijacked.\n        new_signal (int | str): The signal to hijack the original signal with.\n        recursive (bool, optional): Whether, when the signal is hijacked with another one, the signal catcher associated with the new signal should be considered as well. Defaults to False.\n\n    Returns:\n        SignalCatcher: The SignalCatcher object.\n    \"\"\"\n    if isinstance(original_signal, str):\n        original_signal_number = resolve_signal_number(original_signal)\n    else:\n        original_signal_number = original_signal\n\n    new_signal_number = resolve_signal_number(new_signal) if isinstance(new_signal, str) else new_signal\n\n    if new_signal_number == -1:\n        raise ValueError(\"Cannot hijack a signal with the 'ALL' signal.\")\n\n    if original_signal_number == new_signal_number:\n        raise ValueError(\n            \"The original signal and the new signal must be different during hijacking.\",\n        )\n\n    def callback(thread: ThreadContext, _: SignalCatcher) -&gt; None:\n        \"\"\"The callback to execute when the signal is received.\"\"\"\n        thread.signal = new_signal_number\n\n    return self.catch_signal(original_signal_number, callback, recursive)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.hijack_syscall","title":"<code>hijack_syscall(original_syscall, new_syscall, recursive=True, **kwargs)</code>","text":"<p>Hijacks a syscall in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>original_syscall</code> <code>int | str</code> <p>The syscall name or number to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be hijacked.</p> required <code>new_syscall</code> <code>int | str</code> <p>The syscall name or number to hijack the original syscall with.</p> required <code>recursive</code> <code>bool</code> <p>Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.</p> <code>True</code> <code>**kwargs</code> <code>int</code> <p>(int, optional): The arguments to pass to the new syscall.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>SyscallHandler</code> <code>SyscallHandler</code> <p>The SyscallHandler object.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\n@change_state_function_process\ndef hijack_syscall(\n    self: InternalDebugger,\n    original_syscall: int | str,\n    new_syscall: int | str,\n    recursive: bool = True,\n    **kwargs: int,\n) -&gt; SyscallHandler:\n    \"\"\"Hijacks a syscall in the target process.\n\n    Args:\n        original_syscall (int | str): The syscall name or number to hijack. If \"*\", \"ALL\", \"all\" or -1 is passed, all syscalls will be hijacked.\n        new_syscall (int | str): The syscall name or number to hijack the original syscall with.\n        recursive (bool, optional): Whether, when the syscall is hijacked with another one, the syscall handler associated with the new syscall should be considered as well. Defaults to False.\n        **kwargs: (int, optional): The arguments to pass to the new syscall.\n\n    Returns:\n        SyscallHandler: The SyscallHandler object.\n    \"\"\"\n    if set(kwargs) - SyscallHijacker.allowed_args:\n        raise ValueError(\"Invalid keyword arguments in syscall hijack\")\n\n    if isinstance(original_syscall, str):\n        original_syscall_number = resolve_syscall_number(self.arch, original_syscall)\n    else:\n        original_syscall_number = original_syscall\n\n    new_syscall_number = (\n        resolve_syscall_number(self.arch, new_syscall) if isinstance(new_syscall, str) else new_syscall\n    )\n\n    if new_syscall_number == -1:\n        raise ValueError(\"Cannot hijack a syscall with the 'ALL' syscall.\")\n\n    if original_syscall_number == new_syscall_number:\n        raise ValueError(\n            \"The original syscall and the new syscall must be different during hijacking.\",\n        )\n\n    on_enter = SyscallHijacker().create_hijacker(\n        new_syscall_number,\n        **kwargs,\n    )\n\n    # Check if the syscall is already handled (by the user or by the pretty print handler)\n    if original_syscall_number in self.handled_syscalls:\n        handler = self.handled_syscalls[original_syscall_number]\n        if handler.on_enter_user or handler.on_exit_user:\n            liblog.warning(\n                f\"Syscall {original_syscall_number} is already handled by a user-defined handler. Overriding it.\",\n            )\n        handler.on_enter_user = on_enter\n        handler.on_exit_user = None\n        handler.recursive = recursive\n        handler.enabled = True\n    else:\n        handler = SyscallHandler(\n            original_syscall_number,\n            on_enter,\n            None,\n            None,\n            None,\n            recursive,\n        )\n\n        link_to_internal_debugger(handler, self)\n\n        self.__polling_thread_command_queue.put(\n            (self.__threaded_handle_syscall, (handler,)),\n        )\n\n        self._join_and_check_status()\n\n    return handler\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.insert_new_thread","title":"<code>insert_new_thread(thread)</code>","text":"<p>Insert a new thread in the context.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>the thread to insert.</p> required Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def insert_new_thread(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n    \"\"\"Insert a new thread in the context.\n\n    Args:\n        thread (ThreadContext): the thread to insert.\n    \"\"\"\n    if thread in self.threads:\n        raise RuntimeError(\"Thread already registered.\")\n\n    self.threads.append(thread)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.interrupt","title":"<code>interrupt()</code>","text":"<p>Interrupts the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\ndef interrupt(self: InternalDebugger) -&gt; None:\n    \"\"\"Interrupts the process.\"\"\"\n    if not self.is_debugging:\n        raise RuntimeError(\"Process not running, cannot interrupt.\")\n\n    # We have to ensure that at least one thread is alive before executing the method\n    if self.threads[0].dead:\n        raise RuntimeError(\"All threads are dead.\")\n\n    if not self.running:\n        return\n\n    self.resume_context.force_interrupt = True\n    os.kill(self.process_id, SIGSTOP)\n\n    self.wait()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.kill","title":"<code>kill()</code>","text":"<p>Kills the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\ndef kill(self: InternalDebugger) -&gt; None:\n    \"\"\"Kills the process.\"\"\"\n    try:\n        self._ensure_process_stopped()\n    except (OSError, RuntimeError):\n        # This exception might occur if the process has already died\n        liblog.debugger(\"OSError raised during kill\")\n\n    self._process_memory_manager.close()\n\n    self.__polling_thread_command_queue.put((self.__threaded_kill, ()))\n\n    self.instanced = False\n    self.is_debugging = False\n\n    if self.pipe_manager:\n        self.pipe_manager.close()\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.next","title":"<code>next(thread)</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_next)\n@change_state_function_thread\ndef next(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    self._ensure_process_stopped()\n    self.__polling_thread_command_queue.put((self.__threaded_next, (thread,)))\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.pprint_maps","title":"<code>pprint_maps()</code>","text":"<p>Prints the memory maps of the process.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def pprint_maps(self: InternalDebugger) -&gt; None:\n    \"\"\"Prints the memory maps of the process.\"\"\"\n    self._ensure_process_stopped()\n    header = (\n        f\"{'start':&gt;18}  \"\n        f\"{'end':&gt;18}  \"\n        f\"{'perm':&gt;6}  \"\n        f\"{'size':&gt;8}  \"\n        f\"{'offset':&gt;8}  \"\n        f\"{'backing_file':&lt;20}\"\n    )\n    print(header)\n    for memory_map in self.maps:\n        info = (\n            f\"{memory_map.start:#18x}  \"\n            f\"{memory_map.end:#18x}  \"\n            f\"{memory_map.permissions:&gt;6}  \"\n            f\"{memory_map.size:#8x}  \"\n            f\"{memory_map.offset:#8x}  \"\n            f\"{memory_map.backing_file}\"\n        )\n        if \"rwx\" in memory_map.permissions:\n            print(f\"{ANSIColors.RED}{ANSIColors.UNDERLINE}{info}{ANSIColors.RESET}\")\n        elif \"x\" in memory_map.permissions:\n            print(f\"{ANSIColors.RED}{info}{ANSIColors.RESET}\")\n        elif \"w\" in memory_map.permissions:\n            print(f\"{ANSIColors.YELLOW}{info}{ANSIColors.RESET}\")\n        elif \"r\" in memory_map.permissions:\n            print(f\"{ANSIColors.GREEN}{info}{ANSIColors.RESET}\")\n        else:\n            print(info)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.resolve_address","title":"<code>resolve_address(address, backing_file, skip_absolute_address_validation=False)</code>","text":"<p>Normalizes and validates the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to normalize and validate.</p> required <code>backing_file</code> <code>str</code> <p>The backing file to resolve the address in.</p> required <code>skip_absolute_address_validation</code> <code>bool</code> <p>Whether to skip bounds checking for absolute addresses. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The normalized and validated address.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the substring <code>backing_file</code> is present in multiple backing files.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def resolve_address(\n    self: InternalDebugger,\n    address: int,\n    backing_file: str,\n    skip_absolute_address_validation: bool = False,\n) -&gt; int:\n    \"\"\"Normalizes and validates the specified address.\n\n    Args:\n        address (int): The address to normalize and validate.\n        backing_file (str): The backing file to resolve the address in.\n        skip_absolute_address_validation (bool, optional): Whether to skip bounds checking for absolute addresses. Defaults to False.\n\n    Returns:\n        int: The normalized and validated address.\n\n    Raises:\n        ValueError: If the substring `backing_file` is present in multiple backing files.\n    \"\"\"\n    if skip_absolute_address_validation and backing_file == \"absolute\":\n        return address\n\n    maps = self.maps\n\n    if backing_file in [\"hybrid\", \"absolute\"]:\n        if maps.filter(address):\n            # If the address is absolute, we can return it directly\n            return address\n        elif backing_file == \"absolute\":\n            # The address is explicitly an absolute address but we did not find it\n            raise ValueError(\n                \"The specified absolute address does not exist. Check the address or specify a backing file.\",\n            )\n        else:\n            # If the address was not found and the backing file is not \"absolute\",\n            # we have to assume it is in the main map\n            backing_file = self._process_full_path\n            liblog.warning(\n                f\"No backing file specified and no corresponding absolute address found for {hex(address)}. Assuming {backing_file}.\",\n            )\n\n    filtered_maps = maps.filter(backing_file)\n\n    return normalize_and_validate_address(address, filtered_maps)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.resolve_symbol","title":"<code>resolve_symbol(symbol, backing_file)</code>","text":"<p>Resolves the address of the specified symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol to resolve.</p> required <code>backing_file</code> <code>str</code> <p>The backing file to resolve the symbol in.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The address of the symbol.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def resolve_symbol(self: InternalDebugger, symbol: str, backing_file: str) -&gt; int:\n    \"\"\"Resolves the address of the specified symbol.\n\n    Args:\n        symbol (str): The symbol to resolve.\n        backing_file (str): The backing file to resolve the symbol in.\n\n    Returns:\n        int: The address of the symbol.\n    \"\"\"\n    if backing_file == \"absolute\":\n        raise ValueError(\"Cannot use `absolute` backing file with symbols.\")\n\n    if backing_file == \"hybrid\":\n        # If no explicit backing file is specified, we have to assume it is in the main map\n        backing_file = self._process_full_path\n        liblog.debugger(f\"No backing file specified for the symbol {symbol}. Assuming {backing_file}.\")\n    elif backing_file in [\"binary\", self._process_name]:\n        backing_file = self._process_full_path\n\n    filtered_maps = self.maps.filter(backing_file)\n\n    return resolve_symbol_in_maps(symbol, filtered_maps)\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.run","title":"<code>run(redirect_pipes=True)</code>","text":"<p>Starts the process and waits for it to stop.</p> <p>Parameters:</p> Name Type Description Default <code>redirect_pipes</code> <code>bool</code> <p>Whether to hook and redirect the pipes of the process to a PipeManager.</p> <code>True</code> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def run(self: InternalDebugger, redirect_pipes: bool = True) -&gt; PipeManager | None:\n    \"\"\"Starts the process and waits for it to stop.\n\n    Args:\n        redirect_pipes (bool): Whether to hook and redirect the pipes of the process to a PipeManager.\n    \"\"\"\n    if not self.argv:\n        raise RuntimeError(\"No binary file specified.\")\n\n    if not Path(self.argv[0]).is_file():\n        raise RuntimeError(f\"File {self.argv[0]} does not exist.\")\n\n    if not os.access(self.argv[0], os.X_OK):\n        raise RuntimeError(\n            f\"File {self.argv[0]} is not executable.\",\n        )\n\n    if self.is_debugging:\n        liblog.debugger(\"Process already running, stopping it before restarting.\")\n        self.kill()\n    if self.threads:\n        self.clear()\n        self.debugging_interface.reset()\n\n    self.instanced = True\n    self.is_debugging = True\n\n    if not self.__polling_thread_command_queue.empty():\n        raise RuntimeError(\"Polling thread command queue not empty.\")\n\n    self.__polling_thread_command_queue.put((self.__threaded_run, (redirect_pipes,)))\n\n    self._join_and_check_status()\n\n    if self.escape_antidebug:\n        liblog.debugger(\"Enabling anti-debugging escape mechanism.\")\n        self._enable_antidebug_escaping()\n\n    if redirect_pipes and not self.pipe_manager:\n        raise RuntimeError(\"Something went wrong during pipe initialization.\")\n\n    self._process_memory_manager.open(self.process_id)\n\n    return self.pipe_manager\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.set_running","title":"<code>set_running()</code>","text":"<p>Set the state of the process to running.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def set_running(self: InternalDebugger) -&gt; None:\n    \"\"\"Set the state of the process to running.\"\"\"\n    self._is_running = True\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.set_stopped","title":"<code>set_stopped()</code>","text":"<p>Set the state of the process to stopped.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def set_stopped(self: InternalDebugger) -&gt; None:\n    \"\"\"Set the state of the process to stopped.\"\"\"\n    self._is_running = False\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.set_thread_as_dead","title":"<code>set_thread_as_dead(thread_id, exit_code, exit_signal)</code>","text":"<p>Set a thread as dead and update its exit code and exit signal.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>the ID of the thread to set as dead.</p> required <code>exit_code</code> <code>int</code> <p>the exit code of the thread.</p> required <code>exit_signal</code> <code>int</code> <p>the exit signal of the thread.</p> required Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def set_thread_as_dead(\n    self: InternalDebugger,\n    thread_id: int,\n    exit_code: int | None,\n    exit_signal: int | None,\n) -&gt; None:\n    \"\"\"Set a thread as dead and update its exit code and exit signal.\n\n    Args:\n        thread_id (int): the ID of the thread to set as dead.\n        exit_code (int, optional): the exit code of the thread.\n        exit_signal (int, optional): the exit signal of the thread.\n    \"\"\"\n    for thread in self.threads:\n        if thread.thread_id == thread_id:\n            thread.set_as_dead()\n            thread._exit_code = exit_code\n            thread._exit_signal = exit_signal\n            break\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.start_processing_thread","title":"<code>start_processing_thread()</code>","text":"<p>Starts the thread that will poll the traced process for state change.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def start_processing_thread(self: InternalDebugger) -&gt; None:\n    \"\"\"Starts the thread that will poll the traced process for state change.\"\"\"\n    # Set as daemon so that the Python interpreter can exit even if the thread is still running\n    self.__polling_thread = Thread(\n        target=self.__polling_thread_function,\n        name=\"libdebug__polling_thread\",\n        daemon=True,\n    )\n    self.__polling_thread.start()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.start_up","title":"<code>start_up()</code>","text":"<p>Starts up the context.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def start_up(self: InternalDebugger) -&gt; None:\n    \"\"\"Starts up the context.\"\"\"\n    # The context is linked to itself\n    link_to_internal_debugger(self, self)\n\n    self.start_processing_thread()\n    with extend_internal_debugger(self):\n        self.debugging_interface = provide_debugging_interface()\n        self._fast_memory = DirectMemoryView(self._fast_read_memory, self._fast_write_memory)\n        self._slow_memory = ChunkedMemoryView(\n            self._peek_memory,\n            self._poke_memory,\n            unit_size=get_platform_register_size(libcontext.platform),\n        )\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.step","title":"<code>step(thread)</code>","text":"<p>Executes a single instruction of the process.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step. Defaults to None.</p> required Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_step)\n@change_state_function_thread\ndef step(self: InternalDebugger, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes a single instruction of the process.\n\n    Args:\n        thread (ThreadContext): The thread to step. Defaults to None.\n    \"\"\"\n    self._ensure_process_stopped()\n    self.__polling_thread_command_queue.put((self.__threaded_step, (thread,)))\n    self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.step_until","title":"<code>step_until(thread, position, max_steps=-1, file='hybrid')</code>","text":"<p>Executes instructions of the process until the specified location is reached.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step. Defaults to None.</p> required <code>position</code> <code>int | bytes</code> <p>The location to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute. Defaults to -1.</p> <code>-1</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).</p> <code>'hybrid'</code> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_step_until)\n@change_state_function_thread\ndef step_until(\n    self: InternalDebugger,\n    thread: ThreadContext,\n    position: int | str,\n    max_steps: int = -1,\n    file: str = \"hybrid\",\n) -&gt; None:\n    \"\"\"Executes instructions of the process until the specified location is reached.\n\n    Args:\n        thread (ThreadContext): The thread to step. Defaults to None.\n        position (int | bytes): The location to reach.\n        max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n    \"\"\"\n    if isinstance(position, str):\n        address = self.resolve_symbol(position, file)\n    else:\n        address = self.resolve_address(position, file)\n\n    arguments = (\n        thread,\n        address,\n        max_steps,\n    )\n\n    self.__polling_thread_command_queue.put((self.__threaded_step_until, arguments))\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.terminate","title":"<code>terminate()</code>","text":"<p>Interrupts the process, kills it and then terminates the background thread.</p> <p>The debugger object will not be usable after this method is called. This method should only be called to free up resources when the debugger object is no longer needed.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>def terminate(self: InternalDebugger) -&gt; None:\n    \"\"\"Interrupts the process, kills it and then terminates the background thread.\n\n    The debugger object will not be usable after this method is called.\n    This method should only be called to free up resources when the debugger object is no longer needed.\n    \"\"\"\n    if self.instanced and self.running:\n        try:\n            self.interrupt()\n        except ProcessLookupError:\n            # The process has already been killed by someone or something else\n            liblog.debugger(\"Interrupting process failed: already terminated\")\n\n    if self.instanced:\n        try:\n            self.kill()\n        except ProcessLookupError:\n            # The process has already been killed by someone or something else\n            liblog.debugger(\"Killing process failed: already terminated\")\n\n    self.instanced = False\n    self.is_debugging = False\n\n    if self.__polling_thread is not None:\n        self.__polling_thread_command_queue.put((THREAD_TERMINATE, ()))\n        self.__polling_thread.join()\n        del self.__polling_thread\n        self.__polling_thread = None\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger/#libdebug.debugger.internal_debugger.InternalDebugger.wait","title":"<code>wait()</code>","text":"<p>Waits for the process to stop.</p> Source code in <code>libdebug/debugger/internal_debugger.py</code> <pre><code>@background_alias(_background_invalid_call)\ndef wait(self: InternalDebugger) -&gt; None:\n    \"\"\"Waits for the process to stop.\"\"\"\n    if not self.is_debugging:\n        raise RuntimeError(\"Process not running, cannot wait.\")\n\n    self._join_and_check_status()\n\n    if self.threads[0].dead or not self.running:\n        # Most of the time the function returns here, as there was a wait already\n        # queued by the previous command\n        return\n\n    self.__polling_thread_command_queue.put((self.__threaded_wait, ()))\n\n    self._join_and_check_status()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_holder/","title":"libdebug.debugger.internal_debugger_holder","text":""},{"location":"from_pydoc/generated/debugger/internal_debugger_holder/#libdebug.debugger.internal_debugger_holder.InternalDebuggerHolder","title":"<code>InternalDebuggerHolder</code>  <code>dataclass</code>","text":"<p>A holder for internal debuggers.</p> Source code in <code>libdebug/debugger/internal_debugger_holder.py</code> <pre><code>@dataclass\nclass InternalDebuggerHolder:\n    \"\"\"A holder for internal debuggers.\"\"\"\n\n    internal_debuggers: WeakKeyDictionary = field(default_factory=WeakKeyDictionary)\n    global_internal_debugger = None\n    internal_debugger_lock = Lock()\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/","title":"libdebug.debugger.internal_debugger_instance_manager","text":""},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/#libdebug.debugger.internal_debugger_instance_manager.extend_internal_debugger","title":"<code>extend_internal_debugger(referrer)</code>","text":"<p>Extend the internal debugger.</p> <p>Parameters:</p> Name Type Description Default <code>referrer</code> <code>object</code> <p>the referrer object.</p> required <p>Yields:</p> Name Type Description <code>InternalDebugger</code> <code>...</code> <p>the internal debugger.</p> Source code in <code>libdebug/debugger/internal_debugger_instance_manager.py</code> <pre><code>@contextmanager\ndef extend_internal_debugger(referrer: object) -&gt; ...:\n    \"\"\"Extend the internal debugger.\n\n    Args:\n        referrer (object): the referrer object.\n\n    Yields:\n        InternalDebugger: the internal debugger.\n    \"\"\"\n    with internal_debugger_holder.internal_debugger_lock:\n        if referrer not in internal_debugger_holder.internal_debuggers:\n            raise RuntimeError(\"Referrer isn't linked to any internal debugger.\")\n\n        internal_debugger_holder.global_internal_debugger = internal_debugger_holder.internal_debuggers[referrer]\n        yield\n        internal_debugger_holder.global_internal_debugger = None\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/#libdebug.debugger.internal_debugger_instance_manager.get_global_internal_debugger","title":"<code>get_global_internal_debugger()</code>","text":"<p>Can be used to retrieve a temporarily-global internal debugger.</p> Source code in <code>libdebug/debugger/internal_debugger_instance_manager.py</code> <pre><code>def get_global_internal_debugger() -&gt; InternalDebugger:\n    \"\"\"Can be used to retrieve a temporarily-global internal debugger.\"\"\"\n    if internal_debugger_holder.global_internal_debugger is None:\n        raise RuntimeError(\"No internal debugger available\")\n    return internal_debugger_holder.global_internal_debugger\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/#libdebug.debugger.internal_debugger_instance_manager.link_to_internal_debugger","title":"<code>link_to_internal_debugger(reference, internal_debugger)</code>","text":"<p>Link a reference to a InternalDebugger.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>object</code> <p>the object that needs the internal debugger.</p> required <code>internal_debugger</code> <code>InternalDebugger</code> <p>the internal debugger.</p> required Source code in <code>libdebug/debugger/internal_debugger_instance_manager.py</code> <pre><code>def link_to_internal_debugger(reference: object, internal_debugger: InternalDebugger) -&gt; None:\n    \"\"\"Link a reference to a InternalDebugger.\n\n    Args:\n        reference (object): the object that needs the internal debugger.\n        internal_debugger (InternalDebugger): the internal debugger.\n    \"\"\"\n    internal_debugger_holder.internal_debuggers[reference] = internal_debugger\n</code></pre>"},{"location":"from_pydoc/generated/debugger/internal_debugger_instance_manager/#libdebug.debugger.internal_debugger_instance_manager.provide_internal_debugger","title":"<code>provide_internal_debugger(reference)</code>","text":"<p>Provide a internal debugger.</p> <p>Parameters:</p> Name Type Description Default <code>reference</code> <code>object</code> <p>the object that needs the internal debugger.</p> required <p>Returns:</p> Name Type Description <code>InternalDebugger</code> <code>InternalDebugger</code> <p>the internal debugger.</p> Source code in <code>libdebug/debugger/internal_debugger_instance_manager.py</code> <pre><code>def provide_internal_debugger(reference: object) -&gt; InternalDebugger:\n    \"\"\"Provide a internal debugger.\n\n    Args:\n        reference (object): the object that needs the internal debugger.\n\n    Returns:\n        InternalDebugger: the internal debugger.\n    \"\"\"\n    if reference in internal_debugger_holder.internal_debuggers:\n        return internal_debugger_holder.internal_debuggers[reference]\n\n    if internal_debugger_holder.global_internal_debugger is None:\n        raise RuntimeError(\"No internal debugger available\")\n\n    internal_debugger_holder.internal_debuggers[reference] = internal_debugger_holder.global_internal_debugger\n    return internal_debugger_holder.global_internal_debugger\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/","title":"libdebug.interfaces.debugging_interface","text":""},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface","title":"<code>DebuggingInterface</code>","text":"<p>               Bases: <code>ABC</code></p> <p>The interface used by <code>_InternalDebugger</code> to communicate with the available debugging backends, such as <code>ptrace</code> or <code>gdb</code>.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>class DebuggingInterface(ABC):\n    \"\"\"The interface used by `_InternalDebugger` to communicate with the available debugging backends, such as `ptrace` or `gdb`.\"\"\"\n\n    @abstractmethod\n    def __init__(self: DebuggingInterface) -&gt; None:\n        \"\"\"Initializes the DebuggingInterface classs.\"\"\"\n\n    @abstractmethod\n    def reset(self: DebuggingInterface) -&gt; None:\n        \"\"\"Resets the state of the interface.\"\"\"\n\n    @abstractmethod\n    def run(self: DebuggingInterface, redirect_pipes: bool) -&gt; None:\n        \"\"\"Runs the specified process.\n\n        Args:\n            redirect_pipes (bool): Whether to hook and redirect the pipes of the process to a PipeManager.\n        \"\"\"\n\n    @abstractmethod\n    def attach(self: DebuggingInterface, pid: int) -&gt; None:\n        \"\"\"Attaches to the specified process.\n\n        Args:\n            pid (int): the pid of the process to attach to.\n        \"\"\"\n\n    @abstractmethod\n    def detach(self: DebuggingInterface) -&gt; None:\n        \"\"\"Detaches from the process.\"\"\"\n\n    @abstractmethod\n    def kill(self: DebuggingInterface) -&gt; None:\n        \"\"\"Instantly terminates the process.\"\"\"\n\n    @abstractmethod\n    def cont(self: DebuggingInterface) -&gt; None:\n        \"\"\"Continues the execution of the process.\"\"\"\n\n    @abstractmethod\n    def wait(self: DebuggingInterface) -&gt; None:\n        \"\"\"Waits for the process to stop.\"\"\"\n\n    @abstractmethod\n    def migrate_to_gdb(self: DebuggingInterface) -&gt; None:\n        \"\"\"Migrates the current process to GDB.\"\"\"\n\n    @abstractmethod\n    def migrate_from_gdb(self: DebuggingInterface) -&gt; None:\n        \"\"\"Migrates the current process from GDB.\"\"\"\n\n    @abstractmethod\n    def step(self: DebuggingInterface, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the specified thread.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n        \"\"\"\n\n    @abstractmethod\n    def step_until(self: DebuggingInterface, thread: ThreadContext, address: int, max_steps: int) -&gt; None:\n        \"\"\"Executes instructions of the specified thread until the specified address is reached.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n            address (int): The address to reach.\n            max_steps (int): The maximum number of steps to execute.\n        \"\"\"\n\n    @abstractmethod\n    def finish(self: DebuggingInterface, thread: ThreadContext, heuristic: str) -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            thread (ThreadContext): The thread to finish.\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n\n    @abstractmethod\n    def next(self: DebuggingInterface, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n\n    @abstractmethod\n    def get_maps(self: DebuggingInterface) -&gt; MemoryMapList[MemoryMap]:\n        \"\"\"Returns the memory maps of the process.\"\"\"\n\n    @abstractmethod\n    def set_breakpoint(self: DebuggingInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Sets a breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to set.\n        \"\"\"\n\n    @abstractmethod\n    def unset_breakpoint(self: DebuggingInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Restores the original instruction flow at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to restore.\n        \"\"\"\n\n    @abstractmethod\n    def set_syscall_handler(self: DebuggingInterface, handler: SyscallHandler) -&gt; None:\n        \"\"\"Sets a handler for a syscall.\n\n        Args:\n            handler (HandledSyscall): The syscall to set.\n        \"\"\"\n\n    @abstractmethod\n    def unset_syscall_handler(self: DebuggingInterface, handler: SyscallHandler) -&gt; None:\n        \"\"\"Unsets a handler for a syscall.\n\n        Args:\n            handler (HandledSyscall): The syscall to unset.\n        \"\"\"\n\n    @abstractmethod\n    def set_signal_catcher(self: DebuggingInterface, catcher: SignalCatcher) -&gt; None:\n        \"\"\"Sets a catcher for a signal.\n\n        Args:\n            catcher (CaughtSignal): The signal to set.\n        \"\"\"\n\n    @abstractmethod\n    def unset_signal_catcher(self: DebuggingInterface, catcher: SignalCatcher) -&gt; None:\n        \"\"\"Unset a catcher for a signal.\n\n        Args:\n            catcher (CaughtSignal): The signal to unset.\n        \"\"\"\n\n    @abstractmethod\n    def peek_memory(self: DebuggingInterface, address: int) -&gt; int:\n        \"\"\"Reads the memory at the specified address.\n\n        Args:\n            address (int): The address to read.\n\n        Returns:\n            int: The read memory value.\n        \"\"\"\n\n    @abstractmethod\n    def poke_memory(self: DebuggingInterface, address: int, data: int) -&gt; None:\n        \"\"\"Writes the memory at the specified address.\n\n        Args:\n            address (int): The address to write.\n            data (int): The value to write.\n        \"\"\"\n\n    @abstractmethod\n    def fetch_fp_registers(self: DebuggingInterface, registers: Registers) -&gt; None:\n        \"\"\"Fetches the floating-point registers of the specified thread.\n\n        Args:\n            registers (Registers): The registers instance to update.\n        \"\"\"\n\n    @abstractmethod\n    def flush_fp_registers(self: DebuggingInterface, registers: Registers) -&gt; None:\n        \"\"\"Flushes the floating-point registers of the specified thread.\n\n        Args:\n            registers (Registers): The registers instance to flush.\n        \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.__init__","title":"<code>__init__()</code>  <code>abstractmethod</code>","text":"<p>Initializes the DebuggingInterface classs.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef __init__(self: DebuggingInterface) -&gt; None:\n    \"\"\"Initializes the DebuggingInterface classs.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.attach","title":"<code>attach(pid)</code>  <code>abstractmethod</code>","text":"<p>Attaches to the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>the pid of the process to attach to.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef attach(self: DebuggingInterface, pid: int) -&gt; None:\n    \"\"\"Attaches to the specified process.\n\n    Args:\n        pid (int): the pid of the process to attach to.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.cont","title":"<code>cont()</code>  <code>abstractmethod</code>","text":"<p>Continues the execution of the process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef cont(self: DebuggingInterface) -&gt; None:\n    \"\"\"Continues the execution of the process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.detach","title":"<code>detach()</code>  <code>abstractmethod</code>","text":"<p>Detaches from the process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef detach(self: DebuggingInterface) -&gt; None:\n    \"\"\"Detaches from the process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.fetch_fp_registers","title":"<code>fetch_fp_registers(registers)</code>  <code>abstractmethod</code>","text":"<p>Fetches the floating-point registers of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>registers</code> <code>Registers</code> <p>The registers instance to update.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef fetch_fp_registers(self: DebuggingInterface, registers: Registers) -&gt; None:\n    \"\"\"Fetches the floating-point registers of the specified thread.\n\n    Args:\n        registers (Registers): The registers instance to update.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.finish","title":"<code>finish(thread, heuristic)</code>  <code>abstractmethod</code>","text":"<p>Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to finish.</p> required <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef finish(self: DebuggingInterface, thread: ThreadContext, heuristic: str) -&gt; None:\n    \"\"\"Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        thread (ThreadContext): The thread to finish.\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.flush_fp_registers","title":"<code>flush_fp_registers(registers)</code>  <code>abstractmethod</code>","text":"<p>Flushes the floating-point registers of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>registers</code> <code>Registers</code> <p>The registers instance to flush.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef flush_fp_registers(self: DebuggingInterface, registers: Registers) -&gt; None:\n    \"\"\"Flushes the floating-point registers of the specified thread.\n\n    Args:\n        registers (Registers): The registers instance to flush.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.get_maps","title":"<code>get_maps()</code>  <code>abstractmethod</code>","text":"<p>Returns the memory maps of the process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef get_maps(self: DebuggingInterface) -&gt; MemoryMapList[MemoryMap]:\n    \"\"\"Returns the memory maps of the process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.kill","title":"<code>kill()</code>  <code>abstractmethod</code>","text":"<p>Instantly terminates the process.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef kill(self: DebuggingInterface) -&gt; None:\n    \"\"\"Instantly terminates the process.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.migrate_from_gdb","title":"<code>migrate_from_gdb()</code>  <code>abstractmethod</code>","text":"<p>Migrates the current process from GDB.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef migrate_from_gdb(self: DebuggingInterface) -&gt; None:\n    \"\"\"Migrates the current process from GDB.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.migrate_to_gdb","title":"<code>migrate_to_gdb()</code>  <code>abstractmethod</code>","text":"<p>Migrates the current process to GDB.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef migrate_to_gdb(self: DebuggingInterface) -&gt; None:\n    \"\"\"Migrates the current process to GDB.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.next","title":"<code>next(thread)</code>  <code>abstractmethod</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef next(self: DebuggingInterface, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.peek_memory","title":"<code>peek_memory(address)</code>  <code>abstractmethod</code>","text":"<p>Reads the memory at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The read memory value.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef peek_memory(self: DebuggingInterface, address: int) -&gt; int:\n    \"\"\"Reads the memory at the specified address.\n\n    Args:\n        address (int): The address to read.\n\n    Returns:\n        int: The read memory value.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.poke_memory","title":"<code>poke_memory(address, data)</code>  <code>abstractmethod</code>","text":"<p>Writes the memory at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write.</p> required <code>data</code> <code>int</code> <p>The value to write.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef poke_memory(self: DebuggingInterface, address: int, data: int) -&gt; None:\n    \"\"\"Writes the memory at the specified address.\n\n    Args:\n        address (int): The address to write.\n        data (int): The value to write.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.reset","title":"<code>reset()</code>  <code>abstractmethod</code>","text":"<p>Resets the state of the interface.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef reset(self: DebuggingInterface) -&gt; None:\n    \"\"\"Resets the state of the interface.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.run","title":"<code>run(redirect_pipes)</code>  <code>abstractmethod</code>","text":"<p>Runs the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>redirect_pipes</code> <code>bool</code> <p>Whether to hook and redirect the pipes of the process to a PipeManager.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef run(self: DebuggingInterface, redirect_pipes: bool) -&gt; None:\n    \"\"\"Runs the specified process.\n\n    Args:\n        redirect_pipes (bool): Whether to hook and redirect the pipes of the process to a PipeManager.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.set_breakpoint","title":"<code>set_breakpoint(bp)</code>  <code>abstractmethod</code>","text":"<p>Sets a breakpoint at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>bp</code> <code>Breakpoint</code> <p>The breakpoint to set.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef set_breakpoint(self: DebuggingInterface, bp: Breakpoint) -&gt; None:\n    \"\"\"Sets a breakpoint at the specified address.\n\n    Args:\n        bp (Breakpoint): The breakpoint to set.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.set_signal_catcher","title":"<code>set_signal_catcher(catcher)</code>  <code>abstractmethod</code>","text":"<p>Sets a catcher for a signal.</p> <p>Parameters:</p> Name Type Description Default <code>catcher</code> <code>CaughtSignal</code> <p>The signal to set.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef set_signal_catcher(self: DebuggingInterface, catcher: SignalCatcher) -&gt; None:\n    \"\"\"Sets a catcher for a signal.\n\n    Args:\n        catcher (CaughtSignal): The signal to set.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.set_syscall_handler","title":"<code>set_syscall_handler(handler)</code>  <code>abstractmethod</code>","text":"<p>Sets a handler for a syscall.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandledSyscall</code> <p>The syscall to set.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef set_syscall_handler(self: DebuggingInterface, handler: SyscallHandler) -&gt; None:\n    \"\"\"Sets a handler for a syscall.\n\n    Args:\n        handler (HandledSyscall): The syscall to set.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.step","title":"<code>step(thread)</code>  <code>abstractmethod</code>","text":"<p>Executes a single instruction of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef step(self: DebuggingInterface, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes a single instruction of the specified thread.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.step_until","title":"<code>step_until(thread, address, max_steps)</code>  <code>abstractmethod</code>","text":"<p>Executes instructions of the specified thread until the specified address is reached.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required <code>address</code> <code>int</code> <p>The address to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef step_until(self: DebuggingInterface, thread: ThreadContext, address: int, max_steps: int) -&gt; None:\n    \"\"\"Executes instructions of the specified thread until the specified address is reached.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n        address (int): The address to reach.\n        max_steps (int): The maximum number of steps to execute.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.unset_breakpoint","title":"<code>unset_breakpoint(bp)</code>  <code>abstractmethod</code>","text":"<p>Restores the original instruction flow at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>bp</code> <code>Breakpoint</code> <p>The breakpoint to restore.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef unset_breakpoint(self: DebuggingInterface, bp: Breakpoint) -&gt; None:\n    \"\"\"Restores the original instruction flow at the specified address.\n\n    Args:\n        bp (Breakpoint): The breakpoint to restore.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.unset_signal_catcher","title":"<code>unset_signal_catcher(catcher)</code>  <code>abstractmethod</code>","text":"<p>Unset a catcher for a signal.</p> <p>Parameters:</p> Name Type Description Default <code>catcher</code> <code>CaughtSignal</code> <p>The signal to unset.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef unset_signal_catcher(self: DebuggingInterface, catcher: SignalCatcher) -&gt; None:\n    \"\"\"Unset a catcher for a signal.\n\n    Args:\n        catcher (CaughtSignal): The signal to unset.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.unset_syscall_handler","title":"<code>unset_syscall_handler(handler)</code>  <code>abstractmethod</code>","text":"<p>Unsets a handler for a syscall.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandledSyscall</code> <p>The syscall to unset.</p> required Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef unset_syscall_handler(self: DebuggingInterface, handler: SyscallHandler) -&gt; None:\n    \"\"\"Unsets a handler for a syscall.\n\n    Args:\n        handler (HandledSyscall): The syscall to unset.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/debugging_interface/#libdebug.interfaces.debugging_interface.DebuggingInterface.wait","title":"<code>wait()</code>  <code>abstractmethod</code>","text":"<p>Waits for the process to stop.</p> Source code in <code>libdebug/interfaces/debugging_interface.py</code> <pre><code>@abstractmethod\ndef wait(self: DebuggingInterface) -&gt; None:\n    \"\"\"Waits for the process to stop.\"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/interface_helper/","title":"libdebug.interfaces.interface_helper","text":""},{"location":"from_pydoc/generated/interfaces/interface_helper/#libdebug.interfaces.interface_helper.provide_debugging_interface","title":"<code>provide_debugging_interface(interface=AvailableInterfaces.PTRACE)</code>","text":"<p>Returns an instance of the debugging interface to be used by the <code>_InternalDebugger</code> class.</p> Source code in <code>libdebug/interfaces/interface_helper.py</code> <pre><code>def provide_debugging_interface(\n    interface: AvailableInterfaces = AvailableInterfaces.PTRACE,\n) -&gt; DebuggingInterface:\n    \"\"\"Returns an instance of the debugging interface to be used by the `_InternalDebugger` class.\"\"\"\n    match interface:\n        case AvailableInterfaces.PTRACE:\n            return PtraceInterface()\n        case _:\n            raise NotImplementedError(f\"Interface {interface} not available.\")\n</code></pre>"},{"location":"from_pydoc/generated/interfaces/interfaces/","title":"libdebug.interfaces.interfaces","text":""},{"location":"from_pydoc/generated/interfaces/interfaces/#libdebug.interfaces.interfaces.AvailableInterfaces","title":"<code>AvailableInterfaces</code>","text":"<p>               Bases: <code>Enum</code></p> <p>An enumeration of the available backend interfaces.</p> Source code in <code>libdebug/interfaces/interfaces.py</code> <pre><code>class AvailableInterfaces(Enum):\n    \"\"\"An enumeration of the available backend interfaces.\"\"\"\n\n    PTRACE = 1\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/","title":"libdebug.memory.abstract_memory_view","text":""},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView","title":"<code>AbstractMemoryView</code>","text":"<p>               Bases: <code>MutableSequence</code>, <code>ABC</code></p> <p>An abstract memory interface for the target process.</p> <p>An implementation of class must be used to read and write memory of the target process.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>class AbstractMemoryView(MutableSequence, ABC):\n    \"\"\"An abstract memory interface for the target process.\n\n    An implementation of class must be used to read and write memory of the target process.\n    \"\"\"\n\n    def __init__(self: AbstractMemoryView) -&gt; None:\n        \"\"\"Initializes the MemoryView.\"\"\"\n        self._internal_debugger = provide_internal_debugger(self)\n\n    @abstractmethod\n    def read(self: AbstractMemoryView, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target process.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n\n    @abstractmethod\n    def write(self: AbstractMemoryView, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target process.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n\n    def find(\n        self: AbstractMemoryView,\n        value: bytes | str | int,\n        file: str = \"all\",\n        start: int | None = None,\n        end: int | None = None,\n    ) -&gt; list[int]:\n        \"\"\"Searches for the given value in the specified memory maps of the process.\n\n        The start and end addresses can be used to limit the search to a specific range.\n        If not specified, the search will be performed on the whole memory map.\n\n        Args:\n            value (bytes | str | int): The value to search for.\n            file (str): The backing file to search the value in. Defaults to \"all\", which means all memory.\n            start (int | None): The start address of the search. Defaults to None.\n            end (int | None): The end address of the search. Defaults to None.\n\n        Returns:\n            list[int]: A list of offset where the value was found.\n        \"\"\"\n        if isinstance(value, str):\n            value = value.encode()\n        elif isinstance(value, int):\n            value = value.to_bytes(1, sys.byteorder)\n\n        occurrences = []\n        if file == \"all\" and start is None and end is None:\n            for vmap in self._internal_debugger.maps:\n                liblog.debugger(f\"Searching in {vmap.backing_file}...\")\n                try:\n                    memory_content = self.read(vmap.start, vmap.end - vmap.start)\n                except (OSError, OverflowError):\n                    # There are some memory regions that cannot be read, such as [vvar], [vdso], etc.\n                    continue\n                occurrences += find_all_overlapping_occurrences(value, memory_content, vmap.start)\n        elif file == \"all\" and start is not None and end is None:\n            for vmap in self._internal_debugger.maps:\n                if vmap.end &gt; start:\n                    liblog.debugger(f\"Searching in {vmap.backing_file}...\")\n                    read_start = max(vmap.start, start)\n                    try:\n                        memory_content = self.read(read_start, vmap.end - read_start)\n                    except (OSError, OverflowError):\n                        # There are some memory regions that cannot be read, such as [vvar], [vdso], etc.\n                        continue\n                    occurrences += find_all_overlapping_occurrences(value, memory_content, read_start)\n        elif file == \"all\" and start is None and end is not None:\n            for vmap in self._internal_debugger.maps:\n                if vmap.start &lt; end:\n                    liblog.debugger(f\"Searching in {vmap.backing_file}...\")\n                    read_end = min(vmap.end, end)\n                    try:\n                        memory_content = self.read(vmap.start, read_end - vmap.start)\n                    except (OSError, OverflowError):\n                        # There are some memory regions that cannot be read, such as [vvar], [vdso], etc.\n                        continue\n                    occurrences += find_all_overlapping_occurrences(value, memory_content, vmap.start)\n        elif file == \"all\" and start is not None and end is not None:\n            # Search in the specified range, hybrid mode\n            start = self._internal_debugger.resolve_address(start, \"hybrid\", True)\n            end = self._internal_debugger.resolve_address(end, \"hybrid\", True)\n            liblog.debugger(f\"Searching in the range {start:#x}-{end:#x}...\")\n            memory_content = self.read(start, end - start)\n            occurrences = find_all_overlapping_occurrences(value, memory_content, start)\n        else:\n            maps = self._internal_debugger.maps.filter(file)\n            start = self._internal_debugger.resolve_address(start, file, True) if start is not None else maps[0].start\n            end = self._internal_debugger.resolve_address(end, file, True) if end is not None else maps[-1].end - 1\n\n            liblog.debugger(f\"Searching in the range {start:#x}-{end:#x}...\")\n            memory_content = self.read(start, end - start)\n\n            occurrences = find_all_overlapping_occurrences(value, memory_content, start)\n\n        return occurrences\n\n    def __getitem__(self: AbstractMemoryView, key: int | slice | str | tuple) -&gt; bytes:\n        \"\"\"Read from memory, either a single byte or a byte string.\n\n        Args:\n            key (int | slice | str | tuple): The key to read from memory.\n        \"\"\"\n        return self._manage_memory_read_type(key)\n\n    def __setitem__(self: AbstractMemoryView, key: int | slice | str | tuple, value: bytes) -&gt; None:\n        \"\"\"Write to memory, either a single byte or a byte string.\n\n        Args:\n            key (int | slice | str | tuple): The key to write to memory.\n            value (bytes): The value to write.\n        \"\"\"\n        if not isinstance(value, bytes):\n            raise TypeError(\"Invalid type for the value to write to memory. Expected bytes.\")\n        self._manage_memory_write_type(key, value)\n\n    def _manage_memory_read_type(\n        self: AbstractMemoryView,\n        key: int | slice | str | tuple,\n        file: str = \"hybrid\",\n    ) -&gt; bytes:\n        \"\"\"Manage the read from memory, according to the typing.\n\n        Args:\n            key (int | slice | str | tuple): The key to read from memory.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        if isinstance(key, int):\n            address = self._internal_debugger.resolve_address(key, file, skip_absolute_address_validation=True)\n            try:\n                return self.read(address, 1)\n            except OSError as e:\n                raise ValueError(\"Invalid address.\") from e\n        elif isinstance(key, slice):\n            if isinstance(key.start, str):\n                start = self._internal_debugger.resolve_symbol(key.start, file)\n            else:\n                start = self._internal_debugger.resolve_address(key.start, file, skip_absolute_address_validation=True)\n\n            if isinstance(key.stop, str):\n                stop = self._internal_debugger.resolve_symbol(key.stop, file)\n            else:\n                stop = self._internal_debugger.resolve_address(key.stop, file, skip_absolute_address_validation=True)\n\n            if stop &lt; start:\n                raise ValueError(\"Invalid slice range.\")\n\n            try:\n                return self.read(start, stop - start)\n            except OSError as e:\n                raise ValueError(\"Invalid address.\") from e\n        elif isinstance(key, str):\n            address = self._internal_debugger.resolve_symbol(key, file)\n\n            return self.read(address, 1)\n        elif isinstance(key, tuple):\n            return self._manage_memory_read_tuple(key)\n        else:\n            raise TypeError(\"Invalid key type.\")\n\n    def _manage_memory_read_tuple(self: AbstractMemoryView, key: tuple) -&gt; bytes:\n        \"\"\"Manage the read from memory, when the access is through a tuple.\n\n        Args:\n            key (tuple): The key to read from memory.\n        \"\"\"\n        if len(key) == 3:\n            # It can only be a tuple of the type (address, size, file)\n            address, size, file = key\n            if not isinstance(file, str):\n                raise TypeError(\"Invalid type for the backing file. Expected string.\")\n        elif len(key) == 2:\n            left, right = key\n            if isinstance(right, str):\n                # The right element can only be the backing file\n                return self._manage_memory_read_type(left, right)\n            elif isinstance(right, int):\n                # The right element must be the size\n                address = left\n                size = right\n                file = \"hybrid\"\n        else:\n            raise TypeError(\"Tuple must have 2 or 3 elements.\")\n\n        if not isinstance(size, int):\n            raise TypeError(\"Invalid type for the size. Expected int.\")\n\n        if isinstance(address, str):\n            address = self._internal_debugger.resolve_symbol(address, file)\n        elif isinstance(address, int):\n            address = self._internal_debugger.resolve_address(address, file, skip_absolute_address_validation=True)\n        else:\n            raise TypeError(\"Invalid type for the address. Expected int or string.\")\n\n        try:\n            return self.read(address, size)\n        except OSError as e:\n            raise ValueError(\"Invalid address.\") from e\n\n    def _manage_memory_write_type(\n        self: AbstractMemoryView,\n        key: int | slice | str | tuple,\n        value: bytes,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Manage the write to memory, according to the typing.\n\n        Args:\n            key (int | slice | str | tuple): The key to read from memory.\n            value (bytes): The value to write.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        if isinstance(key, int):\n            address = self._internal_debugger.resolve_address(key, file, skip_absolute_address_validation=True)\n            try:\n                self.write(address, value)\n            except OSError as e:\n                raise ValueError(\"Invalid address.\") from e\n        elif isinstance(key, slice):\n            if isinstance(key.start, str):\n                start = self._internal_debugger.resolve_symbol(key.start, file)\n            else:\n                start = self._internal_debugger.resolve_address(key.start, file, skip_absolute_address_validation=True)\n\n            if key.stop is not None:\n                if isinstance(key.stop, str):\n                    stop = self._internal_debugger.resolve_symbol(key.stop, file)\n                else:\n                    stop = self._internal_debugger.resolve_address(\n                        key.stop,\n                        file,\n                        skip_absolute_address_validation=True,\n                    )\n\n                if stop &lt; start:\n                    raise ValueError(\"Invalid slice range\")\n\n                if len(value) != stop - start:\n                    liblog.warning(f\"Mismatch between slice width and value size, writing {len(value)} bytes.\")\n\n            try:\n                self.write(start, value)\n            except OSError as e:\n                raise ValueError(\"Invalid address.\") from e\n\n        elif isinstance(key, str):\n            address = self._internal_debugger.resolve_symbol(key, file)\n\n            self.write(address, value)\n        elif isinstance(key, tuple):\n            self._manage_memory_write_tuple(key, value)\n        else:\n            raise TypeError(\"Invalid key type.\")\n\n    def _manage_memory_write_tuple(self: AbstractMemoryView, key: tuple, value: bytes) -&gt; None:\n        \"\"\"Manage the write to memory, when the access is through a tuple.\n\n        Args:\n            key (tuple): The key to read from memory.\n            value (bytes): The value to write.\n        \"\"\"\n        if len(key) == 3:\n            # It can only be a tuple of the type (address, size, file)\n            address, size, file = key\n            if not isinstance(file, str):\n                raise TypeError(\"Invalid type for the backing file. Expected string.\")\n        elif len(key) == 2:\n            left, right = key\n            if isinstance(right, str):\n                # The right element can only be the backing file\n                self._manage_memory_write_type(left, value, right)\n                return\n            elif isinstance(right, int):\n                # The right element must be the size\n                address = left\n                size = right\n                file = \"hybrid\"\n        else:\n            raise TypeError(\"Tuple must have 2 or 3 elements.\")\n\n        if not isinstance(size, int):\n            raise TypeError(\"Invalid type for the size. Expected int.\")\n\n        if isinstance(address, str):\n            address = self._internal_debugger.resolve_symbol(address, file)\n        elif isinstance(address, int):\n            address = self._internal_debugger.resolve_address(address, file, skip_absolute_address_validation=True)\n        else:\n            raise TypeError(\"Invalid type for the address. Expected int or string.\")\n\n        if len(value) != size:\n            liblog.warning(f\"Mismatch between specified size and actual value size, writing {len(value)} bytes.\")\n\n        try:\n            self.write(address, value)\n        except OSError as e:\n            raise ValueError(\"Invalid address.\") from e\n\n    def __delitem__(self: AbstractMemoryView, key: int | slice | str | tuple) -&gt; None:\n        \"\"\"MemoryView doesn't support deletion.\"\"\"\n        raise NotImplementedError(\"MemoryView doesn't support deletion\")\n\n    def __len__(self: AbstractMemoryView) -&gt; None:\n        \"\"\"MemoryView doesn't support length.\"\"\"\n        raise NotImplementedError(\"MemoryView doesn't support length\")\n\n    def insert(self: AbstractMemoryView, index: int, value: int) -&gt; None:\n        \"\"\"MemoryView doesn't support insertion.\"\"\"\n        raise NotImplementedError(\"MemoryView doesn't support insertion\")\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__delitem__","title":"<code>__delitem__(key)</code>","text":"<p>MemoryView doesn't support deletion.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __delitem__(self: AbstractMemoryView, key: int | slice | str | tuple) -&gt; None:\n    \"\"\"MemoryView doesn't support deletion.\"\"\"\n    raise NotImplementedError(\"MemoryView doesn't support deletion\")\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Read from memory, either a single byte or a byte string.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int | slice | str | tuple</code> <p>The key to read from memory.</p> required Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __getitem__(self: AbstractMemoryView, key: int | slice | str | tuple) -&gt; bytes:\n    \"\"\"Read from memory, either a single byte or a byte string.\n\n    Args:\n        key (int | slice | str | tuple): The key to read from memory.\n    \"\"\"\n    return self._manage_memory_read_type(key)\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the MemoryView.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __init__(self: AbstractMemoryView) -&gt; None:\n    \"\"\"Initializes the MemoryView.\"\"\"\n    self._internal_debugger = provide_internal_debugger(self)\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__len__","title":"<code>__len__()</code>","text":"<p>MemoryView doesn't support length.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __len__(self: AbstractMemoryView) -&gt; None:\n    \"\"\"MemoryView doesn't support length.\"\"\"\n    raise NotImplementedError(\"MemoryView doesn't support length\")\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.__setitem__","title":"<code>__setitem__(key, value)</code>","text":"<p>Write to memory, either a single byte or a byte string.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int | slice | str | tuple</code> <p>The key to write to memory.</p> required <code>value</code> <code>bytes</code> <p>The value to write.</p> required Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def __setitem__(self: AbstractMemoryView, key: int | slice | str | tuple, value: bytes) -&gt; None:\n    \"\"\"Write to memory, either a single byte or a byte string.\n\n    Args:\n        key (int | slice | str | tuple): The key to write to memory.\n        value (bytes): The value to write.\n    \"\"\"\n    if not isinstance(value, bytes):\n        raise TypeError(\"Invalid type for the value to write to memory. Expected bytes.\")\n    self._manage_memory_write_type(key, value)\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.find","title":"<code>find(value, file='all', start=None, end=None)</code>","text":"<p>Searches for the given value in the specified memory maps of the process.</p> <p>The start and end addresses can be used to limit the search to a specific range. If not specified, the search will be performed on the whole memory map.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bytes | str | int</code> <p>The value to search for.</p> required <code>file</code> <code>str</code> <p>The backing file to search the value in. Defaults to \"all\", which means all memory.</p> <code>'all'</code> <code>start</code> <code>int | None</code> <p>The start address of the search. Defaults to None.</p> <code>None</code> <code>end</code> <code>int | None</code> <p>The end address of the search. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[int]</code> <p>list[int]: A list of offset where the value was found.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def find(\n    self: AbstractMemoryView,\n    value: bytes | str | int,\n    file: str = \"all\",\n    start: int | None = None,\n    end: int | None = None,\n) -&gt; list[int]:\n    \"\"\"Searches for the given value in the specified memory maps of the process.\n\n    The start and end addresses can be used to limit the search to a specific range.\n    If not specified, the search will be performed on the whole memory map.\n\n    Args:\n        value (bytes | str | int): The value to search for.\n        file (str): The backing file to search the value in. Defaults to \"all\", which means all memory.\n        start (int | None): The start address of the search. Defaults to None.\n        end (int | None): The end address of the search. Defaults to None.\n\n    Returns:\n        list[int]: A list of offset where the value was found.\n    \"\"\"\n    if isinstance(value, str):\n        value = value.encode()\n    elif isinstance(value, int):\n        value = value.to_bytes(1, sys.byteorder)\n\n    occurrences = []\n    if file == \"all\" and start is None and end is None:\n        for vmap in self._internal_debugger.maps:\n            liblog.debugger(f\"Searching in {vmap.backing_file}...\")\n            try:\n                memory_content = self.read(vmap.start, vmap.end - vmap.start)\n            except (OSError, OverflowError):\n                # There are some memory regions that cannot be read, such as [vvar], [vdso], etc.\n                continue\n            occurrences += find_all_overlapping_occurrences(value, memory_content, vmap.start)\n    elif file == \"all\" and start is not None and end is None:\n        for vmap in self._internal_debugger.maps:\n            if vmap.end &gt; start:\n                liblog.debugger(f\"Searching in {vmap.backing_file}...\")\n                read_start = max(vmap.start, start)\n                try:\n                    memory_content = self.read(read_start, vmap.end - read_start)\n                except (OSError, OverflowError):\n                    # There are some memory regions that cannot be read, such as [vvar], [vdso], etc.\n                    continue\n                occurrences += find_all_overlapping_occurrences(value, memory_content, read_start)\n    elif file == \"all\" and start is None and end is not None:\n        for vmap in self._internal_debugger.maps:\n            if vmap.start &lt; end:\n                liblog.debugger(f\"Searching in {vmap.backing_file}...\")\n                read_end = min(vmap.end, end)\n                try:\n                    memory_content = self.read(vmap.start, read_end - vmap.start)\n                except (OSError, OverflowError):\n                    # There are some memory regions that cannot be read, such as [vvar], [vdso], etc.\n                    continue\n                occurrences += find_all_overlapping_occurrences(value, memory_content, vmap.start)\n    elif file == \"all\" and start is not None and end is not None:\n        # Search in the specified range, hybrid mode\n        start = self._internal_debugger.resolve_address(start, \"hybrid\", True)\n        end = self._internal_debugger.resolve_address(end, \"hybrid\", True)\n        liblog.debugger(f\"Searching in the range {start:#x}-{end:#x}...\")\n        memory_content = self.read(start, end - start)\n        occurrences = find_all_overlapping_occurrences(value, memory_content, start)\n    else:\n        maps = self._internal_debugger.maps.filter(file)\n        start = self._internal_debugger.resolve_address(start, file, True) if start is not None else maps[0].start\n        end = self._internal_debugger.resolve_address(end, file, True) if end is not None else maps[-1].end - 1\n\n        liblog.debugger(f\"Searching in the range {start:#x}-{end:#x}...\")\n        memory_content = self.read(start, end - start)\n\n        occurrences = find_all_overlapping_occurrences(value, memory_content, start)\n\n    return occurrences\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.insert","title":"<code>insert(index, value)</code>","text":"<p>MemoryView doesn't support insertion.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>def insert(self: AbstractMemoryView, index: int, value: int) -&gt; None:\n    \"\"\"MemoryView doesn't support insertion.\"\"\"\n    raise NotImplementedError(\"MemoryView doesn't support insertion\")\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.read","title":"<code>read(address, size)</code>  <code>abstractmethod</code>","text":"<p>Reads memory from the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>@abstractmethod\ndef read(self: AbstractMemoryView, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target process.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/memory/abstract_memory_view/#libdebug.memory.abstract_memory_view.AbstractMemoryView.write","title":"<code>write(address, data)</code>  <code>abstractmethod</code>","text":"<p>Writes memory to the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/memory/abstract_memory_view.py</code> <pre><code>@abstractmethod\ndef write(self: AbstractMemoryView, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target process.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n</code></pre>"},{"location":"from_pydoc/generated/memory/chunked_memory_view/","title":"libdebug.memory.chunked_memory_view","text":""},{"location":"from_pydoc/generated/memory/chunked_memory_view/#libdebug.memory.chunked_memory_view.ChunkedMemoryView","title":"<code>ChunkedMemoryView</code>","text":"<p>               Bases: <code>AbstractMemoryView</code></p> <p>A memory interface for the target process, intended for chunk-based memory access.</p> <p>Attributes:</p> Name Type Description <code>getter</code> <code>Callable[[int], bytes]</code> <p>A function that reads a chunk of memory from the target process.</p> <code>setter</code> <code>Callable[[int, bytes], None]</code> <p>A function that writes a chunk of memory to the target process.</p> <code>unit_size</code> <code>int</code> <p>The chunk size used by the getter and setter functions. Defaults to 8.</p> <code>align_to</code> <code>int</code> <p>The address alignment that must be used when reading and writing memory. Defaults to 1.</p> Source code in <code>libdebug/memory/chunked_memory_view.py</code> <pre><code>class ChunkedMemoryView(AbstractMemoryView):\n    \"\"\"A memory interface for the target process, intended for chunk-based memory access.\n\n    Attributes:\n            getter (Callable[[int], bytes]): A function that reads a chunk of memory from the target process.\n            setter (Callable[[int, bytes], None]): A function that writes a chunk of memory to the target process.\n            unit_size (int, optional): The chunk size used by the getter and setter functions. Defaults to 8.\n            align_to (int, optional): The address alignment that must be used when reading and writing memory. Defaults to 1.\n    \"\"\"\n\n    def __init__(\n        self: ChunkedMemoryView,\n        getter: Callable[[int], bytes],\n        setter: Callable[[int, bytes], None],\n        unit_size: int = 8,\n        align_to: int = 1,\n    ) -&gt; None:\n        \"\"\"Initializes the MemoryView.\"\"\"\n        super().__init__()\n        self.getter = getter\n        self.setter = setter\n        self.unit_size = unit_size\n        self.align_to = align_to\n\n    def read(self: ChunkedMemoryView, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target process.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n        if self.align_to == 1:\n            data = b\"\"\n\n            remainder = size % self.unit_size\n\n            for i in range(address, address + size - remainder, self.unit_size):\n                data += self.getter(i)\n\n            if remainder:\n                data += self.getter(address + size - remainder)[:remainder]\n\n            return data\n        else:\n            prefix = address % self.align_to\n            prefix_size = self.unit_size - prefix\n\n            data = self.getter(address - prefix)[prefix:]\n\n            remainder = (size - prefix_size) % self.unit_size\n\n            for i in range(\n                address + prefix_size,\n                address + size - remainder,\n                self.unit_size,\n            ):\n                data += self.getter(i)\n\n            if remainder:\n                data += self.getter(address + size - remainder)[:remainder]\n\n            return data\n\n    def write(self: ChunkedMemoryView, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target process.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n        size = len(data)\n\n        if self.align_to == 1:\n            remainder = size % self.unit_size\n            base = address\n        else:\n            prefix = address % self.align_to\n            prefix_size = self.unit_size - prefix\n\n            prev_data = self.getter(address - prefix)\n\n            self.setter(address - prefix, prev_data[:prefix_size] + data[:prefix])\n\n            remainder = (size - prefix_size) % self.unit_size\n            base = address + prefix_size\n\n        for i in range(base, address + size - remainder, self.unit_size):\n            self.setter(i, data[i - address : i - address + self.unit_size])\n\n        if remainder:\n            prev_data = self.getter(address + size - remainder)\n            self.setter(\n                address + size - remainder,\n                data[size - remainder :] + prev_data[remainder:],\n            )\n</code></pre>"},{"location":"from_pydoc/generated/memory/chunked_memory_view/#libdebug.memory.chunked_memory_view.ChunkedMemoryView.__init__","title":"<code>__init__(getter, setter, unit_size=8, align_to=1)</code>","text":"<p>Initializes the MemoryView.</p> Source code in <code>libdebug/memory/chunked_memory_view.py</code> <pre><code>def __init__(\n    self: ChunkedMemoryView,\n    getter: Callable[[int], bytes],\n    setter: Callable[[int, bytes], None],\n    unit_size: int = 8,\n    align_to: int = 1,\n) -&gt; None:\n    \"\"\"Initializes the MemoryView.\"\"\"\n    super().__init__()\n    self.getter = getter\n    self.setter = setter\n    self.unit_size = unit_size\n    self.align_to = align_to\n</code></pre>"},{"location":"from_pydoc/generated/memory/chunked_memory_view/#libdebug.memory.chunked_memory_view.ChunkedMemoryView.read","title":"<code>read(address, size)</code>","text":"<p>Reads memory from the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/memory/chunked_memory_view.py</code> <pre><code>def read(self: ChunkedMemoryView, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target process.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n    if self.align_to == 1:\n        data = b\"\"\n\n        remainder = size % self.unit_size\n\n        for i in range(address, address + size - remainder, self.unit_size):\n            data += self.getter(i)\n\n        if remainder:\n            data += self.getter(address + size - remainder)[:remainder]\n\n        return data\n    else:\n        prefix = address % self.align_to\n        prefix_size = self.unit_size - prefix\n\n        data = self.getter(address - prefix)[prefix:]\n\n        remainder = (size - prefix_size) % self.unit_size\n\n        for i in range(\n            address + prefix_size,\n            address + size - remainder,\n            self.unit_size,\n        ):\n            data += self.getter(i)\n\n        if remainder:\n            data += self.getter(address + size - remainder)[:remainder]\n\n        return data\n</code></pre>"},{"location":"from_pydoc/generated/memory/chunked_memory_view/#libdebug.memory.chunked_memory_view.ChunkedMemoryView.write","title":"<code>write(address, data)</code>","text":"<p>Writes memory to the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/memory/chunked_memory_view.py</code> <pre><code>def write(self: ChunkedMemoryView, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target process.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n    size = len(data)\n\n    if self.align_to == 1:\n        remainder = size % self.unit_size\n        base = address\n    else:\n        prefix = address % self.align_to\n        prefix_size = self.unit_size - prefix\n\n        prev_data = self.getter(address - prefix)\n\n        self.setter(address - prefix, prev_data[:prefix_size] + data[:prefix])\n\n        remainder = (size - prefix_size) % self.unit_size\n        base = address + prefix_size\n\n    for i in range(base, address + size - remainder, self.unit_size):\n        self.setter(i, data[i - address : i - address + self.unit_size])\n\n    if remainder:\n        prev_data = self.getter(address + size - remainder)\n        self.setter(\n            address + size - remainder,\n            data[size - remainder :] + prev_data[remainder:],\n        )\n</code></pre>"},{"location":"from_pydoc/generated/memory/direct_memory_view/","title":"libdebug.memory.direct_memory_view","text":""},{"location":"from_pydoc/generated/memory/direct_memory_view/#libdebug.memory.direct_memory_view.DirectMemoryView","title":"<code>DirectMemoryView</code>","text":"<p>               Bases: <code>AbstractMemoryView</code></p> <p>A memory interface for the target process, intended for direct memory access.</p> <p>Attributes:</p> Name Type Description <code>getter</code> <code>Callable[[int, int], bytes]</code> <p>A function that reads a variable amount of data from the target's memory.</p> <code>setter</code> <code>Callable[[int, bytes], None]</code> <p>A function that writes memory to the target process.</p> <code>align_to</code> <code>int</code> <p>The address alignment that must be used when reading and writing memory. Defaults to 1.</p> Source code in <code>libdebug/memory/direct_memory_view.py</code> <pre><code>class DirectMemoryView(AbstractMemoryView):\n    \"\"\"A memory interface for the target process, intended for direct memory access.\n\n    Attributes:\n            getter (Callable[[int, int], bytes]): A function that reads a variable amount of data from the target's memory.\n            setter (Callable[[int, bytes], None]): A function that writes memory to the target process.\n            align_to (int, optional): The address alignment that must be used when reading and writing memory. Defaults to 1.\n    \"\"\"\n\n    def __init__(\n        self: DirectMemoryView,\n        getter: Callable[[int, int], bytes],\n        setter: Callable[[int, bytes], None],\n        align_to: int = 1,\n    ) -&gt; None:\n        \"\"\"Initializes the MemoryView.\"\"\"\n        super().__init__()\n        self.getter = getter\n        self.setter = setter\n        self.align_to = align_to\n\n    def read(self: DirectMemoryView, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target process.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n        if self.align_to == 1:\n            return self.getter(address, size)\n        else:\n            prefix = address % self.align_to\n            base_address = address - prefix\n            new_size = size + prefix\n            data = self.getter(base_address, new_size)\n            return data[prefix : prefix + size]\n\n    def write(self: DirectMemoryView, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target process.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n        size = len(data)\n\n        if self.align_to == 1:\n            self.setter(address, data)\n        else:\n            prefix = address % self.align_to\n            base_address = address - prefix\n            new_size = size + prefix\n            prefix_data = self.getter(base_address, new_size)\n            new_data = prefix_data[:prefix] + data + prefix_data[prefix + size :]\n            self.setter(base_address, new_data)\n</code></pre>"},{"location":"from_pydoc/generated/memory/direct_memory_view/#libdebug.memory.direct_memory_view.DirectMemoryView.__init__","title":"<code>__init__(getter, setter, align_to=1)</code>","text":"<p>Initializes the MemoryView.</p> Source code in <code>libdebug/memory/direct_memory_view.py</code> <pre><code>def __init__(\n    self: DirectMemoryView,\n    getter: Callable[[int, int], bytes],\n    setter: Callable[[int, bytes], None],\n    align_to: int = 1,\n) -&gt; None:\n    \"\"\"Initializes the MemoryView.\"\"\"\n    super().__init__()\n    self.getter = getter\n    self.setter = setter\n    self.align_to = align_to\n</code></pre>"},{"location":"from_pydoc/generated/memory/direct_memory_view/#libdebug.memory.direct_memory_view.DirectMemoryView.read","title":"<code>read(address, size)</code>","text":"<p>Reads memory from the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/memory/direct_memory_view.py</code> <pre><code>def read(self: DirectMemoryView, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target process.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n    if self.align_to == 1:\n        return self.getter(address, size)\n    else:\n        prefix = address % self.align_to\n        base_address = address - prefix\n        new_size = size + prefix\n        data = self.getter(base_address, new_size)\n        return data[prefix : prefix + size]\n</code></pre>"},{"location":"from_pydoc/generated/memory/direct_memory_view/#libdebug.memory.direct_memory_view.DirectMemoryView.write","title":"<code>write(address, data)</code>","text":"<p>Writes memory to the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/memory/direct_memory_view.py</code> <pre><code>def write(self: DirectMemoryView, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target process.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n    size = len(data)\n\n    if self.align_to == 1:\n        self.setter(address, data)\n    else:\n        prefix = address % self.align_to\n        base_address = address - prefix\n        new_size = size + prefix\n        prefix_data = self.getter(base_address, new_size)\n        new_data = prefix_data[:prefix] + data + prefix_data[prefix + size :]\n        self.setter(base_address, new_data)\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/","title":"libdebug.memory.process_memory_manager","text":""},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager","title":"<code>ProcessMemoryManager</code>","text":"<p>A class that provides accessors to the memory of a process, through /proc/pid/mem.</p> Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>class ProcessMemoryManager:\n    \"\"\"A class that provides accessors to the memory of a process, through /proc/pid/mem.\"\"\"\n\n    def open(self: ProcessMemoryManager, process_id: int) -&gt; None:\n        \"\"\"Initializes the ProcessMemoryManager.\"\"\"\n        self.process_id = process_id\n        self._mem_file = None\n\n    def _open(self: ProcessMemoryManager) -&gt; None:\n        self._mem_file = open(f\"/proc/{self.process_id}/mem\", \"r+b\", buffering=0)\n\n    def read(self: ProcessMemoryManager, address: int, size: int) -&gt; bytes:\n        \"\"\"Reads memory from the target process.\n\n        Args:\n            address (int): The address to read from.\n            size (int): The number of bytes to read.\n\n        Returns:\n            bytes: The read bytes.\n        \"\"\"\n        if not self._mem_file:\n            self._open()\n\n        self._mem_file.seek(address)\n        return self._mem_file.read(size)\n\n    def write(self: ProcessMemoryManager, address: int, data: bytes) -&gt; None:\n        \"\"\"Writes memory to the target process.\n\n        Args:\n            address (int): The address to write to.\n            data (bytes): The data to write.\n        \"\"\"\n        if not self._mem_file:\n            self._open()\n\n        self._mem_file.seek(address)\n        self._mem_file.write(data)\n\n    def close(self: ProcessMemoryManager) -&gt; None:\n        \"\"\"Closes the memory file.\"\"\"\n        if self._mem_file:\n            self._mem_file.close()\n            self._mem_file = None\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager.close","title":"<code>close()</code>","text":"<p>Closes the memory file.</p> Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>def close(self: ProcessMemoryManager) -&gt; None:\n    \"\"\"Closes the memory file.\"\"\"\n    if self._mem_file:\n        self._mem_file.close()\n        self._mem_file = None\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager.open","title":"<code>open(process_id)</code>","text":"<p>Initializes the ProcessMemoryManager.</p> Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>def open(self: ProcessMemoryManager, process_id: int) -&gt; None:\n    \"\"\"Initializes the ProcessMemoryManager.\"\"\"\n    self.process_id = process_id\n    self._mem_file = None\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager.read","title":"<code>read(address, size)</code>","text":"<p>Reads memory from the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to read from.</p> required <code>size</code> <code>int</code> <p>The number of bytes to read.</p> required <p>Returns:</p> Name Type Description <code>bytes</code> <code>bytes</code> <p>The read bytes.</p> Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>def read(self: ProcessMemoryManager, address: int, size: int) -&gt; bytes:\n    \"\"\"Reads memory from the target process.\n\n    Args:\n        address (int): The address to read from.\n        size (int): The number of bytes to read.\n\n    Returns:\n        bytes: The read bytes.\n    \"\"\"\n    if not self._mem_file:\n        self._open()\n\n    self._mem_file.seek(address)\n    return self._mem_file.read(size)\n</code></pre>"},{"location":"from_pydoc/generated/memory/process_memory_manager/#libdebug.memory.process_memory_manager.ProcessMemoryManager.write","title":"<code>write(address, data)</code>","text":"<p>Writes memory to the target process.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to write to.</p> required <code>data</code> <code>bytes</code> <p>The data to write.</p> required Source code in <code>libdebug/memory/process_memory_manager.py</code> <pre><code>def write(self: ProcessMemoryManager, address: int, data: bytes) -&gt; None:\n    \"\"\"Writes memory to the target process.\n\n    Args:\n        address (int): The address to write to.\n        data (bytes): The data to write.\n    \"\"\"\n    if not self._mem_file:\n        self._open()\n\n    self._mem_file.seek(address)\n    self._mem_file.write(data)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_constants/","title":"libdebug.ptrace.ptrace_constants","text":""},{"location":"from_pydoc/generated/ptrace/ptrace_constants/#libdebug.ptrace.ptrace_constants.Commands","title":"<code>Commands</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration of the available ptrace commands.</p> Source code in <code>libdebug/ptrace/ptrace_constants.py</code> <pre><code>class Commands(IntEnum):\n    \"\"\"An enumeration of the available ptrace commands.\"\"\"\n\n    PTRACE_TRACEME = 0\n    PTRACE_PEEKTEXT = 1\n    PTRACE_PEEKDATA = 2\n    PTRACE_PEEKUSER = 3\n    PTRACE_POKETEXT = 4\n    PTRACE_POKEDATA = 5\n    PTRACE_POKEUSER = 6\n    PTRACE_CONT = 7\n    PTRACE_KILL = 8\n    PTRACE_SINGLESTEP = 9\n    PTRACE_GETREGS = 12\n    PTRACE_SETREGS = 13\n    PTRACE_GETFPREGS = 14\n    PTRACE_SETFPREGS = 15\n    PTRACE_ATTACH = 16\n    PTRACE_DETACH = 17\n    PTRACE_GETFPXREGS = 18\n    PTRACE_SETFPXREGS = 19\n    PTRACE_SYSCALL = 24\n    PTRACE_SETOPTIONS = 0x4200\n    PTRACE_GETEVENTMSG = 0x4201\n    PTRACE_GETSIGINFO = 0x4202\n    PTRACE_SETSIGINFO = 0x4203\n    PTRACE_GETREGSET = 0x4204\n    PTRACE_SETREGSET = 0x4205\n    PTRACE_SEIZE = 0x4206\n    PTRACE_INTERRUPT = 0x4207\n    PTRACE_LISTEN = 0x4208\n    PTRACE_PEEKSIGINFO = 0x4209\n    PTRACE_GETSIGMASK = 0x420A\n    PTRACE_SETSIGMASK = 0x420B\n    PTRACE_SECCOMP_GET_FILTER = 0x420C\n    PTRACE_SECCOMP_GET_METADATA = 0x420D\n    PTRACE_GET_SYSCALL_INFO = 0x420E\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_constants/#libdebug.ptrace.ptrace_constants.StopEvents","title":"<code>StopEvents</code>","text":"<p>               Bases: <code>IntEnum</code></p> <p>An enumeration of the stop events that ptrace can return.</p> Source code in <code>libdebug/ptrace/ptrace_constants.py</code> <pre><code>class StopEvents(IntEnum):\n    \"\"\"An enumeration of the stop events that ptrace can return.\"\"\"\n\n    CLONE_EVENT = SIGTRAP | (PTRACE_EVENT_CLONE &lt;&lt; 8)\n    EXEC_EVENT = SIGTRAP | (PTRACE_EVENT_EXEC &lt;&lt; 8)\n    EXIT_EVENT = SIGTRAP | (PTRACE_EVENT_EXIT &lt;&lt; 8)\n    FORK_EVENT = SIGTRAP | (PTRACE_EVENT_FORK &lt;&lt; 8)\n    VFORK_EVENT = SIGTRAP | (PTRACE_EVENT_VFORK &lt;&lt; 8)\n    VFORK_DONE_EVENT = SIGTRAP | (PTRACE_EVENT_VFORK_DONE &lt;&lt; 8)\n    SECCOMP_EVENT = SIGTRAP | (PTRACE_EVENT_SECCOMP &lt;&lt; 8)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/","title":"libdebug.ptrace.ptrace_interface","text":""},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface","title":"<code>PtraceInterface</code>","text":"<p>               Bases: <code>DebuggingInterface</code></p> <p>The interface used by <code>_InternalDebugger</code> to communicate with the <code>ptrace</code> debugging backend.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>class PtraceInterface(DebuggingInterface):\n    \"\"\"The interface used by `_InternalDebugger` to communicate with the `ptrace` debugging backend.\"\"\"\n\n    process_id: int | None\n    \"\"\"The process ID of the debugged process.\"\"\"\n\n    detached: bool\n    \"\"\"Whether the process was detached or not.\"\"\"\n\n    _internal_debugger: InternalDebugger\n    \"\"\"The internal debugger instance.\"\"\"\n\n    def __init__(self: PtraceInterface) -&gt; None:\n        super().__init__()\n\n        self.lib_trace = _ptrace_cffi.lib\n        self.ffi = _ptrace_cffi.ffi\n\n        self._internal_debugger = provide_internal_debugger(self)\n\n        self._global_state = self.ffi.new(\"struct global_state*\")\n        self._global_state.t_HEAD = self.ffi.NULL\n        self._global_state.dead_t_HEAD = self.ffi.NULL\n        self._global_state.sw_b_HEAD = self.ffi.NULL\n        self._global_state.hw_b_HEAD = self.ffi.NULL\n\n        self.process_id = 0\n        self.detached = False\n\n        self._disabled_aslr = False\n\n        self.reset()\n\n    def reset(self: PtraceInterface) -&gt; None:\n        \"\"\"Resets the state of the interface.\"\"\"\n        self.lib_trace.free_thread_list(self._global_state)\n        self.lib_trace.free_breakpoints(self._global_state)\n\n    def _set_options(self: PtraceInterface) -&gt; None:\n        \"\"\"Sets the tracer options.\"\"\"\n        self.lib_trace.ptrace_set_options(self.process_id)\n\n    def run(self: PtraceInterface, redirect_pipes: bool) -&gt; None:\n        \"\"\"Runs the specified process.\"\"\"\n        if not self._disabled_aslr and not self._internal_debugger.aslr_enabled:\n            disable_self_aslr()\n            self._disabled_aslr = True\n\n        argv = self._internal_debugger.argv\n        env = self._internal_debugger.env\n\n        liblog.debugger(\"Running %s\", argv)\n\n        # Setup ptrace wait status handler after debugging_context has been properly initialized\n        with extend_internal_debugger(self):\n            self.status_handler = PtraceStatusHandler()\n\n        file_actions = []\n\n        if redirect_pipes:\n            # Creating pipes for stdin, stdout, stderr\n            self.stdin_read, self.stdin_write = os.pipe()\n            self.stdout_read, self.stdout_write = pty.openpty()\n            self.stderr_read, self.stderr_write = pty.openpty()\n\n            # Setting stdout, stderr to raw mode to avoid terminal control codes interfering with the\n            # output\n            tty.setraw(self.stdout_read)\n            tty.setraw(self.stderr_read)\n\n            flags = fcntl(self.stdout_read, F_GETFL)\n            fcntl(self.stdout_read, F_SETFL, flags | os.O_NONBLOCK)\n\n            flags = fcntl(self.stderr_read, F_GETFL)\n            fcntl(self.stderr_read, F_SETFL, flags | os.O_NONBLOCK)\n\n            file_actions.extend(\n                [\n                    (POSIX_SPAWN_CLOSE, self.stdin_write),\n                    (POSIX_SPAWN_CLOSE, self.stdout_read),\n                    (POSIX_SPAWN_CLOSE, self.stderr_read),\n                    (POSIX_SPAWN_DUP2, self.stdin_read, 0),\n                    (POSIX_SPAWN_DUP2, self.stdout_write, 1),\n                    (POSIX_SPAWN_DUP2, self.stderr_write, 2),\n                    (POSIX_SPAWN_CLOSE, self.stdin_read),\n                    (POSIX_SPAWN_CLOSE, self.stdout_write),\n                    (POSIX_SPAWN_CLOSE, self.stderr_write),\n                ]\n            )\n\n        # argv[1] is the length of the custom environment variables\n        # argv[2:2 + env_len] is the custom environment variables\n        # argv[2 + env_len] should be NULL\n        # argv[2 + env_len + 1:] is the new argv\n        if env is None:\n            env_len = -1\n            env = {}\n        else:\n            env_len = len(env)\n\n        argv = [\n            JUMPSTART_LOCATION,\n            str(env_len),\n            *[f\"{key}={value}\" for key, value in env.items()],\n            \"NULL\",\n            *argv,\n        ]\n\n        child_pid = posix_spawn(\n            JUMPSTART_LOCATION,\n            argv,\n            os.environ,\n            file_actions=file_actions,\n            setpgroup=0,\n        )\n\n        self.process_id = child_pid\n        self.detached = False\n        self._internal_debugger.process_id = child_pid\n        self.register_new_thread(child_pid)\n        continue_to_entry_point = self._internal_debugger.autoreach_entrypoint\n        self._setup_parent(continue_to_entry_point)\n\n        if redirect_pipes:\n            self._internal_debugger.pipe_manager = self._setup_pipe()\n        else:\n            self._internal_debugger.pipe_manager = None\n\n            # https://stackoverflow.com/questions/58918188/why-is-stdin-not-propagated-to-child-process-of-different-process-group\n            # We need to set the foreground process group to the child process group, otherwise the child process\n            # will not receive the input from the terminal\n            try:\n                os.tcsetpgrp(0, child_pid)\n            except OSError as e:\n                liblog.debugger(\"Failed to set the foreground process group: %r\", e)\n\n    def attach(self: PtraceInterface, pid: int) -&gt; None:\n        \"\"\"Attaches to the specified process.\n\n        Args:\n            pid (int): the pid of the process to attach to.\n        \"\"\"\n        # Setup ptrace wait status handler after debugging_context has been properly initialized\n        with extend_internal_debugger(self):\n            self.status_handler = PtraceStatusHandler()\n\n        # Attach to all the tasks of the process\n        self._attach_to_all_tasks(pid)\n\n        self.process_id = pid\n        self.detached = False\n        self._internal_debugger.process_id = pid\n        # If we are attaching to a process, we don't want to continue to the entry point\n        # which we have probably already passed\n        self._setup_parent(False)\n\n    def _attach_to_all_tasks(self: PtraceStatusHandler, pid: int) -&gt; None:\n        \"\"\"Attach to all the tasks of the process.\"\"\"\n        tids = get_process_tasks(pid)\n        for tid in tids:\n            res = self.lib_trace.ptrace_attach(tid)\n            if res == -1:\n                errno_val = self.ffi.errno\n                if errno_val == errno.EPERM:\n                    raise PermissionError(\n                        errno_val,\n                        errno.errorcode[errno_val],\n                        \"You don't have permission to attach to the process. Did you check the ptrace_scope?\",\n                    )\n                raise OSError(errno_val, errno.errorcode[errno_val])\n            self.register_new_thread(tid)\n\n    def detach(self: PtraceInterface) -&gt; None:\n        \"\"\"Detaches from the process.\"\"\"\n        # We must disable all breakpoints before detaching\n        for bp in list(self._internal_debugger.breakpoints.values()):\n            if bp.enabled:\n                self.unset_breakpoint(bp, delete=True)\n\n        self.lib_trace.ptrace_detach_and_cont(self._global_state, self.process_id)\n\n        self.detached = True\n\n        # Reset the event type\n        self._internal_debugger.resume_context.event_type.clear()\n\n        # Reset the breakpoint hit\n        self._internal_debugger.resume_context.event_hit_ref.clear()\n\n    def kill(self: PtraceInterface) -&gt; None:\n        \"\"\"Instantly terminates the process.\"\"\"\n        if not self.detached:\n            self.lib_trace.ptrace_detach_for_kill(self._global_state, self.process_id)\n        else:\n            # If we detached from the process, there's no reason to attempt to detach again\n            # We can just kill the process\n            os.kill(self.process_id, 9)\n            os.waitpid(self.process_id, 0)\n\n    def cont(self: PtraceInterface) -&gt; None:\n        \"\"\"Continues the execution of the process.\"\"\"\n        # Forward signals to the threads\n        if self._internal_debugger.resume_context.threads_with_signals_to_forward:\n            self.forward_signal()\n\n        # Enable all breakpoints if they were disabled for a single step\n        changed = []\n\n        for bp in self._internal_debugger.breakpoints.values():\n            bp._disabled_for_step = False\n            if bp._changed:\n                changed.append(bp)\n                bp._changed = False\n\n        for bp in changed:\n            if bp.enabled:\n                self.set_breakpoint(bp, insert=False)\n            else:\n                self.unset_breakpoint(bp, delete=False)\n\n        for handler in self._internal_debugger.handled_syscalls.values():\n            if handler.enabled or handler.on_enter_pprint or handler.on_exit_pprint:\n                self._global_state.handle_syscall_enabled = True\n                break\n        else:\n            self._global_state.handle_syscall_enabled = False\n\n        # Reset the event type\n        self._internal_debugger.resume_context.event_type.clear()\n\n        # Reset the breakpoint hit\n        self._internal_debugger.resume_context.event_hit_ref.clear()\n\n        result = self.lib_trace.cont_all_and_set_bps(\n            self._global_state,\n            self.process_id,\n        )\n\n        if result &lt; 0:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n    def step(self: PtraceInterface, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n        \"\"\"\n        # Disable all breakpoints for the single step\n        for bp in self._internal_debugger.breakpoints.values():\n            bp._disabled_for_step = True\n\n        # Reset the event type\n        self._internal_debugger.resume_context.event_type.clear()\n\n        # Reset the breakpoint hit\n        self._internal_debugger.resume_context.event_hit_ref.clear()\n\n        result = self.lib_trace.singlestep(self._global_state, thread.thread_id)\n        if result == -1:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n        self._internal_debugger.resume_context.is_a_step = True\n\n    def step_until(self: PtraceInterface, thread: ThreadContext, address: int, max_steps: int) -&gt; None:\n        \"\"\"Executes instructions of the specified thread until the specified address is reached.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n            address (int): The address to reach.\n            max_steps (int): The maximum number of steps to execute.\n        \"\"\"\n        # Disable all breakpoints for the single step\n        for bp in self._internal_debugger.breakpoints.values():\n            bp._disabled_for_step = True\n\n        # Reset the event type\n        self._internal_debugger.resume_context.event_type.clear()\n\n        # Reset the breakpoint hit\n        self._internal_debugger.resume_context.event_hit_ref.clear()\n\n        result = self.lib_trace.step_until(\n            self._global_state,\n            thread.thread_id,\n            address,\n            max_steps,\n        )\n        if result == -1:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n        # As the wait is done internally, we must invalidate the cache\n        invalidate_process_cache()\n\n    def finish(self: PtraceInterface, thread: ThreadContext, heuristic: str) -&gt; None:\n        \"\"\"Continues execution until the current function returns.\n\n        Args:\n            thread (ThreadContext): The thread to step.\n            heuristic (str): The heuristic to use.\n        \"\"\"\n        # Reset the event type\n        self._internal_debugger.resume_context.event_type.clear()\n\n        # Reset the breakpoint hit\n        self._internal_debugger.resume_context.event_hit_ref.clear()\n\n        if heuristic == \"step-mode\":\n            result = self.lib_trace.stepping_finish(\n                self._global_state,\n                thread.thread_id,\n                self._internal_debugger.arch == \"i386\",\n            )\n\n            if result == -1:\n                errno_val = self.ffi.errno\n                raise OSError(errno_val, errno.errorcode[errno_val])\n\n            # As the wait is done internally, we must invalidate the cache\n            invalidate_process_cache()\n        elif heuristic == \"backtrace\":\n            # Breakpoint to return address\n            last_saved_instruction_pointer = thread.saved_ip\n\n            # If a breakpoint already exists at the return address, we don't need to set a new one\n            found = False\n            ip_breakpoint = None\n\n            for bp in self._internal_debugger.breakpoints.values():\n                if bp.address == last_saved_instruction_pointer:\n                    found = True\n                    ip_breakpoint = bp\n                    break\n\n            # If we find an existing breakpoint that is disabled, we enable it\n            # but we need to disable it back after the command\n            should_disable = False\n\n            if not found:\n                # Check if we have enough hardware breakpoints available\n                # Otherwise we use a software breakpoint\n                install_hw_bp = (\n                    self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id) &gt; 0\n                )\n\n                ip_breakpoint = Breakpoint(last_saved_instruction_pointer, hardware=install_hw_bp)\n                self.set_breakpoint(ip_breakpoint)\n            elif not ip_breakpoint.enabled:\n                self._enable_breakpoint(ip_breakpoint)\n                should_disable = True\n\n            self.cont()\n            self.wait()\n\n            # Remove the breakpoint if it was set by us\n            if not found:\n                self.unset_breakpoint(ip_breakpoint)\n            # Disable the breakpoint if it was just enabled by us\n            elif should_disable:\n                self._disable_breakpoint(ip_breakpoint)\n        else:\n            raise ValueError(f\"Unimplemented heuristic {heuristic}\")\n\n    def next(self: PtraceInterface, thread: ThreadContext) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        # Reset the event type\n        self._internal_debugger.resume_context.event_type.clear()\n\n        # Reset the breakpoint hit\n        self._internal_debugger.resume_context.event_hit_ref.clear()\n\n        opcode_window = thread.memory.read(thread.instruction_pointer, 8)\n\n        # Check if the current instruction is a call and its skip amount\n        is_call, skip = call_utilities_provider(self._internal_debugger.arch).get_call_and_skip_amount(opcode_window)\n\n        if is_call:\n            skip_address = thread.instruction_pointer + skip\n\n            # If a breakpoint already exists at the return address, we don't need to set a new one\n            found = False\n            ip_breakpoint = self._internal_debugger.breakpoints.get(skip_address)\n\n            if ip_breakpoint is not None:\n                found = True\n\n            # If we find an existing breakpoint that is disabled, we enable it\n            # but we need to disable it back after the command\n            should_disable = False\n\n            if not found:\n                # Check if we have enough hardware breakpoints available\n                # Otherwise we use a software breakpoint\n                install_hw_bp = (\n                    self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id) &gt; 0\n                )\n                ip_breakpoint = Breakpoint(skip_address, hardware=install_hw_bp)\n                self.set_breakpoint(ip_breakpoint)\n            elif not ip_breakpoint.enabled:\n                self._enable_breakpoint(ip_breakpoint)\n                should_disable = True\n\n            self.cont()\n            self.wait()\n\n            # Remove the breakpoint if it was set by us\n            if not found:\n                self.unset_breakpoint(ip_breakpoint)\n            # Disable the breakpoint if it was just enabled by us\n            elif should_disable:\n                self._disable_breakpoint(ip_breakpoint)\n        else:\n            # Step forward\n            self.step(thread)\n            self.wait()\n\n    def _setup_pipe(self: PtraceInterface) -&gt; None:\n        \"\"\"Sets up the pipe manager for the child process.\n\n        Close the read end for stdin and the write ends for stdout and stderr\n        in the parent process since we are going to write to stdin and read from\n        stdout and stderr\n        \"\"\"\n        try:\n            os.close(self.stdin_read)\n            os.close(self.stdout_write)\n            os.close(self.stderr_write)\n        except Exception as e:\n            raise Exception(\"Closing fds failed: %r\", e) from e\n        with extend_internal_debugger(self):\n            return PipeManager(self.stdin_write, self.stdout_read, self.stderr_read)\n\n    def _setup_parent(self: PtraceInterface, continue_to_entry_point: bool) -&gt; None:\n        \"\"\"Sets up the parent process after the child process has been created or attached to.\"\"\"\n        liblog.debugger(\"Polling child process status\")\n        self._internal_debugger.resume_context.is_startup = True\n        self.wait()\n        self._internal_debugger.resume_context.is_startup = False\n        liblog.debugger(\"Child process ready, setting options\")\n        self._set_options()\n        liblog.debugger(\"Options set\")\n\n        if continue_to_entry_point:\n            # Now that the process is running, we must continue until we have reached the entry point\n            entry_point = get_entry_point(self._internal_debugger.argv[0])\n\n            # For PIE binaries, the entry point is a relative address\n            entry_point = normalize_and_validate_address(entry_point, self.get_maps())\n\n            bp = Breakpoint(entry_point, hardware=True)\n            self.set_breakpoint(bp)\n            self.cont()\n            self.wait()\n\n            self.unset_breakpoint(bp)\n\n        invalidate_process_cache()\n\n    def wait(self: PtraceInterface) -&gt; None:\n        \"\"\"Waits for the process to stop. Returns True if the wait has to be repeated.\"\"\"\n        result = self.lib_trace.wait_all_and_update_regs(\n            self._global_state,\n            self.process_id,\n        )\n\n        cursor = result\n\n        invalidate_process_cache()\n\n        results = []\n\n        while cursor != self.ffi.NULL:\n            results.append((cursor.tid, cursor.status))\n            cursor = cursor.next\n\n        # Check the result of the waitpid and handle the changes.\n        self.status_handler.manage_change(results)\n\n        self.lib_trace.free_thread_status_list(result)\n\n    def forward_signal(self: PtraceInterface) -&gt; None:\n        \"\"\"Set the signals to forward to the threads.\"\"\"\n        # change the global_state\n        cursor = self._global_state.t_HEAD\n        threads = self._internal_debugger.resume_context.threads_with_signals_to_forward\n\n        while cursor != self.ffi.NULL:\n            if cursor.tid in threads:\n                thread = self._internal_debugger.get_thread_by_id(cursor.tid)\n                if thread is None:\n                    # The thread is dead in the meantime\n                    continue\n                if thread._signal_number != 0 and thread._signal_number not in self._internal_debugger.signals_to_block:\n                    liblog.debugger(\n                        f\"Forwarding signal {thread._signal_number} to thread {cursor.tid}\",\n                    )\n                    # Set the signal to forward\n                    cursor.signal_to_forward = thread._signal_number\n                    # Reset the signal to forward\n                    thread._signal_number = 0\n            cursor = cursor.next\n\n        # Clear the list of threads with signals to forward\n        self._internal_debugger.resume_context.threads_with_signals_to_forward.clear()\n\n    def migrate_to_gdb(self: PtraceInterface) -&gt; None:\n        \"\"\"Migrates the current process to GDB.\"\"\"\n        # Delete any hardware breakpoint\n        for bp in self._internal_debugger.breakpoints.values():\n            if bp.hardware:\n                for thread in self._internal_debugger.threads:\n                    self.lib_trace.unregister_hw_breakpoint(\n                        self._global_state,\n                        thread.thread_id,\n                        bp.address,\n                    )\n\n        self.lib_trace.ptrace_detach_for_migration(self._global_state, self.process_id)\n\n    def migrate_from_gdb(self: PtraceInterface) -&gt; None:\n        \"\"\"Migrates the current process from GDB.\"\"\"\n        self.lib_trace.ptrace_reattach_from_gdb(self._global_state, self.process_id)\n\n        invalidate_process_cache()\n        self.status_handler.check_for_new_threads(self.process_id)\n\n        # We have to reinstall any hardware breakpoint\n        for bp in self._internal_debugger.breakpoints.values():\n            if bp.hardware:\n                for thread in self._internal_debugger.threads:\n                    self.lib_trace.register_hw_breakpoint(\n                        self._global_state,\n                        thread.thread_id,\n                        bp.address,\n                        bp.condition.encode().ljust(2, b\"\\x00\"),\n                        chr(bp.length).encode(),\n                    )\n\n    def register_new_thread(self: PtraceInterface, new_thread_id: int) -&gt; None:\n        \"\"\"Registers a new thread.\n\n        Args:\n            new_thread_id (int): The new thread ID.\n        \"\"\"\n        # The FFI implementation returns a pointer to the register file\n        register_file = self.lib_trace.register_thread(\n            self._global_state,\n            new_thread_id,\n        )\n\n        fp_register_file = self.lib_trace.get_thread_fp_regs(self._global_state, new_thread_id)\n\n        register_holder = register_holder_provider(self._internal_debugger.arch, register_file, fp_register_file)\n\n        with extend_internal_debugger(self._internal_debugger):\n            thread = ThreadContext(new_thread_id, register_holder)\n\n        self._internal_debugger.insert_new_thread(thread)\n\n        # For any hardware breakpoints, we need to reapply them to the new thread\n        for bp in self._internal_debugger.breakpoints.values():\n            if bp.hardware:\n                self.lib_trace.register_hw_breakpoint(\n                    self._global_state,\n                    new_thread_id,\n                    bp.address,\n                    bp.condition.encode().ljust(2, b\"\\x00\"),\n                    chr(bp.length).encode(),\n                )\n\n    def unregister_thread(\n        self: PtraceInterface,\n        thread_id: int,\n        exit_code: int | None,\n        exit_signal: int | None,\n    ) -&gt; None:\n        \"\"\"Unregisters a thread.\n\n        Args:\n            thread_id (int): The thread ID.\n            exit_code (int): The exit code of the thread.\n            exit_signal (int): The exit signal of the thread.\n        \"\"\"\n        self.lib_trace.unregister_thread(self._global_state, thread_id)\n\n        self._internal_debugger.set_thread_as_dead(thread_id, exit_code=exit_code, exit_signal=exit_signal)\n\n    def _set_sw_breakpoint(self: PtraceInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Sets a software breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to set.\n        \"\"\"\n        self.lib_trace.register_breakpoint(\n            self._global_state,\n            self.process_id,\n            bp.address,\n        )\n\n    def _unset_sw_breakpoint(self: PtraceInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Unsets a software breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to unset.\n        \"\"\"\n        self.lib_trace.unregister_breakpoint(self._global_state, bp.address)\n\n    def _enable_breakpoint(self: PtraceInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Enables a breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to enable.\n        \"\"\"\n        self.lib_trace.enable_breakpoint(self._global_state, bp.address)\n\n    def _disable_breakpoint(self: PtraceInterface, bp: Breakpoint) -&gt; None:\n        \"\"\"Disables a breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to disable.\n        \"\"\"\n        self.lib_trace.disable_breakpoint(self._global_state, bp.address)\n\n    def set_breakpoint(self: PtraceInterface, bp: Breakpoint, insert: bool = True) -&gt; None:\n        \"\"\"Sets a breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to set.\n            insert (bool): Whether the breakpoint has to be inserted or just enabled.\n        \"\"\"\n        if bp.hardware:\n            for thread in self._internal_debugger.threads:\n                if bp.condition == \"x\":\n                    remaining = self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id)\n                else:\n                    remaining = self.lib_trace.get_remaining_hw_watchpoint_count(self._global_state, thread.thread_id)\n\n                if not remaining:\n                    raise ValueError(\"No more hardware breakpoints of this type available\")\n\n                self.lib_trace.register_hw_breakpoint(\n                    self._global_state,\n                    thread.thread_id,\n                    bp.address,\n                    bp.condition.encode().ljust(2, b\"\\x00\"),\n                    chr(bp.length).encode(),\n                )\n        elif insert:\n            self._set_sw_breakpoint(bp)\n        else:\n            self._enable_breakpoint(bp)\n\n        if insert:\n            self._internal_debugger.breakpoints[bp.address] = bp\n\n    def unset_breakpoint(self: PtraceInterface, bp: Breakpoint, delete: bool = True) -&gt; None:\n        \"\"\"Restores the breakpoint at the specified address.\n\n        Args:\n            bp (Breakpoint): The breakpoint to unset.\n            delete (bool): Whether the breakpoint has to be deleted or just disabled.\n        \"\"\"\n        if bp.hardware:\n            for thread in self._internal_debugger.threads:\n                self.lib_trace.unregister_hw_breakpoint(\n                    self._global_state,\n                    thread.thread_id,\n                    bp.address,\n                )\n        elif delete:\n            self._unset_sw_breakpoint(bp)\n        else:\n            self._disable_breakpoint(bp)\n\n        if delete:\n            del self._internal_debugger.breakpoints[bp.address]\n\n    def set_syscall_handler(self: PtraceInterface, handler: SyscallHandler) -&gt; None:\n        \"\"\"Sets a handler for a syscall.\n\n        Args:\n            handler (HandledSyscall): The syscall to set.\n        \"\"\"\n        self._internal_debugger.handled_syscalls[handler.syscall_number] = handler\n\n    def unset_syscall_handler(self: PtraceInterface, handler: SyscallHandler) -&gt; None:\n        \"\"\"Unsets a handler for a syscall.\n\n        Args:\n            handler (HandledSyscall): The syscall to unset.\n        \"\"\"\n        del self._internal_debugger.handled_syscalls[handler.syscall_number]\n\n    def set_signal_catcher(self: PtraceInterface, catcher: SignalCatcher) -&gt; None:\n        \"\"\"Sets a catcher for a signal.\n\n        Args:\n            catcher (CaughtSignal): The signal to set.\n        \"\"\"\n        self._internal_debugger.caught_signals[catcher.signal_number] = catcher\n\n    def unset_signal_catcher(self: PtraceInterface, catcher: SignalCatcher) -&gt; None:\n        \"\"\"Unset a catcher for a signal.\n\n        Args:\n            catcher (CaughtSignal): The signal to unset.\n        \"\"\"\n        del self._internal_debugger.caught_signals[catcher.signal_number]\n\n    def peek_memory(self: PtraceInterface, address: int) -&gt; int:\n        \"\"\"Reads the memory at the specified address.\"\"\"\n        result = self.lib_trace.ptrace_peekdata(self.process_id, address)\n        liblog.debugger(\n            \"PEEKDATA at address %d returned with result %x\",\n            address,\n            result,\n        )\n\n        error = self.ffi.errno\n        if error:\n            raise OSError(error, errno.errorcode[error])\n\n        return result\n\n    def poke_memory(self: PtraceInterface, address: int, value: int) -&gt; None:\n        \"\"\"Writes the memory at the specified address.\"\"\"\n        result = self.lib_trace.ptrace_pokedata(self.process_id, address, value)\n        liblog.debugger(\n            \"POKEDATA at address %d returned with result %d\",\n            address,\n            result,\n        )\n\n        if result == -1:\n            error = self.ffi.errno\n            raise OSError(error, errno.errorcode[error])\n\n    def fetch_fp_registers(self: PtraceInterface, registers: Registers) -&gt; None:\n        \"\"\"Fetches the floating-point registers of the specified thread.\n\n        Args:\n            registers (Registers): The registers instance to update.\n        \"\"\"\n        liblog.debugger(\"Fetching floating-point registers for thread %d\", registers._thread_id)\n        self.lib_trace.get_fp_regs(registers._thread_id, registers._fp_register_file)\n\n    def flush_fp_registers(self: PtraceInterface, _: Registers) -&gt; None:\n        \"\"\"Flushes the floating-point registers of the specified thread.\n\n        Args:\n            registers (Registers): The registers instance to update.\n        \"\"\"\n        raise NotImplementedError(\"Flushing floating-point registers is automatically handled by the native code.\")\n\n    def _get_event_msg(self: PtraceInterface, thread_id: int) -&gt; int:\n        \"\"\"Returns the event message.\"\"\"\n        return self.lib_trace.ptrace_geteventmsg(thread_id)\n\n    def get_maps(self: PtraceInterface) -&gt; MemoryMapList[MemoryMap]:\n        \"\"\"Returns the memory maps of the process.\"\"\"\n        with extend_internal_debugger(self._internal_debugger):\n            return get_process_maps(self.process_id)\n\n    def get_hit_watchpoint(self: PtraceInterface, thread_id: int) -&gt; Breakpoint:\n        \"\"\"Returns the watchpoint that has been hit.\"\"\"\n        address = self.lib_trace.get_hit_hw_breakpoint(self._global_state, thread_id)\n\n        if not address:\n            return None\n\n        bp = self._internal_debugger.breakpoints[address]\n\n        if bp.condition != \"x\":\n            return bp\n\n        return None\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.detached","title":"<code>detached: bool = False</code>  <code>instance-attribute</code>","text":"<p>Whether the process was detached or not.</p>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.process_id","title":"<code>process_id: int | None = 0</code>  <code>instance-attribute</code>","text":"<p>The process ID of the debugged process.</p>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.attach","title":"<code>attach(pid)</code>","text":"<p>Attaches to the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>pid</code> <code>int</code> <p>the pid of the process to attach to.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def attach(self: PtraceInterface, pid: int) -&gt; None:\n    \"\"\"Attaches to the specified process.\n\n    Args:\n        pid (int): the pid of the process to attach to.\n    \"\"\"\n    # Setup ptrace wait status handler after debugging_context has been properly initialized\n    with extend_internal_debugger(self):\n        self.status_handler = PtraceStatusHandler()\n\n    # Attach to all the tasks of the process\n    self._attach_to_all_tasks(pid)\n\n    self.process_id = pid\n    self.detached = False\n    self._internal_debugger.process_id = pid\n    # If we are attaching to a process, we don't want to continue to the entry point\n    # which we have probably already passed\n    self._setup_parent(False)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.cont","title":"<code>cont()</code>","text":"<p>Continues the execution of the process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def cont(self: PtraceInterface) -&gt; None:\n    \"\"\"Continues the execution of the process.\"\"\"\n    # Forward signals to the threads\n    if self._internal_debugger.resume_context.threads_with_signals_to_forward:\n        self.forward_signal()\n\n    # Enable all breakpoints if they were disabled for a single step\n    changed = []\n\n    for bp in self._internal_debugger.breakpoints.values():\n        bp._disabled_for_step = False\n        if bp._changed:\n            changed.append(bp)\n            bp._changed = False\n\n    for bp in changed:\n        if bp.enabled:\n            self.set_breakpoint(bp, insert=False)\n        else:\n            self.unset_breakpoint(bp, delete=False)\n\n    for handler in self._internal_debugger.handled_syscalls.values():\n        if handler.enabled or handler.on_enter_pprint or handler.on_exit_pprint:\n            self._global_state.handle_syscall_enabled = True\n            break\n    else:\n        self._global_state.handle_syscall_enabled = False\n\n    # Reset the event type\n    self._internal_debugger.resume_context.event_type.clear()\n\n    # Reset the breakpoint hit\n    self._internal_debugger.resume_context.event_hit_ref.clear()\n\n    result = self.lib_trace.cont_all_and_set_bps(\n        self._global_state,\n        self.process_id,\n    )\n\n    if result &lt; 0:\n        errno_val = self.ffi.errno\n        raise OSError(errno_val, errno.errorcode[errno_val])\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.detach","title":"<code>detach()</code>","text":"<p>Detaches from the process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def detach(self: PtraceInterface) -&gt; None:\n    \"\"\"Detaches from the process.\"\"\"\n    # We must disable all breakpoints before detaching\n    for bp in list(self._internal_debugger.breakpoints.values()):\n        if bp.enabled:\n            self.unset_breakpoint(bp, delete=True)\n\n    self.lib_trace.ptrace_detach_and_cont(self._global_state, self.process_id)\n\n    self.detached = True\n\n    # Reset the event type\n    self._internal_debugger.resume_context.event_type.clear()\n\n    # Reset the breakpoint hit\n    self._internal_debugger.resume_context.event_hit_ref.clear()\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.fetch_fp_registers","title":"<code>fetch_fp_registers(registers)</code>","text":"<p>Fetches the floating-point registers of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>registers</code> <code>Registers</code> <p>The registers instance to update.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def fetch_fp_registers(self: PtraceInterface, registers: Registers) -&gt; None:\n    \"\"\"Fetches the floating-point registers of the specified thread.\n\n    Args:\n        registers (Registers): The registers instance to update.\n    \"\"\"\n    liblog.debugger(\"Fetching floating-point registers for thread %d\", registers._thread_id)\n    self.lib_trace.get_fp_regs(registers._thread_id, registers._fp_register_file)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.finish","title":"<code>finish(thread, heuristic)</code>","text":"<p>Continues execution until the current function returns.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required <code>heuristic</code> <code>str</code> <p>The heuristic to use.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def finish(self: PtraceInterface, thread: ThreadContext, heuristic: str) -&gt; None:\n    \"\"\"Continues execution until the current function returns.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n        heuristic (str): The heuristic to use.\n    \"\"\"\n    # Reset the event type\n    self._internal_debugger.resume_context.event_type.clear()\n\n    # Reset the breakpoint hit\n    self._internal_debugger.resume_context.event_hit_ref.clear()\n\n    if heuristic == \"step-mode\":\n        result = self.lib_trace.stepping_finish(\n            self._global_state,\n            thread.thread_id,\n            self._internal_debugger.arch == \"i386\",\n        )\n\n        if result == -1:\n            errno_val = self.ffi.errno\n            raise OSError(errno_val, errno.errorcode[errno_val])\n\n        # As the wait is done internally, we must invalidate the cache\n        invalidate_process_cache()\n    elif heuristic == \"backtrace\":\n        # Breakpoint to return address\n        last_saved_instruction_pointer = thread.saved_ip\n\n        # If a breakpoint already exists at the return address, we don't need to set a new one\n        found = False\n        ip_breakpoint = None\n\n        for bp in self._internal_debugger.breakpoints.values():\n            if bp.address == last_saved_instruction_pointer:\n                found = True\n                ip_breakpoint = bp\n                break\n\n        # If we find an existing breakpoint that is disabled, we enable it\n        # but we need to disable it back after the command\n        should_disable = False\n\n        if not found:\n            # Check if we have enough hardware breakpoints available\n            # Otherwise we use a software breakpoint\n            install_hw_bp = (\n                self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id) &gt; 0\n            )\n\n            ip_breakpoint = Breakpoint(last_saved_instruction_pointer, hardware=install_hw_bp)\n            self.set_breakpoint(ip_breakpoint)\n        elif not ip_breakpoint.enabled:\n            self._enable_breakpoint(ip_breakpoint)\n            should_disable = True\n\n        self.cont()\n        self.wait()\n\n        # Remove the breakpoint if it was set by us\n        if not found:\n            self.unset_breakpoint(ip_breakpoint)\n        # Disable the breakpoint if it was just enabled by us\n        elif should_disable:\n            self._disable_breakpoint(ip_breakpoint)\n    else:\n        raise ValueError(f\"Unimplemented heuristic {heuristic}\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.flush_fp_registers","title":"<code>flush_fp_registers(_)</code>","text":"<p>Flushes the floating-point registers of the specified thread.</p> <p>Parameters:</p> Name Type Description Default <code>registers</code> <code>Registers</code> <p>The registers instance to update.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def flush_fp_registers(self: PtraceInterface, _: Registers) -&gt; None:\n    \"\"\"Flushes the floating-point registers of the specified thread.\n\n    Args:\n        registers (Registers): The registers instance to update.\n    \"\"\"\n    raise NotImplementedError(\"Flushing floating-point registers is automatically handled by the native code.\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.forward_signal","title":"<code>forward_signal()</code>","text":"<p>Set the signals to forward to the threads.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def forward_signal(self: PtraceInterface) -&gt; None:\n    \"\"\"Set the signals to forward to the threads.\"\"\"\n    # change the global_state\n    cursor = self._global_state.t_HEAD\n    threads = self._internal_debugger.resume_context.threads_with_signals_to_forward\n\n    while cursor != self.ffi.NULL:\n        if cursor.tid in threads:\n            thread = self._internal_debugger.get_thread_by_id(cursor.tid)\n            if thread is None:\n                # The thread is dead in the meantime\n                continue\n            if thread._signal_number != 0 and thread._signal_number not in self._internal_debugger.signals_to_block:\n                liblog.debugger(\n                    f\"Forwarding signal {thread._signal_number} to thread {cursor.tid}\",\n                )\n                # Set the signal to forward\n                cursor.signal_to_forward = thread._signal_number\n                # Reset the signal to forward\n                thread._signal_number = 0\n        cursor = cursor.next\n\n    # Clear the list of threads with signals to forward\n    self._internal_debugger.resume_context.threads_with_signals_to_forward.clear()\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.get_hit_watchpoint","title":"<code>get_hit_watchpoint(thread_id)</code>","text":"<p>Returns the watchpoint that has been hit.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def get_hit_watchpoint(self: PtraceInterface, thread_id: int) -&gt; Breakpoint:\n    \"\"\"Returns the watchpoint that has been hit.\"\"\"\n    address = self.lib_trace.get_hit_hw_breakpoint(self._global_state, thread_id)\n\n    if not address:\n        return None\n\n    bp = self._internal_debugger.breakpoints[address]\n\n    if bp.condition != \"x\":\n        return bp\n\n    return None\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.get_maps","title":"<code>get_maps()</code>","text":"<p>Returns the memory maps of the process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def get_maps(self: PtraceInterface) -&gt; MemoryMapList[MemoryMap]:\n    \"\"\"Returns the memory maps of the process.\"\"\"\n    with extend_internal_debugger(self._internal_debugger):\n        return get_process_maps(self.process_id)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.kill","title":"<code>kill()</code>","text":"<p>Instantly terminates the process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def kill(self: PtraceInterface) -&gt; None:\n    \"\"\"Instantly terminates the process.\"\"\"\n    if not self.detached:\n        self.lib_trace.ptrace_detach_for_kill(self._global_state, self.process_id)\n    else:\n        # If we detached from the process, there's no reason to attempt to detach again\n        # We can just kill the process\n        os.kill(self.process_id, 9)\n        os.waitpid(self.process_id, 0)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.migrate_from_gdb","title":"<code>migrate_from_gdb()</code>","text":"<p>Migrates the current process from GDB.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def migrate_from_gdb(self: PtraceInterface) -&gt; None:\n    \"\"\"Migrates the current process from GDB.\"\"\"\n    self.lib_trace.ptrace_reattach_from_gdb(self._global_state, self.process_id)\n\n    invalidate_process_cache()\n    self.status_handler.check_for_new_threads(self.process_id)\n\n    # We have to reinstall any hardware breakpoint\n    for bp in self._internal_debugger.breakpoints.values():\n        if bp.hardware:\n            for thread in self._internal_debugger.threads:\n                self.lib_trace.register_hw_breakpoint(\n                    self._global_state,\n                    thread.thread_id,\n                    bp.address,\n                    bp.condition.encode().ljust(2, b\"\\x00\"),\n                    chr(bp.length).encode(),\n                )\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.migrate_to_gdb","title":"<code>migrate_to_gdb()</code>","text":"<p>Migrates the current process to GDB.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def migrate_to_gdb(self: PtraceInterface) -&gt; None:\n    \"\"\"Migrates the current process to GDB.\"\"\"\n    # Delete any hardware breakpoint\n    for bp in self._internal_debugger.breakpoints.values():\n        if bp.hardware:\n            for thread in self._internal_debugger.threads:\n                self.lib_trace.unregister_hw_breakpoint(\n                    self._global_state,\n                    thread.thread_id,\n                    bp.address,\n                )\n\n    self.lib_trace.ptrace_detach_for_migration(self._global_state, self.process_id)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.next","title":"<code>next(thread)</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def next(self: PtraceInterface, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    # Reset the event type\n    self._internal_debugger.resume_context.event_type.clear()\n\n    # Reset the breakpoint hit\n    self._internal_debugger.resume_context.event_hit_ref.clear()\n\n    opcode_window = thread.memory.read(thread.instruction_pointer, 8)\n\n    # Check if the current instruction is a call and its skip amount\n    is_call, skip = call_utilities_provider(self._internal_debugger.arch).get_call_and_skip_amount(opcode_window)\n\n    if is_call:\n        skip_address = thread.instruction_pointer + skip\n\n        # If a breakpoint already exists at the return address, we don't need to set a new one\n        found = False\n        ip_breakpoint = self._internal_debugger.breakpoints.get(skip_address)\n\n        if ip_breakpoint is not None:\n            found = True\n\n        # If we find an existing breakpoint that is disabled, we enable it\n        # but we need to disable it back after the command\n        should_disable = False\n\n        if not found:\n            # Check if we have enough hardware breakpoints available\n            # Otherwise we use a software breakpoint\n            install_hw_bp = (\n                self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id) &gt; 0\n            )\n            ip_breakpoint = Breakpoint(skip_address, hardware=install_hw_bp)\n            self.set_breakpoint(ip_breakpoint)\n        elif not ip_breakpoint.enabled:\n            self._enable_breakpoint(ip_breakpoint)\n            should_disable = True\n\n        self.cont()\n        self.wait()\n\n        # Remove the breakpoint if it was set by us\n        if not found:\n            self.unset_breakpoint(ip_breakpoint)\n        # Disable the breakpoint if it was just enabled by us\n        elif should_disable:\n            self._disable_breakpoint(ip_breakpoint)\n    else:\n        # Step forward\n        self.step(thread)\n        self.wait()\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.peek_memory","title":"<code>peek_memory(address)</code>","text":"<p>Reads the memory at the specified address.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def peek_memory(self: PtraceInterface, address: int) -&gt; int:\n    \"\"\"Reads the memory at the specified address.\"\"\"\n    result = self.lib_trace.ptrace_peekdata(self.process_id, address)\n    liblog.debugger(\n        \"PEEKDATA at address %d returned with result %x\",\n        address,\n        result,\n    )\n\n    error = self.ffi.errno\n    if error:\n        raise OSError(error, errno.errorcode[error])\n\n    return result\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.poke_memory","title":"<code>poke_memory(address, value)</code>","text":"<p>Writes the memory at the specified address.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def poke_memory(self: PtraceInterface, address: int, value: int) -&gt; None:\n    \"\"\"Writes the memory at the specified address.\"\"\"\n    result = self.lib_trace.ptrace_pokedata(self.process_id, address, value)\n    liblog.debugger(\n        \"POKEDATA at address %d returned with result %d\",\n        address,\n        result,\n    )\n\n    if result == -1:\n        error = self.ffi.errno\n        raise OSError(error, errno.errorcode[error])\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.register_new_thread","title":"<code>register_new_thread(new_thread_id)</code>","text":"<p>Registers a new thread.</p> <p>Parameters:</p> Name Type Description Default <code>new_thread_id</code> <code>int</code> <p>The new thread ID.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def register_new_thread(self: PtraceInterface, new_thread_id: int) -&gt; None:\n    \"\"\"Registers a new thread.\n\n    Args:\n        new_thread_id (int): The new thread ID.\n    \"\"\"\n    # The FFI implementation returns a pointer to the register file\n    register_file = self.lib_trace.register_thread(\n        self._global_state,\n        new_thread_id,\n    )\n\n    fp_register_file = self.lib_trace.get_thread_fp_regs(self._global_state, new_thread_id)\n\n    register_holder = register_holder_provider(self._internal_debugger.arch, register_file, fp_register_file)\n\n    with extend_internal_debugger(self._internal_debugger):\n        thread = ThreadContext(new_thread_id, register_holder)\n\n    self._internal_debugger.insert_new_thread(thread)\n\n    # For any hardware breakpoints, we need to reapply them to the new thread\n    for bp in self._internal_debugger.breakpoints.values():\n        if bp.hardware:\n            self.lib_trace.register_hw_breakpoint(\n                self._global_state,\n                new_thread_id,\n                bp.address,\n                bp.condition.encode().ljust(2, b\"\\x00\"),\n                chr(bp.length).encode(),\n            )\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.reset","title":"<code>reset()</code>","text":"<p>Resets the state of the interface.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def reset(self: PtraceInterface) -&gt; None:\n    \"\"\"Resets the state of the interface.\"\"\"\n    self.lib_trace.free_thread_list(self._global_state)\n    self.lib_trace.free_breakpoints(self._global_state)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.run","title":"<code>run(redirect_pipes)</code>","text":"<p>Runs the specified process.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def run(self: PtraceInterface, redirect_pipes: bool) -&gt; None:\n    \"\"\"Runs the specified process.\"\"\"\n    if not self._disabled_aslr and not self._internal_debugger.aslr_enabled:\n        disable_self_aslr()\n        self._disabled_aslr = True\n\n    argv = self._internal_debugger.argv\n    env = self._internal_debugger.env\n\n    liblog.debugger(\"Running %s\", argv)\n\n    # Setup ptrace wait status handler after debugging_context has been properly initialized\n    with extend_internal_debugger(self):\n        self.status_handler = PtraceStatusHandler()\n\n    file_actions = []\n\n    if redirect_pipes:\n        # Creating pipes for stdin, stdout, stderr\n        self.stdin_read, self.stdin_write = os.pipe()\n        self.stdout_read, self.stdout_write = pty.openpty()\n        self.stderr_read, self.stderr_write = pty.openpty()\n\n        # Setting stdout, stderr to raw mode to avoid terminal control codes interfering with the\n        # output\n        tty.setraw(self.stdout_read)\n        tty.setraw(self.stderr_read)\n\n        flags = fcntl(self.stdout_read, F_GETFL)\n        fcntl(self.stdout_read, F_SETFL, flags | os.O_NONBLOCK)\n\n        flags = fcntl(self.stderr_read, F_GETFL)\n        fcntl(self.stderr_read, F_SETFL, flags | os.O_NONBLOCK)\n\n        file_actions.extend(\n            [\n                (POSIX_SPAWN_CLOSE, self.stdin_write),\n                (POSIX_SPAWN_CLOSE, self.stdout_read),\n                (POSIX_SPAWN_CLOSE, self.stderr_read),\n                (POSIX_SPAWN_DUP2, self.stdin_read, 0),\n                (POSIX_SPAWN_DUP2, self.stdout_write, 1),\n                (POSIX_SPAWN_DUP2, self.stderr_write, 2),\n                (POSIX_SPAWN_CLOSE, self.stdin_read),\n                (POSIX_SPAWN_CLOSE, self.stdout_write),\n                (POSIX_SPAWN_CLOSE, self.stderr_write),\n            ]\n        )\n\n    # argv[1] is the length of the custom environment variables\n    # argv[2:2 + env_len] is the custom environment variables\n    # argv[2 + env_len] should be NULL\n    # argv[2 + env_len + 1:] is the new argv\n    if env is None:\n        env_len = -1\n        env = {}\n    else:\n        env_len = len(env)\n\n    argv = [\n        JUMPSTART_LOCATION,\n        str(env_len),\n        *[f\"{key}={value}\" for key, value in env.items()],\n        \"NULL\",\n        *argv,\n    ]\n\n    child_pid = posix_spawn(\n        JUMPSTART_LOCATION,\n        argv,\n        os.environ,\n        file_actions=file_actions,\n        setpgroup=0,\n    )\n\n    self.process_id = child_pid\n    self.detached = False\n    self._internal_debugger.process_id = child_pid\n    self.register_new_thread(child_pid)\n    continue_to_entry_point = self._internal_debugger.autoreach_entrypoint\n    self._setup_parent(continue_to_entry_point)\n\n    if redirect_pipes:\n        self._internal_debugger.pipe_manager = self._setup_pipe()\n    else:\n        self._internal_debugger.pipe_manager = None\n\n        # https://stackoverflow.com/questions/58918188/why-is-stdin-not-propagated-to-child-process-of-different-process-group\n        # We need to set the foreground process group to the child process group, otherwise the child process\n        # will not receive the input from the terminal\n        try:\n            os.tcsetpgrp(0, child_pid)\n        except OSError as e:\n            liblog.debugger(\"Failed to set the foreground process group: %r\", e)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.set_breakpoint","title":"<code>set_breakpoint(bp, insert=True)</code>","text":"<p>Sets a breakpoint at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>bp</code> <code>Breakpoint</code> <p>The breakpoint to set.</p> required <code>insert</code> <code>bool</code> <p>Whether the breakpoint has to be inserted or just enabled.</p> <code>True</code> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def set_breakpoint(self: PtraceInterface, bp: Breakpoint, insert: bool = True) -&gt; None:\n    \"\"\"Sets a breakpoint at the specified address.\n\n    Args:\n        bp (Breakpoint): The breakpoint to set.\n        insert (bool): Whether the breakpoint has to be inserted or just enabled.\n    \"\"\"\n    if bp.hardware:\n        for thread in self._internal_debugger.threads:\n            if bp.condition == \"x\":\n                remaining = self.lib_trace.get_remaining_hw_breakpoint_count(self._global_state, thread.thread_id)\n            else:\n                remaining = self.lib_trace.get_remaining_hw_watchpoint_count(self._global_state, thread.thread_id)\n\n            if not remaining:\n                raise ValueError(\"No more hardware breakpoints of this type available\")\n\n            self.lib_trace.register_hw_breakpoint(\n                self._global_state,\n                thread.thread_id,\n                bp.address,\n                bp.condition.encode().ljust(2, b\"\\x00\"),\n                chr(bp.length).encode(),\n            )\n    elif insert:\n        self._set_sw_breakpoint(bp)\n    else:\n        self._enable_breakpoint(bp)\n\n    if insert:\n        self._internal_debugger.breakpoints[bp.address] = bp\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.set_signal_catcher","title":"<code>set_signal_catcher(catcher)</code>","text":"<p>Sets a catcher for a signal.</p> <p>Parameters:</p> Name Type Description Default <code>catcher</code> <code>CaughtSignal</code> <p>The signal to set.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def set_signal_catcher(self: PtraceInterface, catcher: SignalCatcher) -&gt; None:\n    \"\"\"Sets a catcher for a signal.\n\n    Args:\n        catcher (CaughtSignal): The signal to set.\n    \"\"\"\n    self._internal_debugger.caught_signals[catcher.signal_number] = catcher\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.set_syscall_handler","title":"<code>set_syscall_handler(handler)</code>","text":"<p>Sets a handler for a syscall.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandledSyscall</code> <p>The syscall to set.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def set_syscall_handler(self: PtraceInterface, handler: SyscallHandler) -&gt; None:\n    \"\"\"Sets a handler for a syscall.\n\n    Args:\n        handler (HandledSyscall): The syscall to set.\n    \"\"\"\n    self._internal_debugger.handled_syscalls[handler.syscall_number] = handler\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.step","title":"<code>step(thread)</code>","text":"<p>Executes a single instruction of the process.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def step(self: PtraceInterface, thread: ThreadContext) -&gt; None:\n    \"\"\"Executes a single instruction of the process.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n    \"\"\"\n    # Disable all breakpoints for the single step\n    for bp in self._internal_debugger.breakpoints.values():\n        bp._disabled_for_step = True\n\n    # Reset the event type\n    self._internal_debugger.resume_context.event_type.clear()\n\n    # Reset the breakpoint hit\n    self._internal_debugger.resume_context.event_hit_ref.clear()\n\n    result = self.lib_trace.singlestep(self._global_state, thread.thread_id)\n    if result == -1:\n        errno_val = self.ffi.errno\n        raise OSError(errno_val, errno.errorcode[errno_val])\n\n    self._internal_debugger.resume_context.is_a_step = True\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.step_until","title":"<code>step_until(thread, address, max_steps)</code>","text":"<p>Executes instructions of the specified thread until the specified address is reached.</p> <p>Parameters:</p> Name Type Description Default <code>thread</code> <code>ThreadContext</code> <p>The thread to step.</p> required <code>address</code> <code>int</code> <p>The address to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def step_until(self: PtraceInterface, thread: ThreadContext, address: int, max_steps: int) -&gt; None:\n    \"\"\"Executes instructions of the specified thread until the specified address is reached.\n\n    Args:\n        thread (ThreadContext): The thread to step.\n        address (int): The address to reach.\n        max_steps (int): The maximum number of steps to execute.\n    \"\"\"\n    # Disable all breakpoints for the single step\n    for bp in self._internal_debugger.breakpoints.values():\n        bp._disabled_for_step = True\n\n    # Reset the event type\n    self._internal_debugger.resume_context.event_type.clear()\n\n    # Reset the breakpoint hit\n    self._internal_debugger.resume_context.event_hit_ref.clear()\n\n    result = self.lib_trace.step_until(\n        self._global_state,\n        thread.thread_id,\n        address,\n        max_steps,\n    )\n    if result == -1:\n        errno_val = self.ffi.errno\n        raise OSError(errno_val, errno.errorcode[errno_val])\n\n    # As the wait is done internally, we must invalidate the cache\n    invalidate_process_cache()\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.unregister_thread","title":"<code>unregister_thread(thread_id, exit_code, exit_signal)</code>","text":"<p>Unregisters a thread.</p> <p>Parameters:</p> Name Type Description Default <code>thread_id</code> <code>int</code> <p>The thread ID.</p> required <code>exit_code</code> <code>int</code> <p>The exit code of the thread.</p> required <code>exit_signal</code> <code>int</code> <p>The exit signal of the thread.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def unregister_thread(\n    self: PtraceInterface,\n    thread_id: int,\n    exit_code: int | None,\n    exit_signal: int | None,\n) -&gt; None:\n    \"\"\"Unregisters a thread.\n\n    Args:\n        thread_id (int): The thread ID.\n        exit_code (int): The exit code of the thread.\n        exit_signal (int): The exit signal of the thread.\n    \"\"\"\n    self.lib_trace.unregister_thread(self._global_state, thread_id)\n\n    self._internal_debugger.set_thread_as_dead(thread_id, exit_code=exit_code, exit_signal=exit_signal)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.unset_breakpoint","title":"<code>unset_breakpoint(bp, delete=True)</code>","text":"<p>Restores the breakpoint at the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>bp</code> <code>Breakpoint</code> <p>The breakpoint to unset.</p> required <code>delete</code> <code>bool</code> <p>Whether the breakpoint has to be deleted or just disabled.</p> <code>True</code> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def unset_breakpoint(self: PtraceInterface, bp: Breakpoint, delete: bool = True) -&gt; None:\n    \"\"\"Restores the breakpoint at the specified address.\n\n    Args:\n        bp (Breakpoint): The breakpoint to unset.\n        delete (bool): Whether the breakpoint has to be deleted or just disabled.\n    \"\"\"\n    if bp.hardware:\n        for thread in self._internal_debugger.threads:\n            self.lib_trace.unregister_hw_breakpoint(\n                self._global_state,\n                thread.thread_id,\n                bp.address,\n            )\n    elif delete:\n        self._unset_sw_breakpoint(bp)\n    else:\n        self._disable_breakpoint(bp)\n\n    if delete:\n        del self._internal_debugger.breakpoints[bp.address]\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.unset_signal_catcher","title":"<code>unset_signal_catcher(catcher)</code>","text":"<p>Unset a catcher for a signal.</p> <p>Parameters:</p> Name Type Description Default <code>catcher</code> <code>CaughtSignal</code> <p>The signal to unset.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def unset_signal_catcher(self: PtraceInterface, catcher: SignalCatcher) -&gt; None:\n    \"\"\"Unset a catcher for a signal.\n\n    Args:\n        catcher (CaughtSignal): The signal to unset.\n    \"\"\"\n    del self._internal_debugger.caught_signals[catcher.signal_number]\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.unset_syscall_handler","title":"<code>unset_syscall_handler(handler)</code>","text":"<p>Unsets a handler for a syscall.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>HandledSyscall</code> <p>The syscall to unset.</p> required Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def unset_syscall_handler(self: PtraceInterface, handler: SyscallHandler) -&gt; None:\n    \"\"\"Unsets a handler for a syscall.\n\n    Args:\n        handler (HandledSyscall): The syscall to unset.\n    \"\"\"\n    del self._internal_debugger.handled_syscalls[handler.syscall_number]\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_interface/#libdebug.ptrace.ptrace_interface.PtraceInterface.wait","title":"<code>wait()</code>","text":"<p>Waits for the process to stop. Returns True if the wait has to be repeated.</p> Source code in <code>libdebug/ptrace/ptrace_interface.py</code> <pre><code>def wait(self: PtraceInterface) -&gt; None:\n    \"\"\"Waits for the process to stop. Returns True if the wait has to be repeated.\"\"\"\n    result = self.lib_trace.wait_all_and_update_regs(\n        self._global_state,\n        self.process_id,\n    )\n\n    cursor = result\n\n    invalidate_process_cache()\n\n    results = []\n\n    while cursor != self.ffi.NULL:\n        results.append((cursor.tid, cursor.status))\n        cursor = cursor.next\n\n    # Check the result of the waitpid and handle the changes.\n    self.status_handler.manage_change(results)\n\n    self.lib_trace.free_thread_status_list(result)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/","title":"libdebug.ptrace.ptrace_register_holder","text":""},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder","title":"<code>PtraceRegisterHolder</code>  <code>dataclass</code>","text":"<p>               Bases: <code>RegisterHolder</code></p> <p>An abstract class that holds the state of the registers of a process, providing setters and getters for them.</p> <p>Intended for use with the Ptrace debugging backend.</p> Source code in <code>libdebug/ptrace/ptrace_register_holder.py</code> <pre><code>@dataclass\nclass PtraceRegisterHolder(RegisterHolder):\n    \"\"\"An abstract class that holds the state of the registers of a process, providing setters and getters for them.\n\n    Intended for use with the Ptrace debugging backend.\n    \"\"\"\n\n    register_file: object\n    \"\"\"The register file of the target process, as returned by ptrace.\"\"\"\n\n    fp_register_file: object\n    \"\"\"The floating-point register file of the target process, as returned by ptrace.\"\"\"\n\n    def poll(self: PtraceRegisterHolder, target: ThreadContext) -&gt; None:\n        \"\"\"Poll the register values from the specified target.\"\"\"\n        raise NotImplementedError(\"Do not call this method.\")\n\n    def flush(self: PtraceRegisterHolder, source: ThreadContext) -&gt; None:\n        \"\"\"Flush the register values from the specified source.\"\"\"\n        raise NotImplementedError(\"Do not call this method.\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder.fp_register_file","title":"<code>fp_register_file: object</code>  <code>instance-attribute</code>","text":"<p>The floating-point register file of the target process, as returned by ptrace.</p>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder.register_file","title":"<code>register_file: object</code>  <code>instance-attribute</code>","text":"<p>The register file of the target process, as returned by ptrace.</p>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder.flush","title":"<code>flush(source)</code>","text":"<p>Flush the register values from the specified source.</p> Source code in <code>libdebug/ptrace/ptrace_register_holder.py</code> <pre><code>def flush(self: PtraceRegisterHolder, source: ThreadContext) -&gt; None:\n    \"\"\"Flush the register values from the specified source.\"\"\"\n    raise NotImplementedError(\"Do not call this method.\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_register_holder/#libdebug.ptrace.ptrace_register_holder.PtraceRegisterHolder.poll","title":"<code>poll(target)</code>","text":"<p>Poll the register values from the specified target.</p> Source code in <code>libdebug/ptrace/ptrace_register_holder.py</code> <pre><code>def poll(self: PtraceRegisterHolder, target: ThreadContext) -&gt; None:\n    \"\"\"Poll the register values from the specified target.\"\"\"\n    raise NotImplementedError(\"Do not call this method.\")\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/","title":"libdebug.ptrace.ptrace_status_handler","text":""},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/#libdebug.ptrace.ptrace_status_handler.PtraceStatusHandler","title":"<code>PtraceStatusHandler</code>","text":"<p>This class handles the states return by the waitpid calls on the debugger process.</p> Source code in <code>libdebug/ptrace/ptrace_status_handler.py</code> <pre><code>class PtraceStatusHandler:\n    \"\"\"This class handles the states return by the waitpid calls on the debugger process.\"\"\"\n\n    def __init__(self: PtraceStatusHandler) -&gt; None:\n        \"\"\"Initializes the PtraceStatusHandler class.\"\"\"\n        self.internal_debugger = provide_internal_debugger(self)\n        self.ptrace_interface: DebuggingInterface = self.internal_debugger.debugging_interface\n        self.forward_signal: bool = True\n        self._assume_race_sigstop: bool = (\n            True  # Assume the stop is due to a race condition with SIGSTOP sent by the debugger\n        )\n\n    def _handle_clone(self: PtraceStatusHandler, thread_id: int, results: list) -&gt; None:\n        # https://go.googlesource.com/debug/+/a09ead70f05c87ad67bd9a131ff8352cf39a6082/doc/ptrace-nptl.txt\n        # \"At this time, the new thread will exist, but will initially\n        # be stopped with a SIGSTOP.  The new thread will automatically be\n        # traced and will inherit the PTRACE_O_TRACECLONE option from its\n        # parent.  The attached process should wait on the new thread to receive\n        # the SIGSTOP notification.\"\n\n        # Check if we received the SIGSTOP notification for the new thread\n        # If not, we need to wait for it\n        # 4991 == (WIFSTOPPED &amp;&amp; WSTOPSIG(status) == SIGSTOP)\n        if (thread_id, 4991) not in results:\n            os.waitpid(thread_id, 0)\n        self.ptrace_interface.register_new_thread(thread_id)\n\n    def _handle_exit(\n        self: PtraceStatusHandler,\n        thread_id: int,\n        exit_code: int | None,\n        exit_signal: int | None,\n    ) -&gt; None:\n        if self.internal_debugger.get_thread_by_id(thread_id):\n            self.ptrace_interface.unregister_thread(thread_id, exit_code=exit_code, exit_signal=exit_signal)\n\n    def _handle_breakpoints(self: PtraceStatusHandler, thread_id: int) -&gt; bool:\n        thread = self.internal_debugger.get_thread_by_id(thread_id)\n\n        if not hasattr(thread, \"instruction_pointer\"):\n            # This is a signal trap hit on process startup\n            # Do not resume the process until the user decides to do so\n            self.internal_debugger.resume_context.event_type[thread_id] = EventType.STARTUP\n            self.internal_debugger.resume_context.resume = False\n            self.forward_signal = False\n            return\n\n        ip = thread.instruction_pointer\n\n        bp: None | Breakpoint\n\n        bp = self.internal_debugger.breakpoints.get(ip)\n        if bp and bp.enabled and not bp._disabled_for_step:\n            # Hardware breakpoint hit\n            liblog.debugger(\"Hardware breakpoint hit at 0x%x\", ip)\n        else:\n            # If the trap was caused by a software breakpoint, we need to restore the original instruction\n            # and set the instruction pointer to the previous instruction.\n            ip -= software_breakpoint_byte_size(self.internal_debugger.arch)\n\n            bp = self.internal_debugger.breakpoints.get(ip)\n            if bp and bp.enabled and not bp._disabled_for_step:\n                # Software breakpoint hit\n                liblog.debugger(\"Software breakpoint hit at 0x%x\", ip)\n\n                # Set the instruction pointer to the previous instruction\n                thread.instruction_pointer = ip\n\n                # Link the breakpoint to the thread, so that we can step over it\n                bp._linked_thread_ids.append(thread_id)\n            else:\n                # If the breakpoint has been hit but is not enabled, we need to reset the bp variable\n                bp = None\n\n        # Manage watchpoints\n        if not bp:\n            bp = self.ptrace_interface.get_hit_watchpoint(thread_id)\n            if bp:\n                liblog.debugger(\"Watchpoint hit at 0x%x\", bp.address)\n\n        if bp:\n            self.internal_debugger.resume_context.event_hit_ref[thread_id] = bp\n            self.forward_signal = False\n            bp.hit_count += 1\n\n            if bp.callback:\n                bp.callback(thread, bp)\n            else:\n                # If the breakpoint has no callback, we need to stop the process despite the other signals\n                self.internal_debugger.resume_context.event_type[thread_id] = EventType.BREAKPOINT\n                self.internal_debugger.resume_context.resume = False\n\n    def _manage_syscall_on_enter(\n        self: PtraceStatusHandler,\n        handler: SyscallHandler,\n        thread: ThreadContext,\n        syscall_number: int,\n        hijacked_set: set[int],\n    ) -&gt; None:\n        \"\"\"Manage the on_enter callback of a syscall.\"\"\"\n        # Call the user-defined callback if it exists\n        if handler.on_enter_user and handler.enabled:\n            old_args = [\n                thread.syscall_arg0,\n                thread.syscall_arg1,\n                thread.syscall_arg2,\n                thread.syscall_arg3,\n                thread.syscall_arg4,\n                thread.syscall_arg5,\n            ]\n            handler.on_enter_user(thread, handler)\n\n            # Check if the syscall number has changed\n            syscall_number_after_callback = thread.syscall_number\n\n            if syscall_number_after_callback != syscall_number:\n                # The syscall number has changed\n                # Pretty print the syscall number before the callback\n                if handler.on_enter_pprint:\n                    handler.on_enter_pprint(\n                        thread,\n                        syscall_number,\n                        hijacked=True,\n                        old_args=old_args,\n                    )\n                if syscall_number_after_callback in self.internal_debugger.handled_syscalls:\n                    callback_hijack = self.internal_debugger.handled_syscalls[syscall_number_after_callback]\n\n                    # Check if the new syscall has to be handled recursively\n                    if handler.recursive:\n                        if syscall_number_after_callback not in hijacked_set:\n                            hijacked_set.add(syscall_number_after_callback)\n                        else:\n                            # The syscall has already been hijacked in the current chain\n                            raise RuntimeError(\n                                \"Syscall hijacking loop detected. Check your code to avoid infinite loops.\",\n                            )\n\n                        # Call recursively the function to manage the new syscall\n                        self._manage_syscall_on_enter(\n                            callback_hijack,\n                            thread,\n                            syscall_number_after_callback,\n                            hijacked_set,\n                        )\n                    elif callback_hijack.on_enter_pprint:\n                        # Pretty print the syscall number\n                        callback_hijack.on_enter_pprint(thread, syscall_number_after_callback, hijacker=True)\n                        callback_hijack._has_entered = True\n                        callback_hijack._skip_exit = True\n                    else:\n                        # Skip the exit callback of the syscall that has been hijacked\n                        callback_hijack._has_entered = True\n                        callback_hijack._skip_exit = True\n            elif handler.on_enter_pprint:\n                # Pretty print the syscall number\n                handler.on_enter_pprint(thread, syscall_number, callback=True, old_args=old_args)\n                handler._has_entered = True\n            else:\n                handler._has_entered = True\n        elif handler.on_enter_pprint:\n            # Pretty print the syscall number\n            handler.on_enter_pprint(thread, syscall_number, callback=(handler.on_exit_user is not None))\n            handler._has_entered = True\n        elif handler.on_exit_pprint or handler.on_exit_user:\n            # The syscall has been entered but the user did not define an on_enter callback\n            handler._has_entered = True\n        if not handler.on_enter_user and not handler.on_exit_user and handler.enabled:\n            # If the syscall has no callback, we need to stop the process despite the other signals\n            self.internal_debugger.resume_context.event_type[thread.thread_id] = EventType.SYSCALL\n            handler._has_entered = True\n            self.internal_debugger.resume_context.resume = False\n\n    def _handle_syscall(self: PtraceStatusHandler, thread_id: int) -&gt; bool:\n        \"\"\"Handle a syscall trap.\"\"\"\n        thread = self.internal_debugger.get_thread_by_id(thread_id)\n        if not hasattr(thread, \"syscall_number\"):\n            # This is another spurious trap, we don't know what to do with it\n            return\n\n        syscall_number = thread.syscall_number\n\n        if syscall_number in self.internal_debugger.handled_syscalls:\n            handler = self.internal_debugger.handled_syscalls[syscall_number]\n        elif -1 in self.internal_debugger.handled_syscalls:\n            # Handle all syscalls is enabled\n            handler = self.internal_debugger.handled_syscalls[-1]\n        else:\n            # This is a syscall we don't care about\n            # Resume the execution\n            return\n\n        self.internal_debugger.resume_context.event_hit_ref[thread_id] = handler\n\n        if not handler._has_entered:\n            # The syscall is being entered\n            liblog.debugger(\n                \"Syscall %d entered on thread %d\",\n                syscall_number,\n                thread_id,\n            )\n\n            self._manage_syscall_on_enter(\n                handler,\n                thread,\n                syscall_number,\n                {syscall_number},\n            )\n\n        else:\n            # The syscall is being exited\n            liblog.debugger(\"Syscall %d exited on thread %d\", syscall_number, thread_id)\n\n            if handler.enabled and not handler._skip_exit:\n                # Increment the hit count only if the syscall has been handled\n                handler.hit_count += 1\n\n            # Call the user-defined callback if it exists\n            if handler.on_exit_user and handler.enabled and not handler._skip_exit:\n                # Pretty print the return value before the callback\n                if handler.on_exit_pprint:\n                    return_value_before_callback = thread.syscall_return\n                handler.on_exit_user(thread, handler)\n                if handler.on_exit_pprint:\n                    return_value_after_callback = thread.syscall_return\n                    if return_value_after_callback != return_value_before_callback:\n                        handler.on_exit_pprint(\n                            (return_value_before_callback, return_value_after_callback),\n                        )\n                    else:\n                        handler.on_exit_pprint(return_value_after_callback)\n            elif handler.on_exit_pprint:\n                # Pretty print the return value\n                handler.on_exit_pprint(thread.syscall_return)\n\n            handler._has_entered = False\n            handler._skip_exit = False\n            if not handler.on_enter_user and not handler.on_exit_user and handler.enabled:\n                # If the syscall has no callback, we need to stop the process despite the other signals\n                self.internal_debugger.resume_context.event_type[thread_id] = EventType.SYSCALL\n                self.internal_debugger.resume_context.resume = False\n\n    def _manage_caught_signal(\n        self: PtraceStatusHandler,\n        catcher: SignalCatcher,\n        thread: ThreadContext,\n        signal_number: int,\n        hijacked_set: set[int],\n    ) -&gt; None:\n        if catcher.enabled:\n            catcher.hit_count += 1\n            liblog.debugger(\n                \"Caught signal %s (%d) hit on thread %d\",\n                resolve_signal_name(signal_number),\n                signal_number,\n                thread.thread_id,\n            )\n            if catcher.callback:\n                # Execute the user-defined callback\n                catcher.callback(thread, catcher)\n\n                new_signal_number = thread._signal_number\n\n                if new_signal_number != signal_number:\n                    # The signal number has changed\n                    liblog.debugger(\n                        \"Signal %s (%d) has been hijacked to %s (%d)\",\n                        resolve_signal_name(signal_number),\n                        signal_number,\n                        resolve_signal_name(new_signal_number),\n                        new_signal_number,\n                    )\n\n                    if catcher.recursive and new_signal_number in self.internal_debugger.caught_signals:\n                        hijack_cath_signal = self.internal_debugger.caught_signals[new_signal_number]\n                        if new_signal_number not in hijacked_set:\n                            hijacked_set.add(new_signal_number)\n                        else:\n                            # The signal has already been replaced in the current chain\n                            raise RuntimeError(\n                                \"Signal hijacking loop detected. Check your script to avoid infinite loops.\",\n                            )\n                        # Call recursively the function to manage the new signal\n                        self._manage_caught_signal(\n                            hijack_cath_signal,\n                            thread,\n                            new_signal_number,\n                            hijacked_set,\n                        )\n            else:\n                # If the caught signal has no callback, we need to stop the process despite the other signals\n                self.internal_debugger.resume_context.event = EventType.SIGNAL\n                self.internal_debugger.resume_context.resume = False\n\n    def _handle_signal(self: PtraceStatusHandler, thread: ThreadContext) -&gt; bool:\n        \"\"\"Handle the signal trap.\"\"\"\n        signal_number = thread._signal_number\n\n        if signal_number in self.internal_debugger.caught_signals:\n            catcher = self.internal_debugger.caught_signals[signal_number]\n\n            self._manage_caught_signal(catcher, thread, signal_number, {signal_number})\n        elif -1 in self.internal_debugger.caught_signals and signal_number not in (\n            signal.SIGSTOP,\n            signal.SIGTRAP,\n            signal.SIGKILL,\n        ):\n            # Handle all signals is enabled\n            catcher = self.internal_debugger.caught_signals[-1]\n\n            self.internal_debugger.resume_context.event_hit_ref[thread.thread_id] = catcher\n\n            self._manage_caught_signal(catcher, thread, signal_number, {signal_number})\n\n    def _internal_signal_handler(\n        self: PtraceStatusHandler,\n        pid: int,\n        signum: int,\n        results: list,\n        status: int,\n    ) -&gt; None:\n        \"\"\"Internal handler for signals used by the debugger.\"\"\"\n        if signum == SYSCALL_SIGTRAP:\n            # We hit a syscall\n            liblog.debugger(\"Child thread %d stopped on syscall\", pid)\n            self._handle_syscall(pid)\n            self.forward_signal = False\n        elif signum == signal.SIGSTOP and self.internal_debugger.resume_context.force_interrupt:\n            # The user has requested an interrupt, we need to stop the process despite the ohter signals\n            liblog.debugger(\n                \"Child thread %d stopped with signal %s\",\n                pid,\n                resolve_signal_name(signum),\n            )\n            self.internal_debugger.resume_context.event_type[pid] = EventType.USER_INTERRUPT\n            self.internal_debugger.resume_context.resume = False\n            self.internal_debugger.resume_context.force_interrupt = False\n            self.forward_signal = False\n        elif signum == signal.SIGTRAP:\n            # The trap decides if we hit a breakpoint. If so, it decides whether we should stop or\n            # continue the execution and wait for the next trap\n            self._handle_breakpoints(pid)\n\n            if self.internal_debugger.resume_context.is_a_step:\n                # The process is stepping, we need to stop the execution\n                self.internal_debugger.resume_context.event_type[pid] = EventType.STEP\n                self.internal_debugger.resume_context.resume = False\n                self.internal_debugger.resume_context.is_a_step = False\n                self.forward_signal = False\n\n            event = status &gt;&gt; 8\n            match event:\n                case StopEvents.CLONE_EVENT:\n                    # The process has been cloned\n                    message = self.ptrace_interface._get_event_msg(pid)\n                    liblog.debugger(\n                        f\"Process {pid} cloned, new thread_id: {message}\",\n                    )\n                    self._handle_clone(message, results)\n                    self.forward_signal = False\n                case StopEvents.SECCOMP_EVENT:\n                    # The process has installed a seccomp\n                    liblog.debugger(f\"Process {pid} installed a seccomp\")\n                    self.forward_signal = False\n                case StopEvents.EXIT_EVENT:\n                    # The tracee is still alive; it needs\n                    # to be PTRACE_CONTed or PTRACE_DETACHed to finish exiting.\n                    # so we don't call self._handle_exit(pid) here\n                    # it will be called at the next wait (hopefully)\n                    message = self.ptrace_interface._get_event_msg(pid)\n                    liblog.debugger(\n                        f\"Thread {pid} exited with status: {message}\",\n                    )\n                    self.forward_signal = False\n                case StopEvents.FORK_EVENT:\n                    # The process has been forked\n                    liblog.warning(\n                        f\"Process {pid} forked. Continuing execution of the parent process. The child process will be stopped until the user decides to attach to it.\",\n                    )\n                    self.forward_signal = False\n\n    def _handle_change(self: PtraceStatusHandler, pid: int, status: int, results: list) -&gt; None:\n        \"\"\"Handle a change in the status of a traced process.\"\"\"\n        # Initialize the forward_signal flag\n        self.forward_signal = True\n\n        if os.WIFSTOPPED(status):\n            if self.internal_debugger.resume_context.is_startup:\n                # The process has just started\n                return\n            signum = os.WSTOPSIG(status)\n\n            if signum != signal.SIGSTOP:\n                self._assume_race_sigstop = False\n\n            # Check if the debugger needs to handle the signal\n            self._internal_signal_handler(pid, signum, results, status)\n\n            thread = self.internal_debugger.get_thread_by_id(pid)\n\n            if thread is not None:\n                thread._signal_number = signum\n\n                # Handle the signal\n                self._handle_signal(thread)\n\n                if self.forward_signal and signum != signal.SIGSTOP:\n                    # We have to forward the signal to the thread\n                    self.internal_debugger.resume_context.threads_with_signals_to_forward.append(pid)\n\n        if os.WIFEXITED(status):\n            # The thread has exited normally\n            exit_code = os.WEXITSTATUS(status)\n            liblog.debugger(\"Child process %d exited with exit code %d\", pid, exit_code)\n            self._handle_exit(pid, exit_code=exit_code, exit_signal=None)\n\n        if os.WIFSIGNALED(status):\n            # The thread has exited with a signal\n            exit_signal = os.WTERMSIG(status)\n            liblog.debugger(\"Child process %d exited with signal %d\", pid, exit_signal)\n            self._handle_exit(pid, exit_code=None, exit_signal=exit_signal)\n\n    def manage_change(self: PtraceStatusHandler, result: list[tuple]) -&gt; None:\n        \"\"\"Manage the result of the waitpid and handle the changes.\"\"\"\n        # Assume that the stop depends on SIGSTOP sent by the debugger\n        # This is a workaround for some race conditions that may happen\n        self._assume_race_sigstop = True\n\n        for pid, status in result:\n            if pid != -1:\n                # Otherwise, this is a spurious trap\n                self._handle_change(pid, status, result)\n\n        if self._assume_race_sigstop:\n            # Resume the process if the stop was due to a race condition with SIGSTOP sent by the debugger\n            return\n\n    def check_for_new_threads(self: PtraceStatusHandler, pid: int) -&gt; None:\n        \"\"\"Check for new threads in the process and register them.\"\"\"\n        tids = get_process_tasks(pid)\n        for tid in tids:\n            if not self.internal_debugger.get_thread_by_id(tid):\n                self.ptrace_interface.register_new_thread(tid, self.internal_debugger)\n                liblog.debugger(\"Manually registered new thread %d\" % tid)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/#libdebug.ptrace.ptrace_status_handler.PtraceStatusHandler.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the PtraceStatusHandler class.</p> Source code in <code>libdebug/ptrace/ptrace_status_handler.py</code> <pre><code>def __init__(self: PtraceStatusHandler) -&gt; None:\n    \"\"\"Initializes the PtraceStatusHandler class.\"\"\"\n    self.internal_debugger = provide_internal_debugger(self)\n    self.ptrace_interface: DebuggingInterface = self.internal_debugger.debugging_interface\n    self.forward_signal: bool = True\n    self._assume_race_sigstop: bool = (\n        True  # Assume the stop is due to a race condition with SIGSTOP sent by the debugger\n    )\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/#libdebug.ptrace.ptrace_status_handler.PtraceStatusHandler.check_for_new_threads","title":"<code>check_for_new_threads(pid)</code>","text":"<p>Check for new threads in the process and register them.</p> Source code in <code>libdebug/ptrace/ptrace_status_handler.py</code> <pre><code>def check_for_new_threads(self: PtraceStatusHandler, pid: int) -&gt; None:\n    \"\"\"Check for new threads in the process and register them.\"\"\"\n    tids = get_process_tasks(pid)\n    for tid in tids:\n        if not self.internal_debugger.get_thread_by_id(tid):\n            self.ptrace_interface.register_new_thread(tid, self.internal_debugger)\n            liblog.debugger(\"Manually registered new thread %d\" % tid)\n</code></pre>"},{"location":"from_pydoc/generated/ptrace/ptrace_status_handler/#libdebug.ptrace.ptrace_status_handler.PtraceStatusHandler.manage_change","title":"<code>manage_change(result)</code>","text":"<p>Manage the result of the waitpid and handle the changes.</p> Source code in <code>libdebug/ptrace/ptrace_status_handler.py</code> <pre><code>def manage_change(self: PtraceStatusHandler, result: list[tuple]) -&gt; None:\n    \"\"\"Manage the result of the waitpid and handle the changes.\"\"\"\n    # Assume that the stop depends on SIGSTOP sent by the debugger\n    # This is a workaround for some race conditions that may happen\n    self._assume_race_sigstop = True\n\n    for pid, status in result:\n        if pid != -1:\n            # Otherwise, this is a spurious trap\n            self._handle_change(pid, status, result)\n\n    if self._assume_race_sigstop:\n        # Resume the process if the stop was due to a race condition with SIGSTOP sent by the debugger\n        return\n</code></pre>"},{"location":"from_pydoc/generated/state/resume_context/","title":"libdebug.state.resume_context","text":""},{"location":"from_pydoc/generated/state/resume_context/#libdebug.state.resume_context.EventType","title":"<code>EventType</code>","text":"<p>A class representing the type of event that caused the resume decision.</p> Source code in <code>libdebug/state/resume_context.py</code> <pre><code>class EventType:\n    \"\"\"A class representing the type of event that caused the resume decision.\"\"\"\n\n    UNKNOWN = \"Unknown Event\"\n    BREAKPOINT = \"Breakpoint\"\n    SYSCALL = \"Syscall\"\n    SIGNAL = \"Signal\"\n    USER_INTERRUPT = \"User Interrupt\"\n    STEP = \"Step\"\n    STARTUP = \"Process Startup\"\n</code></pre>"},{"location":"from_pydoc/generated/state/resume_context/#libdebug.state.resume_context.ResumeContext","title":"<code>ResumeContext</code>","text":"<p>A class representing the context of the resume decision.</p> Source code in <code>libdebug/state/resume_context.py</code> <pre><code>class ResumeContext:\n    \"\"\"A class representing the context of the resume decision.\"\"\"\n\n    def __init__(self: ResumeContext) -&gt; None:\n        \"\"\"Initializes the ResumeContext.\"\"\"\n        self.resume: bool = True\n        self.force_interrupt: bool = False\n        self.is_a_step: bool = False\n        self.is_startup: bool = False\n        self.block_on_signal: bool = False\n        self.threads_with_signals_to_forward: list[int] = []\n        self.event_type: dict[int, EventType] = {}\n        self.event_hit_ref: dict[int, Breakpoint] = {}\n\n    def clear(self: ResumeContext) -&gt; None:\n        \"\"\"Clears the context.\"\"\"\n        self.resume = True\n        self.force_interrupt = False\n        self.is_a_step = False\n        self.is_startup = False\n        self.block_on_signal = False\n        self.threads_with_signals_to_forward.clear()\n        self.event_type.clear()\n        self.event_hit_ref.clear()\n\n    def get_event_type(self: ResumeContext) -&gt; str:\n        \"\"\"Returns the event type to be printed.\"\"\"\n        event_str = \"\"\n        if self.event_type:\n            for tid, event in self.event_type.items():\n                if event == EventType.BREAKPOINT:\n                    hit_ref = self.event_hit_ref[tid]\n                    if hit_ref.condition != \"x\":\n                        event_str += (\n                            f\"Watchpoint at {hit_ref.address:#x} with condition {hit_ref.condition} on thread {tid}.\"\n                        )\n                    else:\n                        event_str += f\"Breakpoint at {hit_ref.address:#x} on thread {tid}.\"\n                elif event == EventType.SYSCALL:\n                    hit_ref = self.event_hit_ref[tid]\n                    event_str += f\"Syscall {hit_ref.syscall_number} on thread {tid}.\"\n                elif event == EventType.SIGNAL:\n                    hit_ref = self.event_hit_ref[tid]\n                    event_str += f\"Signal {hit_ref.signal} on thread {tid}.\"\n                else:\n                    event_str += f\"{event} on thread {tid}.\"\n\n        return event_str\n</code></pre>"},{"location":"from_pydoc/generated/state/resume_context/#libdebug.state.resume_context.ResumeContext.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the ResumeContext.</p> Source code in <code>libdebug/state/resume_context.py</code> <pre><code>def __init__(self: ResumeContext) -&gt; None:\n    \"\"\"Initializes the ResumeContext.\"\"\"\n    self.resume: bool = True\n    self.force_interrupt: bool = False\n    self.is_a_step: bool = False\n    self.is_startup: bool = False\n    self.block_on_signal: bool = False\n    self.threads_with_signals_to_forward: list[int] = []\n    self.event_type: dict[int, EventType] = {}\n    self.event_hit_ref: dict[int, Breakpoint] = {}\n</code></pre>"},{"location":"from_pydoc/generated/state/resume_context/#libdebug.state.resume_context.ResumeContext.clear","title":"<code>clear()</code>","text":"<p>Clears the context.</p> Source code in <code>libdebug/state/resume_context.py</code> <pre><code>def clear(self: ResumeContext) -&gt; None:\n    \"\"\"Clears the context.\"\"\"\n    self.resume = True\n    self.force_interrupt = False\n    self.is_a_step = False\n    self.is_startup = False\n    self.block_on_signal = False\n    self.threads_with_signals_to_forward.clear()\n    self.event_type.clear()\n    self.event_hit_ref.clear()\n</code></pre>"},{"location":"from_pydoc/generated/state/resume_context/#libdebug.state.resume_context.ResumeContext.get_event_type","title":"<code>get_event_type()</code>","text":"<p>Returns the event type to be printed.</p> Source code in <code>libdebug/state/resume_context.py</code> <pre><code>def get_event_type(self: ResumeContext) -&gt; str:\n    \"\"\"Returns the event type to be printed.\"\"\"\n    event_str = \"\"\n    if self.event_type:\n        for tid, event in self.event_type.items():\n            if event == EventType.BREAKPOINT:\n                hit_ref = self.event_hit_ref[tid]\n                if hit_ref.condition != \"x\":\n                    event_str += (\n                        f\"Watchpoint at {hit_ref.address:#x} with condition {hit_ref.condition} on thread {tid}.\"\n                    )\n                else:\n                    event_str += f\"Breakpoint at {hit_ref.address:#x} on thread {tid}.\"\n            elif event == EventType.SYSCALL:\n                hit_ref = self.event_hit_ref[tid]\n                event_str += f\"Syscall {hit_ref.syscall_number} on thread {tid}.\"\n            elif event == EventType.SIGNAL:\n                hit_ref = self.event_hit_ref[tid]\n                event_str += f\"Signal {hit_ref.signal} on thread {tid}.\"\n            else:\n                event_str += f\"{event} on thread {tid}.\"\n\n    return event_str\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/","title":"libdebug.state.thread_context","text":""},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext","title":"<code>ThreadContext</code>","text":"<p>This object represents a thread in the context of the target process. It holds information about the thread's state, registers and stack.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>class ThreadContext:\n    \"\"\"This object represents a thread in the context of the target process. It holds information about the thread's state, registers and stack.\"\"\"\n\n    instruction_pointer: int\n    \"\"\"The thread's instruction pointer.\"\"\"\n\n    syscall_arg0: int\n    \"\"\"The thread's syscall argument 0.\"\"\"\n\n    syscall_arg1: int\n    \"\"\"The thread's syscall argument 1.\"\"\"\n\n    syscall_arg2: int\n    \"\"\"The thread's syscall argument 2.\"\"\"\n\n    syscall_arg3: int\n    \"\"\"The thread's syscall argument 3.\"\"\"\n\n    syscall_arg4: int\n    \"\"\"The thread's syscall argument 4.\"\"\"\n\n    syscall_arg5: int\n    \"\"\"The thread's syscall argument 5.\"\"\"\n\n    syscall_number: int\n    \"\"\"The thread's syscall number.\"\"\"\n\n    syscall_return: int\n    \"\"\"The thread's syscall return value.\"\"\"\n\n    regs: Registers\n    \"\"\"The thread's registers.\"\"\"\n\n    _internal_debugger: InternalDebugger | None = None\n    \"\"\"The debugging context this thread belongs to.\"\"\"\n\n    _register_holder: RegisterHolder | None = None\n    \"\"\"The register holder object.\"\"\"\n\n    _dead: bool = False\n    \"\"\"Whether the thread is dead.\"\"\"\n\n    _exit_code: int | None = None\n    \"\"\"The thread's exit code.\"\"\"\n\n    _exit_signal: int | None = None\n    \"\"\"The thread's exit signal.\"\"\"\n\n    _signal_number: int = 0\n    \"\"\"The signal to forward to the thread.\"\"\"\n\n    _thread_id: int\n    \"\"\"The thread's ID.\"\"\"\n\n    def __init__(self: ThreadContext, thread_id: int, registers: RegisterHolder) -&gt; None:\n        \"\"\"Initializes the Thread Context.\"\"\"\n        self._internal_debugger = provide_internal_debugger(self)\n        self._thread_id = thread_id\n        self._register_holder = registers\n        regs_class = self._register_holder.provide_regs_class()\n        self.regs = regs_class(thread_id, self._register_holder.provide_regs())\n        self._register_holder.apply_on_regs(self.regs, regs_class)\n        self._register_holder.apply_on_thread(self, ThreadContext)\n\n    def set_as_dead(self: ThreadContext) -&gt; None:\n        \"\"\"Set the thread as dead.\"\"\"\n        self._dead = True\n\n    @property\n    def debugger(self: ThreadContext) -&gt; Debugger:\n        \"\"\"The debugging context this thread belongs to.\"\"\"\n        return self._internal_debugger.debugger\n\n    @property\n    def dead(self: ThreadContext) -&gt; bool:\n        \"\"\"Whether the thread is dead.\"\"\"\n        return self._dead\n\n    @property\n    def memory(self: ThreadContext) -&gt; AbstractMemoryView:\n        \"\"\"The memory view of the debugged process.\"\"\"\n        return self._internal_debugger.memory\n\n    @property\n    def mem(self: ThreadContext) -&gt; AbstractMemoryView:\n        \"\"\"Alias for the `memory` property.\n\n        Get the memory view of the process.\n        \"\"\"\n        return self._internal_debugger.memory\n\n    @property\n    def process_id(self: ThreadContext) -&gt; int:\n        \"\"\"The process ID.\"\"\"\n        return self._internal_debugger.process_id\n\n    @property\n    def pid(self: ThreadContext) -&gt; int:\n        \"\"\"Alias for `process_id` property.\n\n        The process ID.\n        \"\"\"\n        return self._internal_debugger.process_id\n\n    @property\n    def thread_id(self: ThreadContext) -&gt; int:\n        \"\"\"The thread ID.\"\"\"\n        return self._thread_id\n\n    @property\n    def tid(self: ThreadContext) -&gt; int:\n        \"\"\"The thread ID.\"\"\"\n        return self._thread_id\n\n    @property\n    def running(self: ThreadContext) -&gt; bool:\n        \"\"\"Whether the process is running.\"\"\"\n        return self._internal_debugger.running\n\n    @property\n    def saved_ip(self: ThreadContext) -&gt; int:\n        \"\"\"The return address of the current function.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n\n        try:\n            return_address = stack_unwinder.get_return_address(self, self._internal_debugger.maps)\n        except (OSError, ValueError) as e:\n            raise ValueError(\n                \"Failed to get the return address. Check stack frame registers (e.g., base pointer).\",\n            ) from e\n\n        return return_address\n\n    @property\n    def exit_code(self: ThreadContext) -&gt; int | None:\n        \"\"\"The thread's exit code.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        if not self.dead:\n            liblog.warning(\"Thread is not dead. No exit code available.\")\n        elif self._exit_code is None and self._exit_signal is not None:\n            liblog.warning(\n                \"Thread exited with signal %s. No exit code available.\",\n                resolve_signal_name(self._exit_signal),\n            )\n        return self._exit_code\n\n    @property\n    def exit_signal(self: ThreadContext) -&gt; str | None:\n        \"\"\"The thread's exit signal.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        if not self.dead:\n            liblog.warning(\"Thread is not dead. No exit signal available.\")\n            return None\n        elif self._exit_signal is None and self._exit_code is not None:\n            liblog.warning(\"Thread exited with code %d. No exit signal available.\", self._exit_code)\n            return None\n        return resolve_signal_name(self._exit_signal)\n\n    @property\n    def signal(self: ThreadContext) -&gt; str | None:\n        \"\"\"The signal will be forwarded to the thread.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        return None if self._signal_number == 0 else resolve_signal_name(self._signal_number)\n\n    @signal.setter\n    def signal(self: ThreadContext, signal: str | int) -&gt; None:\n        \"\"\"Set the signal to forward to the thread.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        if self._signal_number != 0:\n            liblog.debugger(\n                f\"Overwriting signal {resolve_signal_name(self._signal_number)} with {resolve_signal_name(signal) if isinstance(signal, int) else signal}.\",\n            )\n        if isinstance(signal, str):\n            signal = resolve_signal_number(signal)\n        self._signal_number = signal\n        self._internal_debugger.resume_context.threads_with_signals_to_forward.append(self.thread_id)\n\n    @property\n    def signal_number(self: ThreadContext) -&gt; int:\n        \"\"\"The signal number to forward to the thread.\"\"\"\n        return self._signal_number\n\n    def backtrace(self: ThreadContext, as_symbols: bool = False) -&gt; list:\n        \"\"\"Returns the current backtrace of the thread.\n\n        Args:\n            as_symbols (bool, optional): Whether to return the backtrace as symbols\n        \"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n        backtrace = stack_unwinder.unwind(self)\n        if as_symbols:\n            maps = self._internal_debugger.debugging_interface.get_maps()\n            backtrace = [resolve_address_in_maps(x, maps) for x in backtrace]\n        return backtrace\n\n    def pprint_backtrace(self: ThreadContext) -&gt; None:\n        \"\"\"Pretty prints the current backtrace of the thread.\"\"\"\n        self._internal_debugger._ensure_process_stopped()\n        stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n        backtrace = stack_unwinder.unwind(self)\n        maps = self._internal_debugger.debugging_interface.get_maps()\n        for return_address in backtrace:\n            filtered_maps = maps.filter(return_address)\n            return_address_symbol = resolve_address_in_maps(return_address, filtered_maps)\n            permissions = filtered_maps[0].permissions\n            if \"rwx\" in permissions:\n                style = f\"{ANSIColors.UNDERLINE}{ANSIColors.RED}\"\n            elif \"x\" in permissions:\n                style = f\"{ANSIColors.RED}\"\n            elif \"w\" in permissions:\n                # This should not happen, but it's here for completeness\n                style = f\"{ANSIColors.YELLOW}\"\n            elif \"r\" in permissions:\n                # This should not happen, but it's here for completeness\n                style = f\"{ANSIColors.GREEN}\"\n            if return_address_symbol[:2] == \"0x\":\n                print(f\"{style}{return_address:#x} {ANSIColors.RESET}\")\n            else:\n                print(f\"{style}{return_address:#x} &lt;{return_address_symbol}&gt; {ANSIColors.RESET}\")\n\n    def _pprint_reg(self: ThreadContext, register: str) -&gt; None:\n        attr = getattr(self.regs, register)\n        color = \"\"\n        style = \"\"\n        formatted_attr = f\"{attr:#x}\"\n\n        if maps := self._internal_debugger.maps.filter(attr):\n            permissions = maps[0].permissions\n            if \"rwx\" in permissions:\n                color = ANSIColors.RED\n                style = ANSIColors.UNDERLINE\n            elif \"x\" in permissions:\n                color = ANSIColors.RED\n            elif \"w\" in permissions:\n                color = ANSIColors.YELLOW\n            elif \"r\" in permissions:\n                color = ANSIColors.GREEN\n\n        if color or style:\n            formatted_attr = f\"{color}{style}{attr:#x}{ANSIColors.RESET}\"\n        print(f\"{ANSIColors.RED}{register}{ANSIColors.RESET}\\t{formatted_attr}\")\n\n    def pprint_registers(self: ThreadContext) -&gt; None:\n        \"\"\"Pretty prints the thread's registers.\"\"\"\n        for register in self._register_holder.provide_regs():\n            self._pprint_reg(register)\n\n    def pprint_regs(self: ThreadContext) -&gt; None:\n        \"\"\"Alias for the `pprint_registers` method.\n\n        Pretty prints the thread's registers.\n        \"\"\"\n        self.pprint_registers()\n\n    def pprint_registers_all(self: ThreadContext) -&gt; None:\n        \"\"\"Pretty prints all the thread's registers.\"\"\"\n        self.pprint_registers()\n\n        for t in self._register_holder.provide_special_regs():\n            self._pprint_reg(t)\n\n        for t in self._register_holder.provide_vector_fp_regs():\n            print(f\"{ANSIColors.BLUE}\" + \"{\" + f\"{ANSIColors.RESET}\")\n            for register in t:\n                value = getattr(self.regs, register)\n                formatted_value = f\"{value:#x}\" if isinstance(value, int) else str(value)\n                print(f\"  {ANSIColors.RED}{register}{ANSIColors.RESET}\\t{formatted_value}\")\n\n            print(f\"{ANSIColors.BLUE}\" + \"}\" + f\"{ANSIColors.RESET}\")\n\n    def pprint_regs_all(self: ThreadContext) -&gt; None:\n        \"\"\"Alias for the `pprint_registers_all` method.\n\n        Pretty prints all the thread's registers.\n        \"\"\"\n        self.pprint_registers_all()\n\n    def step(self: ThreadContext) -&gt; None:\n        \"\"\"Executes a single instruction of the process.\"\"\"\n        self._internal_debugger.step(self)\n\n    def step_until(\n        self: ThreadContext,\n        position: int | str,\n        max_steps: int = -1,\n        file: str = \"hybrid\",\n    ) -&gt; None:\n        \"\"\"Executes instructions of the process until the specified location is reached.\n\n        Args:\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n            file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n        \"\"\"\n        self._internal_debugger.step_until(self, position, max_steps, file)\n\n    def finish(self: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n        \"\"\"Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self._internal_debugger.finish(self, heuristic=heuristic)\n\n    def next(self: ThreadContext) -&gt; None:\n        \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self._internal_debugger.next(self)\n\n    def si(self: ThreadContext) -&gt; None:\n        \"\"\"Alias for the `step` method.\n\n        Executes a single instruction of the process.\n        \"\"\"\n        self._internal_debugger.step(self)\n\n    def su(\n        self: ThreadContext,\n        position: int | str,\n        max_steps: int = -1,\n    ) -&gt; None:\n        \"\"\"Alias for the `step_until` method.\n\n        Executes instructions of the process until the specified location is reached.\n\n        Args:\n            position (int | bytes): The location to reach.\n            max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n        \"\"\"\n        self._internal_debugger.step_until(self, position, max_steps)\n\n    def fin(self: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n        \"\"\"Alias for the `finish` method. Continues execution until the current function returns or the process stops.\n\n        The command requires a heuristic to determine the end of the function. The available heuristics are:\n        - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n        - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n        Args:\n            heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n        \"\"\"\n        self._internal_debugger.finish(self, heuristic)\n\n    def ni(self: ThreadContext) -&gt; None:\n        \"\"\"Alias for the `next` method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n        self._internal_debugger.next(self)\n\n    def __repr__(self: ThreadContext) -&gt; str:\n        \"\"\"Returns a string representation of the object.\"\"\"\n        repr_str = \"ThreadContext()\\n\"\n        repr_str += f\"  Thread ID: {self.thread_id}\\n\"\n        repr_str += f\"  Process ID: {self.process_id}\\n\"\n        repr_str += f\"  Instruction Pointer: {self.instruction_pointer:#x}\\n\"\n        repr_str += f\"  Dead: {self.dead}\"\n        return repr_str\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.dead","title":"<code>dead: bool</code>  <code>property</code>","text":"<p>Whether the thread is dead.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.debugger","title":"<code>debugger: Debugger</code>  <code>property</code>","text":"<p>The debugging context this thread belongs to.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.exit_code","title":"<code>exit_code: int | None</code>  <code>property</code>","text":"<p>The thread's exit code.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.exit_signal","title":"<code>exit_signal: str | None</code>  <code>property</code>","text":"<p>The thread's exit signal.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.instruction_pointer","title":"<code>instruction_pointer: int</code>  <code>instance-attribute</code>","text":"<p>The thread's instruction pointer.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.mem","title":"<code>mem: AbstractMemoryView</code>  <code>property</code>","text":"<p>Alias for the <code>memory</code> property.</p> <p>Get the memory view of the process.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.memory","title":"<code>memory: AbstractMemoryView</code>  <code>property</code>","text":"<p>The memory view of the debugged process.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.pid","title":"<code>pid: int</code>  <code>property</code>","text":"<p>Alias for <code>process_id</code> property.</p> <p>The process ID.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.process_id","title":"<code>process_id: int</code>  <code>property</code>","text":"<p>The process ID.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.regs","title":"<code>regs: Registers = regs_class(thread_id, self._register_holder.provide_regs())</code>  <code>instance-attribute</code>","text":"<p>The thread's registers.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.running","title":"<code>running: bool</code>  <code>property</code>","text":"<p>Whether the process is running.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.saved_ip","title":"<code>saved_ip: int</code>  <code>property</code>","text":"<p>The return address of the current function.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.signal","title":"<code>signal: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>The signal will be forwarded to the thread.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.signal_number","title":"<code>signal_number: int</code>  <code>property</code>","text":"<p>The signal number to forward to the thread.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg0","title":"<code>syscall_arg0: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 0.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg1","title":"<code>syscall_arg1: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 1.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg2","title":"<code>syscall_arg2: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 2.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg3","title":"<code>syscall_arg3: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 3.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg4","title":"<code>syscall_arg4: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 4.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_arg5","title":"<code>syscall_arg5: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall argument 5.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_number","title":"<code>syscall_number: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall number.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.syscall_return","title":"<code>syscall_return: int</code>  <code>instance-attribute</code>","text":"<p>The thread's syscall return value.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.thread_id","title":"<code>thread_id: int</code>  <code>property</code>","text":"<p>The thread ID.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.tid","title":"<code>tid: int</code>  <code>property</code>","text":"<p>The thread ID.</p>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.__init__","title":"<code>__init__(thread_id, registers)</code>","text":"<p>Initializes the Thread Context.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def __init__(self: ThreadContext, thread_id: int, registers: RegisterHolder) -&gt; None:\n    \"\"\"Initializes the Thread Context.\"\"\"\n    self._internal_debugger = provide_internal_debugger(self)\n    self._thread_id = thread_id\n    self._register_holder = registers\n    regs_class = self._register_holder.provide_regs_class()\n    self.regs = regs_class(thread_id, self._register_holder.provide_regs())\n    self._register_holder.apply_on_regs(self.regs, regs_class)\n    self._register_holder.apply_on_thread(self, ThreadContext)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns a string representation of the object.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def __repr__(self: ThreadContext) -&gt; str:\n    \"\"\"Returns a string representation of the object.\"\"\"\n    repr_str = \"ThreadContext()\\n\"\n    repr_str += f\"  Thread ID: {self.thread_id}\\n\"\n    repr_str += f\"  Process ID: {self.process_id}\\n\"\n    repr_str += f\"  Instruction Pointer: {self.instruction_pointer:#x}\\n\"\n    repr_str += f\"  Dead: {self.dead}\"\n    return repr_str\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.backtrace","title":"<code>backtrace(as_symbols=False)</code>","text":"<p>Returns the current backtrace of the thread.</p> <p>Parameters:</p> Name Type Description Default <code>as_symbols</code> <code>bool</code> <p>Whether to return the backtrace as symbols</p> <code>False</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def backtrace(self: ThreadContext, as_symbols: bool = False) -&gt; list:\n    \"\"\"Returns the current backtrace of the thread.\n\n    Args:\n        as_symbols (bool, optional): Whether to return the backtrace as symbols\n    \"\"\"\n    self._internal_debugger._ensure_process_stopped()\n    stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n    backtrace = stack_unwinder.unwind(self)\n    if as_symbols:\n        maps = self._internal_debugger.debugging_interface.get_maps()\n        backtrace = [resolve_address_in_maps(x, maps) for x in backtrace]\n    return backtrace\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.fin","title":"<code>fin(heuristic='backtrace')</code>","text":"<p>Alias for the <code>finish</code> method. Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> <code>'backtrace'</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def fin(self: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n    \"\"\"Alias for the `finish` method. Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n    self._internal_debugger.finish(self, heuristic)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.finish","title":"<code>finish(heuristic='backtrace')</code>","text":"<p>Continues execution until the current function returns or the process stops.</p> <p>The command requires a heuristic to determine the end of the function. The available heuristics are: - <code>backtrace</code>: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads. - <code>step-mode</code>: The debugger will step on the specified thread until the current function returns. This will be slower.</p> <p>Parameters:</p> Name Type Description Default <code>heuristic</code> <code>str</code> <p>The heuristic to use. Defaults to \"backtrace\".</p> <code>'backtrace'</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def finish(self: ThreadContext, heuristic: str = \"backtrace\") -&gt; None:\n    \"\"\"Continues execution until the current function returns or the process stops.\n\n    The command requires a heuristic to determine the end of the function. The available heuristics are:\n    - `backtrace`: The debugger will place a breakpoint on the saved return address found on the stack and continue execution on all threads.\n    - `step-mode`: The debugger will step on the specified thread until the current function returns. This will be slower.\n\n    Args:\n        heuristic (str, optional): The heuristic to use. Defaults to \"backtrace\".\n    \"\"\"\n    self._internal_debugger.finish(self, heuristic=heuristic)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.next","title":"<code>next()</code>","text":"<p>Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def next(self: ThreadContext) -&gt; None:\n    \"\"\"Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    self._internal_debugger.next(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.ni","title":"<code>ni()</code>","text":"<p>Alias for the <code>next</code> method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def ni(self: ThreadContext) -&gt; None:\n    \"\"\"Alias for the `next` method. Executes the next instruction of the process. If the instruction is a call, the debugger will continue until the called function returns.\"\"\"\n    self._internal_debugger.next(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.pprint_backtrace","title":"<code>pprint_backtrace()</code>","text":"<p>Pretty prints the current backtrace of the thread.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def pprint_backtrace(self: ThreadContext) -&gt; None:\n    \"\"\"Pretty prints the current backtrace of the thread.\"\"\"\n    self._internal_debugger._ensure_process_stopped()\n    stack_unwinder = stack_unwinding_provider(self._internal_debugger.arch)\n    backtrace = stack_unwinder.unwind(self)\n    maps = self._internal_debugger.debugging_interface.get_maps()\n    for return_address in backtrace:\n        filtered_maps = maps.filter(return_address)\n        return_address_symbol = resolve_address_in_maps(return_address, filtered_maps)\n        permissions = filtered_maps[0].permissions\n        if \"rwx\" in permissions:\n            style = f\"{ANSIColors.UNDERLINE}{ANSIColors.RED}\"\n        elif \"x\" in permissions:\n            style = f\"{ANSIColors.RED}\"\n        elif \"w\" in permissions:\n            # This should not happen, but it's here for completeness\n            style = f\"{ANSIColors.YELLOW}\"\n        elif \"r\" in permissions:\n            # This should not happen, but it's here for completeness\n            style = f\"{ANSIColors.GREEN}\"\n        if return_address_symbol[:2] == \"0x\":\n            print(f\"{style}{return_address:#x} {ANSIColors.RESET}\")\n        else:\n            print(f\"{style}{return_address:#x} &lt;{return_address_symbol}&gt; {ANSIColors.RESET}\")\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.pprint_registers","title":"<code>pprint_registers()</code>","text":"<p>Pretty prints the thread's registers.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def pprint_registers(self: ThreadContext) -&gt; None:\n    \"\"\"Pretty prints the thread's registers.\"\"\"\n    for register in self._register_holder.provide_regs():\n        self._pprint_reg(register)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.pprint_registers_all","title":"<code>pprint_registers_all()</code>","text":"<p>Pretty prints all the thread's registers.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def pprint_registers_all(self: ThreadContext) -&gt; None:\n    \"\"\"Pretty prints all the thread's registers.\"\"\"\n    self.pprint_registers()\n\n    for t in self._register_holder.provide_special_regs():\n        self._pprint_reg(t)\n\n    for t in self._register_holder.provide_vector_fp_regs():\n        print(f\"{ANSIColors.BLUE}\" + \"{\" + f\"{ANSIColors.RESET}\")\n        for register in t:\n            value = getattr(self.regs, register)\n            formatted_value = f\"{value:#x}\" if isinstance(value, int) else str(value)\n            print(f\"  {ANSIColors.RED}{register}{ANSIColors.RESET}\\t{formatted_value}\")\n\n        print(f\"{ANSIColors.BLUE}\" + \"}\" + f\"{ANSIColors.RESET}\")\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.pprint_regs","title":"<code>pprint_regs()</code>","text":"<p>Alias for the <code>pprint_registers</code> method.</p> <p>Pretty prints the thread's registers.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def pprint_regs(self: ThreadContext) -&gt; None:\n    \"\"\"Alias for the `pprint_registers` method.\n\n    Pretty prints the thread's registers.\n    \"\"\"\n    self.pprint_registers()\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.pprint_regs_all","title":"<code>pprint_regs_all()</code>","text":"<p>Alias for the <code>pprint_registers_all</code> method.</p> <p>Pretty prints all the thread's registers.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def pprint_regs_all(self: ThreadContext) -&gt; None:\n    \"\"\"Alias for the `pprint_registers_all` method.\n\n    Pretty prints all the thread's registers.\n    \"\"\"\n    self.pprint_registers_all()\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.set_as_dead","title":"<code>set_as_dead()</code>","text":"<p>Set the thread as dead.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def set_as_dead(self: ThreadContext) -&gt; None:\n    \"\"\"Set the thread as dead.\"\"\"\n    self._dead = True\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.si","title":"<code>si()</code>","text":"<p>Alias for the <code>step</code> method.</p> <p>Executes a single instruction of the process.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def si(self: ThreadContext) -&gt; None:\n    \"\"\"Alias for the `step` method.\n\n    Executes a single instruction of the process.\n    \"\"\"\n    self._internal_debugger.step(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.step","title":"<code>step()</code>","text":"<p>Executes a single instruction of the process.</p> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def step(self: ThreadContext) -&gt; None:\n    \"\"\"Executes a single instruction of the process.\"\"\"\n    self._internal_debugger.step(self)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.step_until","title":"<code>step_until(position, max_steps=-1, file='hybrid')</code>","text":"<p>Executes instructions of the process until the specified location is reached.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute. Defaults to -1.</p> <code>-1</code> <code>file</code> <code>str</code> <p>The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).</p> <code>'hybrid'</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def step_until(\n    self: ThreadContext,\n    position: int | str,\n    max_steps: int = -1,\n    file: str = \"hybrid\",\n) -&gt; None:\n    \"\"\"Executes instructions of the process until the specified location is reached.\n\n    Args:\n        position (int | bytes): The location to reach.\n        max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n        file (str, optional): The user-defined backing file to resolve the address in. Defaults to \"hybrid\" (libdebug will first try to solve the address as an absolute address, then as a relative address w.r.t. the \"binary\" map file).\n    \"\"\"\n    self._internal_debugger.step_until(self, position, max_steps, file)\n</code></pre>"},{"location":"from_pydoc/generated/state/thread_context/#libdebug.state.thread_context.ThreadContext.su","title":"<code>su(position, max_steps=-1)</code>","text":"<p>Alias for the <code>step_until</code> method.</p> <p>Executes instructions of the process until the specified location is reached.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>int | bytes</code> <p>The location to reach.</p> required <code>max_steps</code> <code>int</code> <p>The maximum number of steps to execute. Defaults to -1.</p> <code>-1</code> Source code in <code>libdebug/state/thread_context.py</code> <pre><code>def su(\n    self: ThreadContext,\n    position: int | str,\n    max_steps: int = -1,\n) -&gt; None:\n    \"\"\"Alias for the `step_until` method.\n\n    Executes instructions of the process until the specified location is reached.\n\n    Args:\n        position (int | bytes): The location to reach.\n        max_steps (int, optional): The maximum number of steps to execute. Defaults to -1.\n    \"\"\"\n    self._internal_debugger.step_until(self, position, max_steps)\n</code></pre>"},{"location":"from_pydoc/generated/utils/ansi_escape_codes/","title":"libdebug.utils.ansi_escape_codes","text":""},{"location":"from_pydoc/generated/utils/ansi_escape_codes/#libdebug.utils.ansi_escape_codes.ANSIColors","title":"<code>ANSIColors</code>","text":"<p>Class to define colors for the terminal.</p> Source code in <code>libdebug/utils/ansi_escape_codes.py</code> <pre><code>class ANSIColors:\n    \"\"\"Class to define colors for the terminal.\"\"\"\n\n    RED = \"\\033[91m\"\n    BLUE = \"\\033[94m\"\n    GREEN = \"\\033[92m\"\n    BRIGHT_YELLOW = \"\\033[93m\"\n    YELLOW = \"\\033[33m\"\n    PINK = \"\\033[95m\"\n    CYAN = \"\\033[96m\"\n    BOLD = \"\\033[1m\"\n    UNDERLINE = \"\\033[4m\"\n    STRIKE = \"\\033[9m\"\n    DEFAULT_COLOR = \"\\033[39m\"\n    RESET = \"\\033[0m\"\n</code></pre>"},{"location":"from_pydoc/generated/utils/arch_mappings/","title":"libdebug.utils.arch_mappings","text":""},{"location":"from_pydoc/generated/utils/arch_mappings/#libdebug.utils.arch_mappings.map_arch","title":"<code>map_arch(arch)</code>","text":"<p>Map the architecture to the correct format.</p> <p>Parameters:</p> Name Type Description Default <code>arch</code> <code>str</code> <p>the architecture to map.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the mapped architecture.</p> Source code in <code>libdebug/utils/arch_mappings.py</code> <pre><code>def map_arch(arch: str) -&gt; str:\n    \"\"\"Map the architecture to the correct format.\n\n    Args:\n        arch (str): the architecture to map.\n\n    Returns:\n        str: the mapped architecture.\n    \"\"\"\n    arch = arch.lower()\n\n    if arch in ARCH_MAPPING.values():\n        return arch\n    elif arch in ARCH_MAPPING:\n        return ARCH_MAPPING[arch]\n    else:\n        raise ValueError(f\"Architecture {arch} not supported.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugger_wrappers/","title":"libdebug.utils.debugger_wrappers","text":""},{"location":"from_pydoc/generated/utils/debugger_wrappers/#libdebug.utils.debugger_wrappers.background_alias","title":"<code>background_alias(alias_method)</code>","text":"<p>Decorator that automatically resolves the call to a different method if coming from the background thread.</p> Source code in <code>libdebug/utils/debugger_wrappers.py</code> <pre><code>def background_alias(alias_method: callable) -&gt; callable:\n    \"\"\"Decorator that automatically resolves the call to a different method if coming from the background thread.\"\"\"\n\n    # This is the stupidest thing I've ever seen. Why Python, why?\n    def _background_alias(method: callable) -&gt; callable:\n        @wraps(method)\n        def inner(self: InternalDebugger, *args: ..., **kwargs: ...) -&gt; ...:\n            if self._is_in_background():\n                return alias_method(self, *args, **kwargs)\n            return method(self, *args, **kwargs)\n\n        return inner\n\n    return _background_alias\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugger_wrappers/#libdebug.utils.debugger_wrappers.change_state_function_process","title":"<code>change_state_function_process(method)</code>","text":"<p>Decorator to perfom control flow checks before executing a method.</p> Source code in <code>libdebug/utils/debugger_wrappers.py</code> <pre><code>def change_state_function_process(method: callable) -&gt; callable:\n    \"\"\"Decorator to perfom control flow checks before executing a method.\"\"\"\n\n    @wraps(method)\n    def wrapper(self: InternalDebugger, *args: ..., **kwargs: ...) -&gt; ...:\n        if not self.instanced:\n            raise RuntimeError(\n                \"Process not running. Did you call run()?\",\n            )\n\n        # We have to ensure that the process is stopped before executing the method\n        self._ensure_process_stopped()\n\n        # We have to ensure that at least one thread is alive before executing the method\n        if self.threads[0].dead:\n            raise RuntimeError(\"All threads are dead.\")\n        return method(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugger_wrappers/#libdebug.utils.debugger_wrappers.change_state_function_thread","title":"<code>change_state_function_thread(method)</code>","text":"<p>Decorator to perfom control flow checks before executing a method.</p> Source code in <code>libdebug/utils/debugger_wrappers.py</code> <pre><code>def change_state_function_thread(method: callable) -&gt; callable:\n    \"\"\"Decorator to perfom control flow checks before executing a method.\"\"\"\n\n    @wraps(method)\n    def wrapper(\n        self: InternalDebugger,\n        thread: ThreadContext,\n        *args: ...,\n        **kwargs: ...,\n    ) -&gt; ...:\n        if not self.instanced:\n            raise RuntimeError(\n                \"Process not running. Did you call run()?\",\n            )\n\n        # We have to ensure that the process is stopped before executing the method\n        self._ensure_process_stopped()\n\n        # We have to ensure that at least one thread is alive before executing the method\n        if thread.dead:\n            raise RuntimeError(\"The thread is dead.\")\n        return method(self, thread, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugging_utils/","title":"libdebug.utils.debugging_utils","text":""},{"location":"from_pydoc/generated/utils/debugging_utils/#libdebug.utils.debugging_utils.normalize_and_validate_address","title":"<code>normalize_and_validate_address(address, maps)</code>","text":"<p>Normalizes and validates the specified address.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address to normalize and validate.</p> required <code>maps</code> <code>MemoryMapList[MemoryMap]</code> <p>The memory maps.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The normalized address.</p> Throws <p>ValueError: If the specified address does not belong to any memory map.</p> Source code in <code>libdebug/utils/debugging_utils.py</code> <pre><code>def normalize_and_validate_address(address: int, maps: MemoryMapList[MemoryMap]) -&gt; int:\n    \"\"\"Normalizes and validates the specified address.\n\n    Args:\n        address (int): The address to normalize and validate.\n        maps (MemoryMapList[MemoryMap]): The memory maps.\n\n    Returns:\n        int: The normalized address.\n\n    Throws:\n        ValueError: If the specified address does not belong to any memory map.\n    \"\"\"\n    if address &lt; maps[0].start:\n        # The address is lower than the base address of the lowest map. Suppose it is a relative address for a PIE binary.\n        address += maps[0].start\n\n    for vmap in maps:\n        if vmap.start &lt;= address &lt; vmap.end:\n            return address\n\n    raise ValueError(f\"Address {hex(address)} does not belong to any memory map.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugging_utils/#libdebug.utils.debugging_utils.resolve_address_in_maps","title":"<code>resolve_address_in_maps(address, maps)</code>","text":"<p>Returns the symbol corresponding to the specified address in the specified memory maps.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>int</code> <p>The address whose symbol should be returned.</p> required <code>maps</code> <code>MemoryMapList[MemoryMap]</code> <p>The memory maps.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The symbol corresponding to the specified address in the specified memory maps.</p> Throws <p>ValueError: If the specified address does not belong to any memory map.</p> Source code in <code>libdebug/utils/debugging_utils.py</code> <pre><code>def resolve_address_in_maps(address: int, maps: MemoryMapList[MemoryMap]) -&gt; str:\n    \"\"\"Returns the symbol corresponding to the specified address in the specified memory maps.\n\n    Args:\n        address (int): The address whose symbol should be returned.\n        maps (MemoryMapList[MemoryMap]): The memory maps.\n\n    Returns:\n        str: The symbol corresponding to the specified address in the specified memory maps.\n\n    Throws:\n        ValueError: If the specified address does not belong to any memory map.\n    \"\"\"\n    mapped_files = {}\n\n    for vmap in maps:\n        file = vmap.backing_file\n        if not file or file[0] == \"[\":\n            continue\n\n        if file not in mapped_files:\n            mapped_files[file] = (vmap.start, vmap.end)\n        else:\n            mapped_files[file] = (mapped_files[file][0], vmap.end)\n\n    for file, (base_address, top_address) in mapped_files.items():\n        # Check if the address is in the range of the current section\n        if address &lt; base_address or address &gt;= top_address:\n            continue\n\n        try:\n            return resolve_address(file, address - base_address) if is_pie(file) else resolve_address(file, address)\n        except OSError as e:\n            liblog.debugger(f\"Error while resolving address {hex(address)} in {file}: {e}\")\n        except ValueError:\n            pass\n\n    return hex(address)\n</code></pre>"},{"location":"from_pydoc/generated/utils/debugging_utils/#libdebug.utils.debugging_utils.resolve_symbol_in_maps","title":"<code>resolve_symbol_in_maps(symbol, maps)</code>","text":"<p>Returns the address of the specified symbol in the specified memory maps.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The symbol whose address should be returned.</p> required <code>maps</code> <code>MemoryMapList[MemoryMap]</code> <p>The memory maps.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The address of the specified symbol in the specified memory maps.</p> Throws <p>ValueError: If the specified symbol does not belong to any memory map.</p> Source code in <code>libdebug/utils/debugging_utils.py</code> <pre><code>def resolve_symbol_in_maps(symbol: str, maps: MemoryMapList[MemoryMap]) -&gt; int:\n    \"\"\"Returns the address of the specified symbol in the specified memory maps.\n\n    Args:\n        symbol (str): The symbol whose address should be returned.\n        maps (MemoryMapList[MemoryMap]): The memory maps.\n\n    Returns:\n        int: The address of the specified symbol in the specified memory maps.\n\n    Throws:\n        ValueError: If the specified symbol does not belong to any memory map.\n    \"\"\"\n    mapped_files = {}\n\n    if \"+\" in symbol:\n        symbol, offset_str = symbol.split(\"+\")\n        offset = int(offset_str, 16)\n    else:\n        offset = 0\n\n    for vmap in maps:\n        if vmap.backing_file and vmap.backing_file not in mapped_files and vmap.backing_file[0] != \"[\":\n            mapped_files[vmap.backing_file] = vmap.start\n\n    for file, base_address in mapped_files.items():\n        try:\n            address = resolve_symbol(file, symbol)\n\n            if is_pie(file):\n                address += base_address\n\n            return address + offset\n        except OSError as e:\n            liblog.debugger(f\"Error while resolving symbol {symbol} in {file}: {e}\")\n        except ValueError:\n            pass\n\n    raise ValueError(f\"Symbol {symbol} not found in the specified mapped file. Please specify a valid symbol.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/","title":"libdebug.utils.elf_utils","text":""},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.elf_architecture","title":"<code>elf_architecture(path)</code>","text":"<p>Returns the architecture of the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The architecture of the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>def elf_architecture(path: str) -&gt; str:\n    \"\"\"Returns the architecture of the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n\n    Returns:\n        str: The architecture of the specified ELF file.\n    \"\"\"\n    return parse_elf_characteristics(path)[2]\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.get_all_symbols","title":"<code>get_all_symbols(backing_files)</code>","text":"<p>Returns a list of all the symbols in the target process.</p> <p>Parameters:</p> Name Type Description Default <code>backing_files</code> <code>set[str]</code> <p>The set of backing files.</p> required <p>Returns:</p> Type Description <code>SymbolList[Symbol]</code> <p>SymbolList[Symbol]: A list of all the symbols in the target process.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>def get_all_symbols(backing_files: set[str]) -&gt; SymbolList[Symbol]:\n    \"\"\"Returns a list of all the symbols in the target process.\n\n    Args:\n        backing_files (set[str]): The set of backing files.\n\n    Returns:\n        SymbolList[Symbol]: A list of all the symbols in the target process.\n    \"\"\"\n    symbols = SymbolList([])\n\n    if libcontext.sym_lvl == 0:\n        raise Exception(\n            \"Symbol resolution is disabled. Please enable it by setting the sym_lvl libcontext parameter to a value greater than 0.\",\n        )\n\n    for file in backing_files:\n        # Retrieve the symbols from the SymbolTableSection\n        new_symbols, buildid, debug_file = _parse_elf_file(file, libcontext.sym_lvl)\n        symbols += new_symbols\n\n        # Retrieve the symbols from the external debuginfo file\n        if buildid and debug_file and libcontext.sym_lvl &gt; 2:\n            folder = buildid[:2]\n            absolute_debug_path_str = str((LOCAL_DEBUG_PATH / folder / debug_file).resolve())\n            symbols += _collect_external_info(absolute_debug_path_str)\n\n        # Retrieve the symbols from debuginfod\n        if buildid and libcontext.sym_lvl &gt; 4:\n            absolute_debug_path = _debuginfod(buildid)\n            if absolute_debug_path.exists():\n                symbols += _collect_external_info(str(absolute_debug_path))\n\n    return symbols\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.get_entry_point","title":"<code>get_entry_point(path)</code>","text":"<p>Returns the entry point of the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The entry point of the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>def get_entry_point(path: str) -&gt; int:\n    \"\"\"Returns the entry point of the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n\n    Returns:\n        int: The entry point of the specified ELF file.\n    \"\"\"\n    return parse_elf_characteristics(path)[1]\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.is_pie","title":"<code>is_pie(path)</code>","text":"<p>Returns True if the specified ELF file is position independent, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the specified ELF file is position independent, False otherwise.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>def is_pie(path: str) -&gt; bool:\n    \"\"\"Returns True if the specified ELF file is position independent, False otherwise.\n\n    Args:\n        path (str): The path to the ELF file.\n\n    Returns:\n        bool: True if the specified ELF file is position independent, False otherwise.\n    \"\"\"\n    return parse_elf_characteristics(path)[0]\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.parse_elf_characteristics","title":"<code>parse_elf_characteristics(path)</code>  <code>cached</code>","text":"<p>Returns a tuple containing the PIE flag, the entry point and the architecture of the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[bool, int, str]</code> <p>A tuple containing the PIE flag, the entry point and the architecture of the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>@functools.cache\ndef parse_elf_characteristics(path: str) -&gt; tuple[bool, int, str]:\n    \"\"\"Returns a tuple containing the PIE flag, the entry point and the architecture of the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n\n    Returns:\n        tuple: A tuple containing the PIE flag, the entry point and the architecture of the specified ELF file.\n    \"\"\"\n    with Path(path).open(\"rb\") as elf_file:\n        elf = ELFFile(elf_file)\n\n    pie = elf.header.e_type == \"ET_DYN\"\n    entry_point = elf.header.e_entry\n    arch = elf.get_machine_arch()\n\n    return pie, entry_point, arch\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.resolve_address","title":"<code>resolve_address(path, address)</code>  <code>cached</code>","text":"<p>Returns the symbol corresponding to the specified address in the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <code>address</code> <code>int</code> <p>The address whose symbol should be returned.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The symbol corresponding to the specified address in the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>@functools.cache\ndef resolve_address(path: str, address: int) -&gt; str:\n    \"\"\"Returns the symbol corresponding to the specified address in the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n        address (int): The address whose symbol should be returned.\n\n    Returns:\n        str: The symbol corresponding to the specified address in the specified ELF file.\n    \"\"\"\n    if libcontext.sym_lvl == 0:\n        return hex(address)\n\n    # Retrieve the symbols from the SymbolTableSection\n    symbols, buildid, debug_file = _parse_elf_file(path, libcontext.sym_lvl)\n    symbols = [symbol for symbol in symbols if symbol.start &lt;= address &lt; symbol.end]\n    if symbols:\n        symbol = symbols[0]\n        return f\"{symbol.name}+{address-symbol.start:x}\"\n\n    # Retrieve the symbols from the external debuginfo file\n    if buildid and debug_file and libcontext.sym_lvl &gt; 2:\n        folder = buildid[:2]\n        absolute_debug_path_str = str((LOCAL_DEBUG_PATH / folder / debug_file).resolve())\n        symbols = _collect_external_info(absolute_debug_path_str)\n        symbols = [symbol for symbol in symbols if symbol.start &lt;= address &lt; symbol.end]\n        if symbols:\n            symbol = symbols[0]\n            return f\"{symbol.name}+{address-symbol.start:x}\"\n\n    # Retrieve the symbols from debuginfod\n    if buildid and libcontext.sym_lvl &gt; 4:\n        absolute_debug_path = _debuginfod(buildid)\n        if absolute_debug_path.exists():\n            symbols = _collect_external_info(str(absolute_debug_path))\n            symbols = [symbol for symbol in symbols if symbol.start &lt;= address &lt; symbol.end]\n            if symbols:\n                symbol = symbols[0]\n                return f\"{symbol.name}+{address-symbol.start:x}\"\n\n    # Address not found\n    raise ValueError(f\"Address {hex(address)} not found in {path}. Please specify a valid address.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.resolve_argv_path","title":"<code>resolve_argv_path(argv_path)</code>","text":"<p>Resolve the path of the binary to debug.</p> <p>Parameters:</p> Name Type Description Default <code>argv_path</code> <code>str</code> <p>The provided path of the binary to debug.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The resolved path of the binary to debug.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>def resolve_argv_path(argv_path: str) -&gt; str:\n    \"\"\"Resolve the path of the binary to debug.\n\n    Args:\n        argv_path (str): The provided path of the binary to debug.\n\n    Returns:\n        str: The resolved path of the binary to debug.\n    \"\"\"\n    argv_path_expanded = Path(argv_path).expanduser()\n\n    # Check if the path is absolute after expansion\n    if argv_path_expanded.is_absolute():\n        # It's an absolute path, return it as is\n        resolved_path = argv_path_expanded\n    else:\n        # It's a relative path, try to resolve it\n        resolved_path = abs_path if (abs_path := shutil.which(argv_path_expanded)) else argv_path_expanded\n    return str(resolved_path)\n</code></pre>"},{"location":"from_pydoc/generated/utils/elf_utils/#libdebug.utils.elf_utils.resolve_symbol","title":"<code>resolve_symbol(path, symbol)</code>  <code>cached</code>","text":"<p>Returns the address of the specified symbol in the specified ELF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the ELF file.</p> required <code>symbol</code> <code>str</code> <p>The symbol whose address should be returned.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The address of the specified symbol in the specified ELF file.</p> Source code in <code>libdebug/utils/elf_utils.py</code> <pre><code>@functools.cache\ndef resolve_symbol(path: str, symbol: str) -&gt; int:\n    \"\"\"Returns the address of the specified symbol in the specified ELF file.\n\n    Args:\n        path (str): The path to the ELF file.\n        symbol (str): The symbol whose address should be returned.\n\n    Returns:\n        int: The address of the specified symbol in the specified ELF file.\n    \"\"\"\n    if libcontext.sym_lvl == 0:\n        raise Exception(\n            \"Symbol resolution is disabled. Please enable it by setting the sym_lvl libcontext parameter to a value greater than 0.\",\n        )\n\n    # Retrieve the symbols from the SymbolTableSection\n    symbols, buildid, debug_file = _parse_elf_file(path, libcontext.sym_lvl)\n    symbols = [sym for sym in symbols if sym.name == symbol]\n    if symbols:\n        return symbols[0].start\n\n    # Retrieve the symbols from the external debuginfo file\n    if buildid and debug_file and libcontext.sym_lvl &gt; 2:\n        folder = buildid[:2]\n        absolute_debug_path_str = str((LOCAL_DEBUG_PATH / folder / debug_file).resolve())\n        symbols = _collect_external_info(absolute_debug_path_str)\n        symbols = [sym for sym in symbols if sym.name == symbol]\n        if symbols:\n            return symbols[0].start\n\n    # Retrieve the symbols from debuginfod\n    if buildid and libcontext.sym_lvl &gt; 4:\n        absolute_debug_path = _debuginfod(buildid)\n        if absolute_debug_path.exists():\n            symbols = _collect_external_info(str(absolute_debug_path))\n            symbols = [sym for sym in symbols if sym.name == symbol]\n            if symbols:\n                return symbols[0].start\n\n    # Symbol not found\n    raise ValueError(f\"Symbol {symbol} not found in {path}. Please specify a valid symbol.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/gdb/","title":"libdebug.utils.gdb","text":""},{"location":"from_pydoc/generated/utils/gdb/#libdebug.utils.gdb.GoBack","title":"<code>GoBack</code>","text":"<p>               Bases: <code>Command</code></p> <p>This extension adds a new command to GDB that allows to detach from the current process and quit GDB.</p> Source code in <code>libdebug/utils/gdb.py</code> <pre><code>class GoBack(gdb.Command):\n    \"\"\"This extension adds a new command to GDB that allows to detach from the current process and quit GDB.\"\"\"\n\n    def __init__(self: GoBack) -&gt; None:\n        \"\"\"Initializes the GoBack command.\"\"\"\n        super().__init__(\"goback\", gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, True)\n\n    def invoke(self: GoBack, _: ..., __: bool) -&gt; None:\n        \"\"\"Detaches and quits from GDB on invocation.\"\"\"\n        gdb.execute(\"detach\")\n        gdb.execute(\"quit\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/gdb/#libdebug.utils.gdb.GoBack.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the GoBack command.</p> Source code in <code>libdebug/utils/gdb.py</code> <pre><code>def __init__(self: GoBack) -&gt; None:\n    \"\"\"Initializes the GoBack command.\"\"\"\n    super().__init__(\"goback\", gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, True)\n</code></pre>"},{"location":"from_pydoc/generated/utils/gdb/#libdebug.utils.gdb.GoBack.invoke","title":"<code>invoke(_, __)</code>","text":"<p>Detaches and quits from GDB on invocation.</p> Source code in <code>libdebug/utils/gdb.py</code> <pre><code>def invoke(self: GoBack, _: ..., __: bool) -&gt; None:\n    \"\"\"Detaches and quits from GDB on invocation.\"\"\"\n    gdb.execute(\"detach\")\n    gdb.execute(\"quit\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/","title":"libdebug.utils.libcontext","text":""},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext","title":"<code>LibContext</code>","text":"<p>A class that holds the global context of the library.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>class LibContext:\n    \"\"\"A class that holds the global context of the library.\"\"\"\n\n    _instance = None\n    _pipe_logger_levels: list[str]\n    _debugger_logger_levels: list[str]\n    _general_logger_levels: list[str]\n\n    def __new__(cls: type):\n        \"\"\"Create a new instance of the class if it does not exist yet.\n\n        Returns:\n            LibContext: the instance of the class.\n        \"\"\"\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._initialized = False\n        return cls._instance\n\n    def __init__(self: LibContext) -&gt; None:\n        \"\"\"Initializes the context.\"\"\"\n        if self._initialized:\n            return\n\n        self._pipe_logger_levels = [\"DEBUG\", \"SILENT\"]\n        self._debugger_logger_levels = [\"DEBUG\", \"SILENT\"]\n        self._general_logger_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"SILENT\"]\n        self._sym_lvl = 5\n\n        self._debugger_logger = \"SILENT\"\n        self._pipe_logger = \"SILENT\"\n        self._general_logger = \"INFO\"\n\n        # Adjust log levels based on command-line arguments\n        if len(sys.argv) &gt; 1:\n            if \"debugger\" in sys.argv:\n                liblog.debugger_logger.setLevel(\"DEBUG\")\n                self._debugger_logger = \"DEBUG\"\n            elif \"pipe\" in sys.argv:\n                liblog.pipe_logger.setLevel(\"DEBUG\")\n                self._pipe_logger = \"DEBUG\"\n            elif \"dbg\" in sys.argv:\n                self._set_debug_level_for_all()\n                self._debugger_logger = \"DEBUG\"\n                self._pipe_logger = \"DEBUG\"\n                self._general_logger = \"DEBUG\"\n        self._initialized = True\n\n        self._terminal = []\n\n    def _set_debug_level_for_all(self: LibContext) -&gt; None:\n        \"\"\"Set the debug level for all the loggers to DEBUG.\"\"\"\n        for logger in [\n            liblog.general_logger,\n            liblog.debugger_logger,\n            liblog.pipe_logger,\n        ]:\n            logger.setLevel(\"DEBUG\")\n\n    @property\n    def sym_lvl(self: LibContext) -&gt; int:\n        \"\"\"Property getter for sym_lvl.\n\n        Returns:\n            _sym_lvl (int): the current symbol level.\n        \"\"\"\n        return self._sym_lvl\n\n    @sym_lvl.setter\n    def sym_lvl(self: LibContext, value: int) -&gt; None:\n        \"\"\"Property setter for sym_lvl, ensuring it's between 0 and 5.\"\"\"\n        if 0 &lt;= value &lt;= 5:\n            self._sym_lvl = value\n        else:\n            raise ValueError(\"sym_lvl must be between 0 and 5\")\n\n    @property\n    def debugger_logger(self: LibContext) -&gt; str:\n        \"\"\"Property getter for debugger_logger.\n\n        Returns:\n            _debugger_logger (str): the current debugger logger level.\n        \"\"\"\n        return self._debugger_logger\n\n    @debugger_logger.setter\n    def debugger_logger(self: LibContext, value: str) -&gt; None:\n        \"\"\"Property setter for debugger_logger, ensuring it's a supported logging level.\"\"\"\n        if value in self._debugger_logger_levels:\n            self._debugger_logger = value\n            liblog.debugger_logger.setLevel(value)\n        else:\n            raise ValueError(\n                f\"debugger_logger must be a supported logging level. The supported levels are: {self._debugger_logger_levels}\",\n            )\n\n    @property\n    def pipe_logger(self: LibContext) -&gt; str:\n        \"\"\"Property getter for pipe_logger.\n\n        Returns:\n            _pipe_logger (str): the current pipe logger level.\n        \"\"\"\n        return self._pipe_logger\n\n    @pipe_logger.setter\n    def pipe_logger(self: LibContext, value: str) -&gt; None:\n        \"\"\"Property setter for pipe_logger, ensuring it's a supported logging level.\"\"\"\n        if value in self._pipe_logger_levels:\n            self._pipe_logger = value\n            liblog.pipe_logger.setLevel(value)\n        else:\n            raise ValueError(\n                f\"pipe_logger must be a supported logging level. The supported levels are: {self._pipe_logger_levels}\",\n            )\n\n    @property\n    def general_logger(self: LibContext) -&gt; str:\n        \"\"\"Property getter for general_logger.\n\n        Returns:\n            _general_logger (str): the current general logger level.\n        \"\"\"\n        return self._general_logger\n\n    @general_logger.setter\n    def general_logger(self: LibContext, value: str) -&gt; None:\n        \"\"\"Property setter for general_logger, ensuring it's a supported logging level.\"\"\"\n        if value in self._general_logger_levels:\n            self._general_logger = value\n            liblog.general_logger.setLevel(value)\n        else:\n            raise ValueError(\n                f\"general_logger must be a supported logging level. The supported levels are: {self._general_logger_levels}\",\n            )\n\n    @property\n    def platform(self: LibContext) -&gt; str:\n        \"\"\"Return the current platform.\"\"\"\n        return map_arch(platform.machine())\n\n    @property\n    def terminal(self: LibContext) -&gt; list[str]:\n        \"\"\"Property getter for terminal.\n\n        Returns:\n            _terminal (str): the current terminal.\n        \"\"\"\n        return self._terminal\n\n    @terminal.setter\n    def terminal(self: LibContext, value: list[str] | str) -&gt; None:\n        \"\"\"Property setter for terminal, ensuring it's a valid terminal.\"\"\"\n        if isinstance(value, str):\n            value = [value]\n\n        self._terminal = value\n\n    def update(self: LibContext, **kwargs: ...) -&gt; None:\n        \"\"\"Update the context with the given values.\"\"\"\n        for key, value in kwargs.items():\n            if hasattr(self, key):\n                setattr(self, key, value)\n\n    @contextmanager\n    def tmp(self: LibContext, **kwargs: ...) -&gt; ...:\n        \"\"\"Context manager that temporarily changes the library context. Use \"with\" statement.\"\"\"\n        # Make a deep copy of the current state\n        old_context = deepcopy(self.__dict__)\n        self.update(**kwargs)\n        try:\n            yield\n        finally:\n            # Restore the original state\n            self.__dict__.update(old_context)\n            liblog.debugger_logger.setLevel(self.debugger_logger)\n            liblog.pipe_logger.setLevel(self.pipe_logger)\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.debugger_logger","title":"<code>debugger_logger: str</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for debugger_logger.</p> <p>Returns:</p> Name Type Description <code>_debugger_logger</code> <code>str</code> <p>the current debugger logger level.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.general_logger","title":"<code>general_logger: str</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for general_logger.</p> <p>Returns:</p> Name Type Description <code>_general_logger</code> <code>str</code> <p>the current general logger level.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.pipe_logger","title":"<code>pipe_logger: str</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for pipe_logger.</p> <p>Returns:</p> Name Type Description <code>_pipe_logger</code> <code>str</code> <p>the current pipe logger level.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.platform","title":"<code>platform: str</code>  <code>property</code>","text":"<p>Return the current platform.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.sym_lvl","title":"<code>sym_lvl: int</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for sym_lvl.</p> <p>Returns:</p> Name Type Description <code>_sym_lvl</code> <code>int</code> <p>the current symbol level.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.terminal","title":"<code>terminal: list[str]</code>  <code>property</code> <code>writable</code>","text":"<p>Property getter for terminal.</p> <p>Returns:</p> Name Type Description <code>_terminal</code> <code>str</code> <p>the current terminal.</p>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.__init__","title":"<code>__init__()</code>","text":"<p>Initializes the context.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>def __init__(self: LibContext) -&gt; None:\n    \"\"\"Initializes the context.\"\"\"\n    if self._initialized:\n        return\n\n    self._pipe_logger_levels = [\"DEBUG\", \"SILENT\"]\n    self._debugger_logger_levels = [\"DEBUG\", \"SILENT\"]\n    self._general_logger_levels = [\"DEBUG\", \"INFO\", \"WARNING\", \"SILENT\"]\n    self._sym_lvl = 5\n\n    self._debugger_logger = \"SILENT\"\n    self._pipe_logger = \"SILENT\"\n    self._general_logger = \"INFO\"\n\n    # Adjust log levels based on command-line arguments\n    if len(sys.argv) &gt; 1:\n        if \"debugger\" in sys.argv:\n            liblog.debugger_logger.setLevel(\"DEBUG\")\n            self._debugger_logger = \"DEBUG\"\n        elif \"pipe\" in sys.argv:\n            liblog.pipe_logger.setLevel(\"DEBUG\")\n            self._pipe_logger = \"DEBUG\"\n        elif \"dbg\" in sys.argv:\n            self._set_debug_level_for_all()\n            self._debugger_logger = \"DEBUG\"\n            self._pipe_logger = \"DEBUG\"\n            self._general_logger = \"DEBUG\"\n    self._initialized = True\n\n    self._terminal = []\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.__new__","title":"<code>__new__()</code>","text":"<p>Create a new instance of the class if it does not exist yet.</p> <p>Returns:</p> Name Type Description <code>LibContext</code> <p>the instance of the class.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>def __new__(cls: type):\n    \"\"\"Create a new instance of the class if it does not exist yet.\n\n    Returns:\n        LibContext: the instance of the class.\n    \"\"\"\n    if cls._instance is None:\n        cls._instance = super().__new__(cls)\n        cls._instance._initialized = False\n    return cls._instance\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.tmp","title":"<code>tmp(**kwargs)</code>","text":"<p>Context manager that temporarily changes the library context. Use \"with\" statement.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>@contextmanager\ndef tmp(self: LibContext, **kwargs: ...) -&gt; ...:\n    \"\"\"Context manager that temporarily changes the library context. Use \"with\" statement.\"\"\"\n    # Make a deep copy of the current state\n    old_context = deepcopy(self.__dict__)\n    self.update(**kwargs)\n    try:\n        yield\n    finally:\n        # Restore the original state\n        self.__dict__.update(old_context)\n        liblog.debugger_logger.setLevel(self.debugger_logger)\n        liblog.pipe_logger.setLevel(self.pipe_logger)\n</code></pre>"},{"location":"from_pydoc/generated/utils/libcontext/#libdebug.utils.libcontext.LibContext.update","title":"<code>update(**kwargs)</code>","text":"<p>Update the context with the given values.</p> Source code in <code>libdebug/utils/libcontext.py</code> <pre><code>def update(self: LibContext, **kwargs: ...) -&gt; None:\n    \"\"\"Update the context with the given values.\"\"\"\n    for key, value in kwargs.items():\n        if hasattr(self, key):\n            setattr(self, key, value)\n</code></pre>"},{"location":"from_pydoc/generated/utils/platform_utils/","title":"libdebug.utils.platform_utils","text":""},{"location":"from_pydoc/generated/utils/platform_utils/#libdebug.utils.platform_utils.get_platform_register_size","title":"<code>get_platform_register_size(arch)</code>","text":"<p>Get the register size of the platform.</p> <p>Parameters:</p> Name Type Description Default <code>arch</code> <code>str</code> <p>The architecture of the platform.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The register size in bytes.</p> Source code in <code>libdebug/utils/platform_utils.py</code> <pre><code>def get_platform_register_size(arch: str) -&gt; int:\n    \"\"\"Get the register size of the platform.\n\n    Args:\n        arch (str): The architecture of the platform.\n\n    Returns:\n        int: The register size in bytes.\n    \"\"\"\n    match arch:\n        case \"amd64\":\n            return 8\n        case \"aarch64\":\n            return 8\n        case \"i386\":\n            return 4\n        case _:\n            raise ValueError(f\"Architecture {arch} not supported.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/posix_spawn/","title":"libdebug.utils.posix_spawn","text":""},{"location":"from_pydoc/generated/utils/posix_spawn/#libdebug.utils.posix_spawn.posix_spawn","title":"<code>posix_spawn(file, argv, env, file_actions, setpgroup)</code>","text":"<p>Spawn a new process, emulating the POSIX spawn function.</p> Source code in <code>libdebug/utils/posix_spawn.py</code> <pre><code>def posix_spawn(file: str, argv: list, env: dict, file_actions: list, setpgroup: bool) -&gt; int:\n    \"\"\"Spawn a new process, emulating the POSIX spawn function.\"\"\"\n    child_pid = os.fork()\n    if child_pid == 0:\n        for element in file_actions:\n            if element[0] == POSIX_SPAWN_CLOSE:\n                os.close(element[1])\n            elif element[0] == POSIX_SPAWN_DUP2:\n                os.dup2(element[1], element[2])\n            elif element[0] == POSIX_SPAWN_OPEN:\n                fd, path, flags, mode = element[1:]\n                os.dup2(os.open(path, flags, mode), fd)\n            else:\n                raise ValueError(\"Invalid file action\")\n        if setpgroup == 0:\n            os.setpgid(0, 0)\n        os.execve(file, argv, env)\n\n    return child_pid\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/","title":"libdebug.utils.process_utils","text":""},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.disable_self_aslr","title":"<code>disable_self_aslr()</code>","text":"<p>Disables ASLR for the current process.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>def disable_self_aslr() -&gt; None:\n    \"\"\"Disables ASLR for the current process.\"\"\"\n    retval = lib_personality.disable_aslr()\n\n    if retval == -1:\n        raise RuntimeError(\"Failed to disable ASLR.\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.get_open_fds","title":"<code>get_open_fds(process_id)</code>  <code>cached</code>","text":"<p>Returns the file descriptors of the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>process_id</code> <code>int</code> <p>The PID of the process whose file descriptors should be returned.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[int]</code> <p>A list of integers, each representing a file descriptor of the specified process.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>@functools.cache\ndef get_open_fds(process_id: int) -&gt; list[int]:\n    \"\"\"Returns the file descriptors of the specified process.\n\n    Args:\n        process_id (int): The PID of the process whose file descriptors should be returned.\n\n    Returns:\n        list: A list of integers, each representing a file descriptor of the specified process.\n    \"\"\"\n    return [int(fd) for fd in os.listdir(f\"/proc/{process_id}/fd\")]\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.get_process_maps","title":"<code>get_process_maps(process_id)</code>  <code>cached</code>","text":"<p>Returns the memory maps of the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>process_id</code> <code>int</code> <p>The PID of the process whose memory maps should be returned.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>MemoryMapList[MemoryMap]</code> <p>A list of <code>MemoryMap</code> objects, each representing a memory map of the specified process.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>@functools.cache\ndef get_process_maps(process_id: int) -&gt; MemoryMapList[MemoryMap]:\n    \"\"\"Returns the memory maps of the specified process.\n\n    Args:\n        process_id (int): The PID of the process whose memory maps should be returned.\n\n    Returns:\n        list: A list of `MemoryMap` objects, each representing a memory map of the specified process.\n    \"\"\"\n    with Path(f\"/proc/{process_id}/maps\").open() as maps_file:\n        maps = maps_file.readlines()\n\n    return MemoryMapList([MemoryMap.parse(vmap) for vmap in maps])\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.get_process_tasks","title":"<code>get_process_tasks(process_id)</code>","text":"<p>Returns the tasks of the specified process.</p> <p>Parameters:</p> Name Type Description Default <code>process_id</code> <code>int</code> <p>The PID of the process whose tasks should be returned.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list[int]</code> <p>A list of integers, each representing a task of the specified process.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>def get_process_tasks(process_id: int) -&gt; list[int]:\n    \"\"\"Returns the tasks of the specified process.\n\n    Args:\n        process_id (int): The PID of the process whose tasks should be returned.\n\n    Returns:\n        list: A list of integers, each representing a task of the specified process.\n    \"\"\"\n    tids = []\n    if Path(f\"/proc/{process_id}/task\").exists():\n        tids = [int(task) for task in os.listdir(f\"/proc/{process_id}/task\")]\n    return tids\n</code></pre>"},{"location":"from_pydoc/generated/utils/process_utils/#libdebug.utils.process_utils.invalidate_process_cache","title":"<code>invalidate_process_cache()</code>","text":"<p>Invalidates the cache of the functions in this module. Must be executed any time the process executes code.</p> Source code in <code>libdebug/utils/process_utils.py</code> <pre><code>def invalidate_process_cache() -&gt; None:\n    \"\"\"Invalidates the cache of the functions in this module. Must be executed any time the process executes code.\"\"\"\n    get_process_maps.cache_clear()\n    get_open_fds.cache_clear()\n</code></pre>"},{"location":"from_pydoc/generated/utils/search_utils/","title":"libdebug.utils.search_utils","text":""},{"location":"from_pydoc/generated/utils/search_utils/#libdebug.utils.search_utils.find_all_overlapping_occurrences","title":"<code>find_all_overlapping_occurrences(pattern, data, abs_address=0)</code>","text":"<p>Find all overlapping occurrences of a pattern in a data.</p> Source code in <code>libdebug/utils/search_utils.py</code> <pre><code>def find_all_overlapping_occurrences(pattern: bytes, data: bytes, abs_address: int = 0) -&gt; list[int]:\n    \"\"\"Find all overlapping occurrences of a pattern in a data.\"\"\"\n    start = 0\n    occurrences = []\n    while True:\n        start = data.find(pattern, start)\n        if start == -1:\n            # No more occurrences\n            break\n        occurrences.append(start + abs_address)\n        # Increment start to find overlapping matches\n        start += 1\n    return occurrences\n</code></pre>"},{"location":"from_pydoc/generated/utils/signal_utils/","title":"libdebug.utils.signal_utils","text":""},{"location":"from_pydoc/generated/utils/signal_utils/#libdebug.utils.signal_utils.create_signal_mappings","title":"<code>create_signal_mappings()</code>  <code>cached</code>","text":"<p>Create mappings between signal names and numbers.</p> Source code in <code>libdebug/utils/signal_utils.py</code> <pre><code>@functools.cache\ndef create_signal_mappings() -&gt; tuple[dict, dict]:\n    \"\"\"Create mappings between signal names and numbers.\"\"\"\n    signal_to_number = {}\n    number_to_signal = {}\n\n    for name in dir(signal):\n        if name.startswith(\"SIG\") and not name.startswith(\"SIG_\"):\n            number = getattr(signal, name)\n            signal_to_number[name] = number\n            number_to_signal[number] = name\n\n    # RT signals have a different convention\n    for i in range(1, signal.SIGRTMAX - signal.SIGRTMIN):\n        name = f\"SIGRTMIN+{i}\"\n        number = signal.SIGRTMIN + i\n        signal_to_number[name] = number\n        number_to_signal[number] = name\n\n    return signal_to_number, number_to_signal\n</code></pre>"},{"location":"from_pydoc/generated/utils/signal_utils/#libdebug.utils.signal_utils.get_all_signal_numbers","title":"<code>get_all_signal_numbers()</code>  <code>cached</code>","text":"<p>Get all the signal numbers.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the list of signal numbers.</p> Source code in <code>libdebug/utils/signal_utils.py</code> <pre><code>@functools.cache\ndef get_all_signal_numbers() -&gt; list:\n    \"\"\"Get all the signal numbers.\n\n    Returns:\n        list: the list of signal numbers.\n    \"\"\"\n    _, number_to_signal = create_signal_mappings()\n\n    return list(number_to_signal.keys())\n</code></pre>"},{"location":"from_pydoc/generated/utils/signal_utils/#libdebug.utils.signal_utils.resolve_signal_name","title":"<code>resolve_signal_name(number)</code>  <code>cached</code>","text":"<p>Resolve a signal number to its name.</p> <p>Parameters:</p> Name Type Description Default <code>number</code> <code>int</code> <p>the signal number.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the signal name.</p> Source code in <code>libdebug/utils/signal_utils.py</code> <pre><code>@functools.cache\ndef resolve_signal_name(number: int) -&gt; str:\n    \"\"\"Resolve a signal number to its name.\n\n    Args:\n        number (int): the signal number.\n\n    Returns:\n        str: the signal name.\n    \"\"\"\n    if number == -1:\n        return \"ALL\"\n\n    _, number_to_signal = create_signal_mappings()\n\n    try:\n        return number_to_signal[number]\n    except KeyError as e:\n        raise ValueError(f\"Signal {number} not found.\") from e\n</code></pre>"},{"location":"from_pydoc/generated/utils/signal_utils/#libdebug.utils.signal_utils.resolve_signal_number","title":"<code>resolve_signal_number(name)</code>  <code>cached</code>","text":"<p>Resolve a signal name to its number.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the signal name.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>the signal number.</p> Source code in <code>libdebug/utils/signal_utils.py</code> <pre><code>@functools.cache\ndef resolve_signal_number(name: str) -&gt; int:\n    \"\"\"Resolve a signal name to its number.\n\n    Args:\n        name (str): the signal name.\n\n    Returns:\n        int: the signal number.\n    \"\"\"\n    if name in [\"ALL\", \"all\", \"*\", \"pkm\"]:\n        return -1\n\n    signal_to_number, _ = create_signal_mappings()\n\n    try:\n        return signal_to_number[name]\n    except KeyError as e:\n        raise ValueError(f\"Signal {name} not found.\") from e\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/","title":"libdebug.utils.syscall_utils","text":""},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.fetch_remote_syscall_definition","title":"<code>fetch_remote_syscall_definition(arch)</code>","text":"<p>Fetch the syscall definition file from the remote server.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>def fetch_remote_syscall_definition(arch: str) -&gt; dict:\n    \"\"\"Fetch the syscall definition file from the remote server.\"\"\"\n    url = get_remote_definition_url(arch)\n\n    response = requests.get(url, timeout=1)\n    response.raise_for_status()\n\n    # Save the response to a local file\n    with Path(f\"{LOCAL_FOLDER_PATH}/{arch}.json\").open(\"w\") as f:\n        f.write(response.text)\n\n    return response.json()\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.get_all_syscall_numbers","title":"<code>get_all_syscall_numbers(architecture)</code>  <code>cached</code>","text":"<p>Retrieves all the syscall numbers.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef get_all_syscall_numbers(architecture: str) -&gt; list[int]:\n    \"\"\"Retrieves all the syscall numbers.\"\"\"\n    definitions = get_syscall_definitions(architecture)\n\n    return [syscall[\"number\"] for syscall in definitions[\"syscalls\"]]\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.get_remote_definition_url","title":"<code>get_remote_definition_url(arch)</code>","text":"<p>Get the URL of the remote syscall definition file.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>def get_remote_definition_url(arch: str) -&gt; str:\n    \"\"\"Get the URL of the remote syscall definition file.\"\"\"\n    match arch:\n        case \"amd64\":\n            return f\"{SYSCALLS_REMOTE}/x86/64/x64/latest/table.json\"\n        case \"aarch64\":\n            return f\"{SYSCALLS_REMOTE}/arm64/64/aarch64/latest/table.json\"\n        case \"i386\":\n            return f\"{SYSCALLS_REMOTE}/x86/32/ia32/latest/table.json\"\n        case _:\n            raise ValueError(f\"Architecture {arch} not supported\")\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.get_syscall_definitions","title":"<code>get_syscall_definitions(arch)</code>  <code>cached</code>","text":"<p>Get the syscall definitions for the specified architecture.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef get_syscall_definitions(arch: str) -&gt; dict:\n    \"\"\"Get the syscall definitions for the specified architecture.\"\"\"\n    LOCAL_FOLDER_PATH.mkdir(parents=True, exist_ok=True)\n\n    if (LOCAL_FOLDER_PATH / f\"{arch}.json\").exists():\n        try:\n            with (LOCAL_FOLDER_PATH / f\"{arch}.json\").open() as f:\n                return json.load(f)\n        except json.decoder.JSONDecodeError:\n            pass\n\n    return fetch_remote_syscall_definition(arch)\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.resolve_syscall_arguments","title":"<code>resolve_syscall_arguments(architecture, number)</code>  <code>cached</code>","text":"<p>Resolve a syscall number to its argument definition.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef resolve_syscall_arguments(architecture: str, number: int) -&gt; list[str]:\n    \"\"\"Resolve a syscall number to its argument definition.\"\"\"\n    definitions = get_syscall_definitions(architecture)\n\n    for syscall in definitions[\"syscalls\"]:\n        if syscall[\"number\"] == number:\n            return syscall[\"signature\"]\n\n    raise ValueError(f'Syscall number \"{number}\" not found')\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.resolve_syscall_name","title":"<code>resolve_syscall_name(architecture, number)</code>  <code>cached</code>","text":"<p>Resolve a syscall number to its name.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef resolve_syscall_name(architecture: str, number: int) -&gt; str:\n    \"\"\"Resolve a syscall number to its name.\"\"\"\n    definitions = get_syscall_definitions(architecture)\n\n    if number == -1:\n        return \"all\"\n\n    for syscall in definitions[\"syscalls\"]:\n        if syscall[\"number\"] == number:\n            return syscall[\"name\"]\n\n    raise ValueError(f'Syscall number \"{number}\" not found')\n</code></pre>"},{"location":"from_pydoc/generated/utils/syscall_utils/#libdebug.utils.syscall_utils.resolve_syscall_number","title":"<code>resolve_syscall_number(architecture, name)</code>  <code>cached</code>","text":"<p>Resolve a syscall name to its number.</p> Source code in <code>libdebug/utils/syscall_utils.py</code> <pre><code>@functools.cache\ndef resolve_syscall_number(architecture: str, name: str) -&gt; int:\n    \"\"\"Resolve a syscall name to its number.\"\"\"\n    definitions = get_syscall_definitions(architecture)\n\n    if name in [\"all\", \"*\", \"ALL\", \"pkm\"]:\n        return -1\n\n    for syscall in definitions[\"syscalls\"]:\n        if syscall[\"name\"] == name:\n            return syscall[\"number\"]\n\n    raise ValueError(f'Syscall \"{name}\" not found')\n</code></pre>"},{"location":"logging/liblog/","title":"Logging","text":"<p>Debugging an application with the freedom of a rich API can lead to flows which are hard to unravel. To aid the user in the debugging process, libdebug provides logging. The logging system is implemented in the submodule <code>liblog</code> and adheres to the Python logging system.</p>","boost":4},{"location":"logging/liblog/#event-logging","title":"Event Logging","text":"<p>By default, libdebug only prints critical logs such as warnings and errors. However, the user can enable more verbose logging by setting the <code>argv</code> parameter of the script.</p> <p>The available logging modes for events are:</p> Mode Description <code>debugger</code> Logs related to the debugging operations performed on the process by libdebug. <code>pipe</code> Logs related to interactions with the process pipe: bytes received and bytes sent. <code>dbg</code> Combination of the <code>pipe</code> and <code>debugger</code> options. <p>pwntools compatibility</p> <p>As reported in this documentation, the <code>argv</code> parameters passed to libdebug are lowercase. This choice is made to avoid conflicts with pwntools, which intercepts all uppercase arguments.</p>","boost":4},{"location":"logging/liblog/#debugger-logging","title":"Debugger Logging","text":"<p>The <code>debugger</code> option displays all logs related to the debugging operations performed on the process by libdebug.</p> <p></p>","boost":4},{"location":"logging/liblog/#pipe-logging","title":"Pipe Logging","text":"<p>The <code>pipe</code> option, on the other hand, displays all logs related to interactions with the process pipe: bytes received and bytes sent.</p> <p></p>","boost":4},{"location":"logging/liblog/#the-best-of-both-worlds","title":"The best of both worlds","text":"<p>The <code>dbg</code> option is the combination of the <code>pipe</code> and <code>debugger</code> options. It displays all logs related to the debugging operations performed on the process by libdebug, as well as interactions with the process pipe: bytes received and bytes sent.</p>","boost":4},{"location":"logging/liblog/#changing-logging-levels-at-runtime","title":"Changing logging levels at runtime","text":"<p>libdebug defines logging levels and information types to allow the user to filter the granularity of the the information they want to see. Logger levels for each event type can be changed at runtime using the <code>libcontext</code> module.</p> <p>Example of setting logging levels</p> <pre><code>from libdebug import libcontext\n\nlibcontext.general_logger = 'DEBUG'\nlibcontext.pipe_logger = 'DEBUG'\nlibcontext.debugger_logger = 'DEBUG'\n</code></pre> Logger Description Supported Levels Default Level <code>general_logger</code> Logger used for general libdebug logs, different from the <code>pipe</code> and <code>debugger</code> logs. <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>SILENT</code> <code>INFO</code> <code>pipe_logger</code> Logger used for pipe logs. <code>DEBUG</code>, <code>SILENT</code> <code>SILENT</code> <code>debugger_logger</code> Logger used for debugger logs. <code>DEBUG</code>, <code>SILENT</code> <code>SILENT</code> <p>Let's see what each logging level actually logs:</p> Log Level Debug Logs Information Logs Warnings DEBUG INFO WARNING SILENT","boost":4},{"location":"logging/liblog/#temporary-logging-level-changes","title":"Temporary logging level changes","text":"<p>Logger levels can be temporarily changed at runtime using a <code>with</code> statement, as shown in the following example.</p> <pre><code>from libdebug import libcontext\n\nwith libcontext.tmp(pipe_logger='SILENT', debugger_logger='DEBUG'):\n    r.sendline(b'gimme the flag')\n</code></pre>","boost":4},{"location":"multithreading/multithreading/","title":"Debugging Multithreaded Applications","text":"<p>Debugging multi-threaded applications can be a daunting task, particularly in an interactive debugger that is designed to operate on one thread at a time. libdebug offers a few features that will help you debug multi-threaded applications more intuitively and efficiently.</p>","boost":4},{"location":"multithreading/multithreading/#child-threads","title":"Child Threads","text":"<p>Threads of a running process in the POSIX standard are children of the main process. They are created by system calls such as fork, clone and clone3. In the Linux kernel, the ptrace system call allows a tracer to identify new threads of the debugged process and retrieve their thread id (tid).</p> <p>libdebug automatically registers new threads and exposes their state with the same API as the main Debugger object. While technically threads can be running or stopped independently, libdebug will enforce a coherent state. This means that if a thread is stopped, all other threads will be stopped as well and if a continuation command is issued, all threads will be resumed.</p> <p>To access the threads of a process, you can use the <code>threads</code> attribute of the Debugger object. This attribute will return a list of ThreadContext objects, each representing a thread of the process. Similarly, you can access the Debugger object from any ThreadContext through the <code>debugger</code> attribute.</p> <p>Meaning of the debugger object</p> <p>When accessing state fields of the Debugger object (e.g. registers, memory), the debugger will act as an alias for the main thread. For example, doing d.regs.rax will be equivalent to doing d.threads[0].regs.rax.</p> <p>Child Processes</p> <p>libdebug does not support debugging child processes (only threads). If a child process is created by the main process, a warning will be printed, prompting the user to attach to the child process manually.</p>","boost":4},{"location":"multithreading/multithreading/#shared-and-unshared-state","title":"Shared and Unshared State","text":"<p>Each thread has its own register set, stack, and instruction pointer. However, there are shared resources between threads that you should be aware of:</p> <ul> <li> <p> The virtual address space is mostly shared between threads. Currently, libdebug does not handle the multiprocessing.</p> </li> <li> <p> Software breakpoints are implemented through code patching in the process memory. This means that a breakpoint set in one thread will be replicated across all threads.</p> <ul> <li> <p>When using synchronous breakpoints, you will need to \"diagnose\" the stopping event to determine which thread triggered the breakpoint. You can do this by checking the return value of the <code>hit_on()</code> method of the Breakpoint object. Passing the ThreadContext as an argument will return <code>True</code> if the breakpoint was hit by that thread.</p> </li> <li> <p>When using asynchronous breakpoints, the breakpoint will be more intuitive to handle, as the signature of the callback function includes the ThreadContext object that triggered the breakpoint.</p> </li> </ul> </li> <li> <p> While hardware breakpoints are thread-specific, libdebug mirrors them across all threads. This is done to avoid asymmetries with software breakpoints. Watchpoints are hardware breakpoints, so this applies to them as well.</p> </li> <li> <p> For consistency, syscall handlers are also enabled across all threads. The same considerations for synchronous and asynchronous breakpoints apply here as well.</p> </li> </ul> <p>Concurrency in Syscall Handling</p> <p>When debugging entering and exiting events in syscalls, be mindful of the scheduling. The kernel may schedule a different thread to handle the syscall exit event right after the enter event of another thread.</p> <ul> <li> Signal Catching is also shared among threads. Apart from consistency, this is a necessity. In fact, the kernel does not guarantee that a signal sent to a process will be dispatched to a specific thread.<ul> <li>By contrast, when sending arbitrary signals through the ThreadContext object, the signal will be sent to the requested thread.</li> </ul> </li> </ul> <p>How to access TLS?</p> <p>While the virtual address space is shared between threads, each thread has its own Thread Local Storage (TLS) area. As it stands, libdebug does not provide a direct interface to the TLS area.</p>","boost":4},{"location":"quality_of_life/anti_debugging/","title":"Evasion of Anti-Debugging","text":"","boost":4},{"location":"quality_of_life/anti_debugging/#automatic-evasion-of-anti-debugging-techniques","title":"Automatic Evasion of Anti-Debugging Techniques","text":"<p>A common anti-debugging technique for Linux ELF binaries is to invoke the <code>ptrace</code> syscall with the <code>PTRACE_TRACEME</code> argument. The syscall will fail if the binary is currently being traced by a debugger, as the kernel forbids a process from being traced by multiple debuggers.</p> <p>Bypassing this technique involves intercepting such syscalls and altering the return value to make the binary believe that it is not being traced. While this can absolutely be performed manually, libdebug comes with a pre-made implementation that can save you precious time.</p> <p>To enable this feature, set the <code>escape_antidebug</code> property to <code>True</code> when creating the debugger object. The debugger will take care of the rest.</p> <p>Example</p> <p>&gt; C source code <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/ptrace.h&gt;\n\nint main()\n{\n\n    if (ptrace(PTRACE_TRACEME, 0, NULL, 0) == -1) // (1)\n    {\n        puts(\"No cheating! Debugger detected.\\n\"); // (2)\n        exit(1);\n    }\n\n    puts(\"Congrats! Here's your flag:\\n\"); // (3)\n    puts(\"flag{y0u_sn3aky_guy_y0u_tr1ck3d_m3}\\n\");\n\n    return 0;\n}\n</code></pre></p> <ol> <li>Call ptrace with <code>PTRACE_TRACEME</code> to detect if we are being debugged</li> <li>If the call fails, it means the program is being debugged</li> <li>If the program is not being debugged, print the flag</li> </ol> <p>&gt; libdebug script <pre><code>from libdebug import debugger\n\nd = debugger(\"evasive_binary\",\n    escape_antidebug=True)\n\npipe = d.run()\n\nd.cont()\nout = pipe.recvline(numlines=2)\nd.wait()\n\nprint(out.decode())\n</code></pre></p> <p>Execution of the script will print the flag, even if the binary is being debugged.</p>","boost":4},{"location":"quality_of_life/memory_maps/","title":"Memory Maps","text":"<p>Virtual memory is a fundamental concept in operating systems. It allows the operating system to provide each process with its own address space, which is isolated from other processes. This isolation is crucial for security and stability reasons. The memory of a process is divided into regions called memory maps. Each memory map has a starting address, an ending address, and a set of permissions (read, write, execute).</p> <p>In libdebug, you can access the memory maps of a process using the <code>maps</code> attribute of the Debugger object.</p> <p>The <code>maps</code> attribute returns a list of MemoryMap objects, which contain the following attributes:</p> Attribute Type Description <code>start</code> <code>int</code> The start address of the memory map. <code>end</code> <code>int</code> The end address of the memory map. <code>permissions</code> <code>str</code> The permissions of the memory map. <code>size</code> <code>int</code> The size of the memory map. <code>offset</code> <code>int</code> The offset of the memory map relative to the backing file. <code>backing_file</code> <code>str</code> The backing file of the memory map, or the symbolic name of the memory map.","boost":4},{"location":"quality_of_life/memory_maps/#filtering-memory-maps","title":"Filtering Memory Maps","text":"<p>You can filter memory maps based on their attributes using the <code>filter()</code> method of the <code>maps</code> attribute. The <code>filter()</code> method accepts a value that can be either a memory address (<code>int</code>) or a symbolic name (<code>str</code>) and returns a list of MemoryMap objects that match the criteria.</p> <p>Function Signature</p> <pre><code>d.maps.filter(value: int | str) -&gt; MemoryMapList[MemoryMap]:\n</code></pre> <p>The behavior of the memory map filtering depends on the type of the <code>value</code> parameter:</p> Queried Value Return Value Integer (memory address) Map that contains the address String (symbolic map name) List of maps with backing file matching the symbolic name","boost":4},{"location":"quality_of_life/pretty_printing/","title":"Pretty Printing","text":"","boost":4},{"location":"quality_of_life/pretty_printing/#pretty-printing","title":"Pretty Printing","text":"<p>libdebug offers utilities to visualize the process's state in a human-readable format and with color highlighting. This can be especially useful when debugging complex binaries or when you need to quickly understand the behavior of a program.</p>","boost":4},{"location":"quality_of_life/pretty_printing/#registers-pretty-printing","title":"Registers Pretty Printing","text":"<p>There are two functions available to print the registers of a thread: <code>pprint_registers()</code> and <code>print_registers_all()</code>. The former will print the current values of the most commonly-interesting registers, while the latter will print all available registers.</p> <p></p> <p>Aliases</p> <p>If you don't like long function names, you can use aliases for the two register pretty print functions. The shorter aliases are <code>pprint_regs()</code> and <code>print_regs_all()</code>.</p>","boost":4},{"location":"quality_of_life/pretty_printing/#syscall-trace-pretty-printing","title":"Syscall Trace Pretty Printing","text":"<p>When debugging a binary, it is often much faster to guess what the intended functionality is by looking at the syscalls that are being invoked. libdebug offers a function that will intercept any syscall and print its arguments and return value. This can be done by setting the property <code>pprint_syscalls = True</code> in the Debugger object or ThreadContext object and resuming the process.</p> <p>Syscall Trace PPrint Syntax</p> <pre><code>d.pprint_syscalls = True\nd.cont()\n</code></pre> <p>The output will be printed to the console in color according to the following coding:</p> Format Description blue Syscall name red Syscall was intercepted and handled by a callback (either a basic handler or a hijack) yellow Value given to a syscall argument in hexadecimal strikethrough Syscall was hijacked or a value was changed, the new syscall or value follows the striken text <p>Handled syscalls with a callback associated with them will be listed as such. Additionally, syscalls hijacked through the libdebug API will be highlighted as striken through, allowing you to monitor both the original behavior and your own changes to the flow. The id of the thread that made the syscall will be printed in the beginning of the line in white bold.</p> <p></p>","boost":4},{"location":"quality_of_life/pretty_printing/#memory-maps-pretty-printing","title":"Memory Maps Pretty Printing","text":"<p>To pretty print the memory maps of a process, you can simply use the <code>pprint_maps()</code> function. This will print the memory maps of the process in a human-readable format, with color highlighting to distinguish between different memory regions.</p> Format Description underlined Memory map with read, write, and execute permissions red Memory map with execute permissions yellow Memory map with write permissions green Memory map with read permission only white Memory map with no permissions <p></p>","boost":4},{"location":"quality_of_life/pretty_printing/#stack-trace-pretty-printing","title":"Stack Trace Pretty Printing","text":"<p>To pretty print the stack trace (backtrace) of a process, you can use the <code>pprint_backtrace()</code> function. This will print the stack trace of the process in a human-readable format.</p> <p></p>","boost":4},{"location":"quality_of_life/quality_of_life/","title":"Quality of Life Features","text":"<p>For your convenience, libdebug offers a few functions that will speed up your debugging process.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#pretty-printing","title":"Pretty Printing","text":"<p>Visualizing the state of the process you are debugging can be a daunting task. libdebug offers utilities to print registers, memory maps, syscalls, and more in a human-readable format and with color highlighting.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#symbol-resolution","title":"Symbol Resolution","text":"<p>libdebug can resolve symbols in the binary and shared libraries. With big binaries, this can be a computationally intensive, especially if your script needs to be run multiple types. You can set symbol resolution levels and specify where to look for symbols according to your needs.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#memory-maps","title":"Memory Maps","text":"<p>libdebug offers utilities to retrieve the memory maps of a process. This can be useful to understand the memory layout of the process you are debugging.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#stack-frame-utils","title":"Stack Frame Utils","text":"<p>libdebug offers utilities to resolve the return addresses of a process.</p>","boost":4},{"location":"quality_of_life/quality_of_life/#evasion-of-anti-debugging","title":"Evasion of Anti-Debugging","text":"<p>libdebug offers a few functions that will help you evade simple anti-debugging techniques. These functions can be used to bypass checks for the presence of a debugger.</p>","boost":4},{"location":"quality_of_life/stack_frame_utils/","title":"Stack Frame Utils","text":"<p>Function calls in a binary executable are made according to a system calling convention. One constant in these conventions is the use of a stack frame to store the return addresses to resume at the end of the function.</p> <p>Different architectures have slightly different ways to retrieve the return address (for example, in AArch64, the latest return address is stored in <code>x30</code>, the Link Register). To abstract these differences, libdebug provides common utilities to resolve the stack trace (backtrace) of the running process (or thread).</p> <p>libdebug's backtrace is structured like a LIFO stack, with the top-most value being the current instruction pointer. Subsequent values are the return addresses of the functions that were called to reach the current instruction pointer.</p> <p>Backtrace usage example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"test_backtrace\")\nd.run()\n\n# A few calls later...\n[...]\n\ncurrent_ip = d.backtrace()[0]\nreturn_address = d.backtrace()[1]\nother_return_addresses = d.backtrace()[2:]\n</code></pre> <p>Additionally, the field <code>saved_ip</code> of the Debugger or ThreadContext objects will contain the return address of the current function.</p>","boost":4},{"location":"quality_of_life/symbols/","title":"Symbol Resolution","text":"","boost":4},{"location":"quality_of_life/symbols/#symbol-resolution","title":"Symbol Resolution","text":"<p>As described in the memory access section, many functions in libdebug accept symbols as an alternative to actual addresses.</p> <p>You can list all resolved symbols in the binary and shared libraries using the <code>symbols</code> attribute of the Debugger object. This attribute returns a SymbolList object.</p> <p>This object grants the user hybrid access to the symbols: as a dict or as a list. Tor example, the following lines of code all have a valid syntax:</p> <pre><code>d.symbols['printf'] #(1)\nd.symbols[0] #(2)\nd.symbols['printf'][0] #(3)\n</code></pre> <ol> <li>Returns a list of symbols that match the string <code>printf</code> exactly.</li> <li>Returns the first symbol in the list.</li> <li>Returns the first symbol that matches the string <code>printf</code> exactly.</li> </ol> <p>Please note that the dict-like access returns exact matches with the symbol name. If you want to filter for symbols that contain a specific string, read the dedicated section.</p> <p>C++ Demangling</p> <p>Reverse-engineering of C++ binaries can be a struggle. To help out, libdebug automatically demangles C++ symbols.</p>","boost":4},{"location":"quality_of_life/symbols/#symbol-resolution-levels","title":"Symbol Resolution Levels","text":"<p>With large binaries and libraries, parsing symbols can become an expensive operation. Because of this, libdebug offers the possibility of choosing among 5 levels of symbol resolution. To set the symbol resolution level, you can use the <code>sym_lvl</code> property of the <code>libcontext</code> module. The default value is level 5.</p> Level Description 0 Symbol resolution is disabled. 1 Parse the ELF symbol table (.symtab) and dynamic symbol table (.dynsym). 2 Parse the ELF DWARF. 3 Follow the external debug file link in the .gnu_debuglink and/or .gnu_debugaltlink sections. If the file is present in the system, read its .symtab and .dynsym. 4 Parse the external debug file DWARF, if the file exists in the system. 5 Download the external debug file using <code>debuginfod</code>. The file is cached in the default folder for <code>debuginfod</code>. <p>Upon searching for symbols, libdebug will proceed from the lowest level to the set maximum.</p> <p>Example of setting the symbol resolution level</p> <pre><code>from libdebug import libcontext\n\nlibcontext.sym_lvl = 3\nd.breakpoint('main')\n</code></pre> <p>If you want to change the symbol resolution level temporarily, you can use a <code>with</code> statement along with the <code>tmp</code> method of the <code>libcontext</code> module.</p> <p>Example of temporary resolution level change</p> <pre><code>from libdebug import libcontext\n\nwith libcontext.tmp(sym_lvl = 5):\n    d.breakpoint('main')\n</code></pre>","boost":4},{"location":"quality_of_life/symbols/#symbol-filtering","title":"Symbol Filtering","text":"<p>The <code>symbols</code> attribute of the Debugger object allows you to filter symbols in the binary and shared libraries.</p> <p>Function Signature</p> <pre><code>d.symbols.filter(value: int | str) -&gt; SymbolList[Symbol]\n</code></pre> <p>Given a symbol name or address, this function returns a SymbolList. The list will conta</p> <p>Symbol objects contain the following attributes:</p> Attribute Type Description <code>start</code> <code>int</code> The start address of the symbol. <code>end</code> <code>int</code> The end address of the symbol. <code>name</code> <code>str</code> The name of the symbol. <code>backing_file</code> <code>str</code> The file where the symbol is defined (e.g., binary, libc, ld). <p>Slow Symbol Resolution</p> <p>Please keep in mind that symbol resolution can be an expensive operation on large binaries and shared libraries. If you are experiencing performance issues, you can set the symbol resolution level to a lower value.</p>","boost":4},{"location":"stopping_events/breakpoints/","title":"Breakpoints","text":"<p>Breakpoints are the killer feature of any debugger, the fundamental stopping event. They allow you to stop the execution of your code at a specific point and inspect the state of your program to find bugs or understand its design.</p> <p>Multithreading and Breakpoints</p> <p>libdebug breakpoints are shared across all threads. This means that any thread can hit the breakpoint and cause the process to stop. You can use the <code>hit_on()</code> method of a breakpoint object to determine which thread hit the breakpoint (provided that the stop was indeed caused by the breakpoint).</p> <p>A breakpoint can be inserted at any of two levels: software or hardware.</p>","boost":4},{"location":"stopping_events/breakpoints/#software-breakpoints","title":"Software Breakpoints","text":"<p>Software breakpoints in the Linux kernel are implemented by patching the code in memory at runtime. The instruction at the chosen address is replaced with an interrupt instruction that is conventionally used for debugging. For example, in the <code>i386</code> and <code>AMD64</code> instruction sets, <code>int3</code> (0xCC) is reserved for this purpose.</p> <p>When the <code>int3</code> instruction is executed, the CPU raises a <code>SIGTRAP</code> signal, which is caught by the debugger. The debugger then stops the process and restores the original instruction to its rightful place.</p> <p>Pros and Cons of Software Breakpoints</p> <p>Software breakpoints are unlimited, but they can break when the program uses self-modifying code. This is because the patched code could be overwritten by the program. On the other hand, software breakpoints are slower than their hardware counterparts on most modern CPUs.</p>","boost":4},{"location":"stopping_events/breakpoints/#hardware-breakpoints","title":"Hardware Breakpoints","text":"<p>Hardware breakpoints are a more reliable way to set breakpoints. They are made possible by the existence of special registers in the CPU that can be used to monitor memory accesses. Differently from software breakpoints, their hardware counterparts allows the debugger to monitor read and write accesses on top of code execution. This kind of hardware breakpoint is also called a watchpoint. More information on watchpoints can be found in the dedicated documentation.</p> <p>Pros and Cons of Hardware Breakpoints</p> <p>Hardware breakpoints are not affected by self-modifying code. They are also usually faster and more flexible. However, hardware breakpoints are limited in number and are hardware-dependent, so their support may vary across different systems.</p> <p>Hardware Breakpoint Alignment in AArch64</p> <p>Hardware breakpoints have to be aligned to 4 bytes (which is the size of an ARM instruction).</p>","boost":4},{"location":"stopping_events/breakpoints/#libdebug-api-for-breakpoints","title":"libdebug API for Breakpoints","text":"<p>The <code>breakpoint()</code> function in the Debugger object sets a breakpoint at a specific address.</p> <p>Function Signature</p> <pre><code>d.breakpoint(position, hardware=False, condition='x', length=1, callback=None, file='hybrid')\n</code></pre> <p>Parameters:</p> Argument Type Description <code>position</code> <code>int</code> | <code>str</code> The address or symbol where the breakpoint will be set. <code>hardware</code> <code>bool</code> Set to <code>True</code> to set a hardware breakpoint. <code>condition</code> <code>str</code> The type of access in case of a hardware breakpoint. <code>length</code> <code>int</code> The size of the word being watched in case of a hardware breakpoint. <code>callback</code> <code>Callable</code> | <code>bool</code> (see callback signature here) Used to create asyncronous breakpoints (read more on the debugging flow of stopping events). <code>file</code> <code>str</code> The backing file for relative addressing. Refer to the memory access section for more information on addressing modes. <p>Returns:</p> Return Type Description <code>Breakpoint</code> Breakpoint The breakpoint object created. <p>Limited Hardware Breakpoints</p> <p>Hardware breakpoints are limited in number. If you exceed the number of hardware breakpoints available on your system, a <code>RuntimeError</code> will be raised.</p> <p>Usage Example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\n\nd.run()\n\nbp = d.breakpoint(0x10ab, file=\"binary\") # (1)\nbp1 = d.breakpoint(\"main\", file=\"binary\") # (3)\nbp2 = d.breakpoint(\"printf\", file=\"libc\") # (4)\n\nd.cont()\n\nprint(f\"RAX: {d.regs.rax} at the breakpoint\") # (2)\nif bp.hit_on(d):\n    print(\"Breakpoint at 0x10ab was hit\")\nelif bp1.hit_on(d):\n    print(\"Breakpoint at main was hit\")\nelif bp2.hit_on(d):\n    print(\"Breakpoint at printf was hit\")\n</code></pre> <ol> <li>Set a software breakpoint at address 0x10ab relative to the program's base address</li> <li>Print the value of the RAX register when the breakpoint is hit</li> <li>Set a software breakpoint at the <code>main</code> symbol</li> <li>Set a software breakpoint at the <code>printf</code> symbol in the <code>libc</code> library</li> </ol>","boost":4},{"location":"stopping_events/breakpoints/#callback-signature","title":"Callback Signature","text":"<p>If you wish to create an asynchronous breakpoint, you will have to provide a callback function. If you want to leave the callback empty, you can set callback to <code>True</code>.</p> <p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, bp: Breakpoint):\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the breakpoint. <code>bp</code> Breakpoint The breakpoint object that triggered the callback. <p>Example usage of asynchronous breakpoints</p> <pre><code>def on_breakpoint_hit(t, bp):\n    print(f\"RAX: {t.regs.rax}\")\n\n    if bp.hit_count == 100:\n        print(\"Hit count reached 100\")\n        bp.disable()\n\nd.breakpoint(0x11f0, callback=on_breakpoint_hit, file=\"binary\")\n</code></pre>","boost":4},{"location":"stopping_events/debugging_flow/","title":"Debugging Flow of Stopping Events","text":"<p>Before diving into each libdebug stopping event, it's crucial to understand the debugging flow that these events introduce, based on the mode selected by the user.</p> <p>The flow of all stopping events is similar and adheres to a mostly uniform API structure. Upon placing a stopping event, the user is allowed to specify a callback function for the stopping event. If a callback is passed, the event will trigger asynchronously. Otherwise, if the callback is not passed, the event will be synchronous. The following flowchart shows the difference between the two flows.</p> Flowchart of different handling modes for stopping events <p>When a synchronous event is hit, the process will stop, awaiting further commands. When an asynchronous event is hit, libdebug temporarily stops the process and invokes the user callback. Process execution is automatically resumed right after.</p> <p>Tip: Use cases of asynchronous stopping events</p> <p>The asynchronous mode for stopping events is particularly useful for events being repeated as a result of a loop in the executed code.</p> <p>When attempting side-channel reverse engineering, this mode can save a lot of your time.</p>","boost":4},{"location":"stopping_events/debugging_flow/#types-of-stopping-events","title":"Types of Stopping Events","text":"<p>libdebug supports the following types of stopping events:</p> Event Type Description Notes Breakpoint Stops the process when a certain address is executed Can be a software or a hardware breakpoint Watchpoint Stops the process when a memory area is read or written Alias for a hardware breakpoint Syscall Stops the process when a syscall is made Two events are supported: syscall start and end Signal Stops the process when a signal is received <p>Multiple callbacks or hijacks</p> <p>Please note that there can be at most one user-defined callback or hijack for each instance of a stopping event (the same syscall, signal or breakpoint address). If a new stopping event is defined for the same thing, the new stopping event will replace the old one, and a warning will be printed.</p> <p>Internally, hijacks are considered callbacks, so you cannot have a callback and hijack registered for the same event.</p>","boost":4},{"location":"stopping_events/debugging_flow/#common-apis-of-stopping-events","title":"Common APIs of Stopping Events","text":"<p>All libdebug stopping events share some common attributes that can be employed in debugging scripts.</p>","boost":4},{"location":"stopping_events/debugging_flow/#enabledisable","title":"Enable/Disable","text":"<p>All stopping events can be enabled or disabled at any time. You can read the <code>enabled</code> attribute to check the current state of the event. To enable or disable the event, you can call the <code>enable()</code> or <code>disable()</code> methods respectively.</p>","boost":4},{"location":"stopping_events/debugging_flow/#callback","title":"Callback","text":"<p>The callback function of the event can be set, changed or removed (set to <code>None</code>) at any time. Please be mindful of the event mode resulting from the change on the callback parameter. Additionally, you can set the callback to <code>True</code> to register an empty callback.</p>","boost":4},{"location":"stopping_events/debugging_flow/#hit-records","title":"Hit Records","text":"<p>Stopping events have attributes that can help you keep track of hits. For example, the <code>hit_count</code> attribute stores the number of times the event has been triggered.</p> <p>The <code>hit_on()</code> function is used to check if the stopping event was the cause of the process stopping. It is particularly useful when debugging multithreaded applications, as it takes a ThreadContext as a parameter. Refer to multithreading for more information.</p>","boost":4},{"location":"stopping_events/debugging_flow/#hijacking","title":"Hijacking","text":"<p>Hijacking is a powerful feature that allows you to change the flow of the process when a stopping event is hit. It is available for both syscalls and signals, but currently not for other stopping events. When registering a hijack for a compatible stopping event, that execution flow will be replaced with another.</p> Example hijacking of a SIGALRM to a SIGUSR1 <p>For example, in the case of a signal, you can specify that a received <code>SIGALRM</code> signal should be replaced with a <code>SIGUSR1</code> signal. This can be useful when you want to prevent a process from executing a certain code path. In fact, you can even use the hijack feature to \"NOP\" the syscall or signal altogether, avoiding it to be executed / forwarded to the processed. More information on how to use this feature in each stopping event can be found in their respective documentation.</p>","boost":4},{"location":"stopping_events/debugging_flow/#recursion","title":"Recursion","text":"<p>Mixing asynchronous callbacks and hijacking can become messy. Because of this, libdebug provides users with the choice of whether to execute the callback for an event that was triggered by a callback or hijack.</p> <p>This behavior is enabled by the parameter <code>recursive</code>, available when instantiating a syscall handler, a signal catcher, or their respective hijackers. By default, recursion is disabled.</p> <p>Recursion Loop Detection</p> <p>When carelessly doing recursive callbacks and hijacking, it could happen that loops are created. libdebug automatically performs checks to avoid these situations and raises an exception if an infinite loop is detected.</p> <p>For example, the following code raises a <code>RuntimeError</code>:</p> <pre><code>handler = d.hijack_syscall(\"read\", \"write\", recursive=True)\nhandler = d.hijack_syscall(\"write\", \"read\", recursive=True)\n</code></pre>","boost":4},{"location":"stopping_events/signals/","title":"Signals","text":"<p>Signals are a feature of POSIX systems like (e.g., the Linux kernel) that provide a mechanism for asynchronous communication between processes and the operating system. When certain events occur (e.g., hardware interrupts, illegal operations, or termination requests) the kernel can send a signal to a process to notify it of the event. Each signal is identified by a unique integer and corresponds to a specific type of event. For example, <code>SIGINT</code> (usually triggered by pressing <code>Ctrl+C</code>) is used to interrupt a process, while <code>SIGKILL</code> forcefully terminates a process without cleanup. </p> <p>Processes can handle these signals in different ways: they may catch and define custom behavior for certain signals, ignore them, or allow the default action to occur.</p> <p>Restrictions on Signal Catching</p> <p>libdebug does not support catching <code>SIGTRAP</code>, <code>SIGSTOP</code>, and <code>SIGKILL</code>. While the first is used internally for debugging purposes, the other two cannot be blocked as a result of kernel limitations.</p> <p>libdebug allows you to intercept signals sent to the tracee. Specifically, you can choose to catch or hijack a specific signal (read more on hijacking).</p>","boost":4},{"location":"stopping_events/signals/#signal-catchers","title":"Signal Catchers","text":"<p>Signal catchers can be created to register stopping events for when a signal is received.</p> <p>Multiple catchers for the same signal</p> <p>Please note that there can be at most one user-defined catcher or hijack for each signal. If a new catcher is defined for a signal that is already caught or hijacked, the new catcher will replace the old one, and a warning will be printed.</p>","boost":4},{"location":"stopping_events/signals/#libdebug-api-for-signal-catching","title":"libdebug API for Signal Catching","text":"<p>The <code>catch_signal()</code> function in the Debugger object registers a catcher for the specified signal.</p> <p>Function Signature</p> <pre><code>d.catch_signal(signal, callback=None, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>signal</code> <code>int</code> | <code>str</code> The signal number or name to catch. If set to <code>\"*\"</code> or <code>\"all\"</code>, all signals will be caught. <code>callback</code> <code>Callable</code> | <code>bool</code> (see callback signature here) The callback function to be executed when the signal is received. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the catcher's callback will be executed even if the signal was triggered by a hijack. <p>Returns:</p> Return Type Description <code>SignalCatcher</code> SignalCatcher The catcher object created.","boost":4},{"location":"stopping_events/signals/#callback-signature","title":"Callback Signature","text":"<p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, catcher: SignalCatcher):\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that received the signal. <code>catcher</code> SignalCatcher The SignalCatcher object that triggered the callback. <p>Signals in multi-threaded applications</p> <p>In the Linux kernel, an incoming signal could be delivered to any thread in the process. Please do not assume that the signal will be delivered to a specific thread in your scripts.</p> <p>Example usage of asynchronous signal catchers</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\n# Define the callback function\ndef catcher_SIGUSR1(t, catcher):\n    t.signal = 0x0\n    print(\"Look mum, I'm catching a signal\")\n\ndef catcher_SIGINT(t, catcher):\n    print(\"Look mum, I'm catching another signal\")\n\n# Register the signal catchers\ncatcher1 = d.catch_signal(10, callback=catcher_SIGUSR1)\ncatcher2 = d.catch_signal('SIGINT', callback=catcher_SIGINT)\n\nd.cont()\nd.wait()\n</code></pre> <p>Example of synchronous signal catching</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\ncatcher = d.catch_signal(10)\nd.cont()\n\nif catcher.hit_on(d):\n    print(\"Signal 10 was caught\")\n</code></pre> <p>The script above will print \"Signal 10 was entered\".</p>","boost":4},{"location":"stopping_events/signals/#hijacking","title":"Hijacking","text":"<p>When hijacking a signal, the user can provide an alternative signal to be executed in place of the original one. Internally, the hijack is implemented by registering a catcher for the signal and replacing the signal number with the new one.</p> <p>Function Signature</p> <pre><code>d.hijack_signal(original_signal, new_signal, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>original_signal</code> <code>int</code> | <code>str</code> The signal number or name to be hijacked. If set to <code>\"*\"</code> or <code>\"all\"</code>, all signals except the restricted ones will be hijacked. <code>new_signal</code> <code>int</code> | <code>str</code> The signal number or name to be delivered instead. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the catcher's callback will be executed even if the signal was dispached by a hijack. <p>Returns:</p> Return Type Description <code>SignalCatcher</code> SignalCatcher The catcher object created. <p>Example of hijacking a signal</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;signal.h&gt;\n\n// Handler for SIGALRM\nvoid handle_sigalrm(int sig) {\n    printf(\"You failed. Better luck next time\\n\");\n    exit(1);\n}\n\n// Handler for SIGUSR1\nvoid handle_sigusr1(int sig) {\n    printf(\"Congrats: flag{pr1nt_pr0vol4_1s_th3_w4y}\\n\");\n    exit(0);\n}\n\nint main() {\n    // Set up the SIGALRM handler\n    struct sigaction sa_alrm;\n    sa_alrm.sa_handler = handle_sigalrm;\n    sigemptyset(&amp;sa_alrm.sa_mask);\n    sa_alrm.sa_flags = 0;\n    sigaction(SIGALRM, &amp;sa_alrm, NULL);\n\n    // Set up the SIGUSR1 handler\n    struct sigaction sa_usr1;\n    sa_usr1.sa_handler = handle_sigusr1;\n    sigemptyset(&amp;sa_usr1.sa_mask);\n    sa_usr1.sa_flags = 0;\n    sigaction(SIGUSR1, &amp;sa_usr1, NULL);\n\n    // Set an alarm to go off after 10 seconds\n    alarm(10);\n\n    printf(\"Waiting for a signal...\\n\");\n\n    // Infinite loop, waiting for signals\n    while (1) {\n        pause(); // Suspend the program until a signal is caught\n    }\n\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.hijack_signal(\"SIGALRM\", \"SIGUSR1\")\n\nd.cont()\n\n# Will print \"Waiting for a signal...\"\nout = pipe.recvline()\nprint(out.decode())\n\nd.wait()\n\n# Will print the flag\nout = pipe.recvline()\nprint(out.decode())\n</code></pre>","boost":4},{"location":"stopping_events/signals/#signal-filtering","title":"Signal Filtering","text":"<p>Instead of setting a catcher on signals, you might want to filter which signals are not to be forwarded to the debugged process during execution.</p> <p>Example of signal filtering</p> <pre><code>d.signals_to_block = [10, 15, 'SIGINT', 3, 13]\n</code></pre>","boost":4},{"location":"stopping_events/signals/#arbitrary-signals","title":"Arbitrary Signals","text":"<p>You can also send an arbitrary signal to the process. The signal will be forwarded upon resuming execution. As always, you can specify the signal number or name.</p> <p>Example of sending an arbitrary signal</p> <pre><code>d.signal = 10\nd.cont()\n</code></pre> <p>In multithreaded applications, the same syntax applies when using a ThreadContext object instead of the Debugger object.</p>","boost":4},{"location":"stopping_events/stopping_events/","title":"Stopping Events","text":"<p>Debugging a process involves stopping the execution at specific points to inspect the state of the program. libdebug provides several ways to stop the execution of a program, such as breakpoints, syscall handling and signal catching. This section covers the different stopping events available in libdebug.</p>","boost":4},{"location":"stopping_events/stopping_events/#is-the-process-running","title":"Is the process running?","text":"<p>Before we dive into the different stopping events, it is important to understand how to check if the process is running. The <code>running</code> attribute of the Debugger object returns <code>True</code> if the process is running and <code>False</code> otherwise.</p> <p>Example</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"program\")\n\nd.run()\n\nif d.running:\n    print(\"The process is running\")\nelse:\n    print(\"The process is not running\")\n</code></pre> <p>In this example, the script should print <code>The process is not running</code>, since the <code>run()</code> command gives you control over a stopped process, ready to be debugged.</p> <p>To know more on how to wait for the process to stop or forcibly cause it to stop, please read about control flow commands.</p>","boost":4},{"location":"stopping_events/syscalls/","title":"Syscalls","text":"<p>System calls (a.k.a. syscalls or software interrupts) are the interface between user space and kernel space. They are used to request services from the kernel, such as reading from a file or creating a new process. libdebug allows you to trace syscalls invoked by the debugged program. Specifically, you can choose to handle or hijack a specific syscall (read more on hijacking).</p> <p>For extra convenience, the Debugger and the ThreadContext objects provide a system-agnostic interface to the arguments and return values of syscalls. Interacting directly with these parameters enables you to create scripts that are independent of the syscall calling convention specific to the target architecture.</p> Field Description <code>syscall_number</code> The number of the syscall. <code>syscall_arg0</code> The first argument of the syscall. <code>syscall_arg1</code> The second argument of the syscall. <code>syscall_arg2</code> The third argument of the syscall. <code>syscall_arg3</code> The fourth argument of the syscall. <code>syscall_arg4</code> The fifth argument of the syscall. <code>syscall_arg5</code> The sixth argument of the syscall. <code>syscall_return</code> The return value of the syscall. <p>Example of Syscall Parameters</p> <pre><code>[...] # (1)\n\nbinsh_str = d.memory.find(b\"/bin/sh\\x00\", file=\"libc\")[0]\n\nd.syscall_arg0 = binsh_str\nd.syscall_arg1 = 0x0\nd.syscall_arg2 = 0x0\nd.syscall_number = 0x3b\n\nd.step() # (2)\n</code></pre> <ol> <li>The instruction pointer is on a syscall / SVC instruction</li> <li>Now the <code>execve('/bin/sh', 0, 0)</code> will be executed in place of the previous syscall.</li> </ol>","boost":4},{"location":"stopping_events/syscalls/#syscall-handlers","title":"Syscall Handlers","text":"<p>Syscall handlers can be created to register stopping events for when a syscall is entered and exited.</p> <p>Do I have to handle both on enter and on exit?</p> <p>When using asynchronous syscall handlers, you can choose to handle both or only one of the two events. However, when using synchronous handlers, both events will stop the process.</p>","boost":4},{"location":"stopping_events/syscalls/#libdebug-api-for-syscall-handlers","title":"libdebug API for Syscall Handlers","text":"<p>The <code>handle_syscall()</code> function in the Debugger object registers a handler for the specified syscall.</p> <p>Function Signature</p> <pre><code>d.handle_syscall(syscall, on_enter=None, on_exit=None, recursive=False) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be handled. If set to <code>\"*\"</code> or <code>\"all\"</code> or <code>\"ALL\"</code>, all syscalls will be handled. <code>on_enter</code> <code>Callable</code> | <code>bool</code> (see callback signature here) The callback function to be executed when the syscall is entered. <code>on_exit</code> <code>Callable</code> | <code>bool</code> (see callback signature here) The callback function to be executed when the syscall is exited. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the handler's callback will be executed even if the syscall was triggered by a hijack or caused by a callback. <p>Returns:</p> Return Type Description <code>SyscallHandler</code> SyscallHandler The handler object created.","boost":4},{"location":"stopping_events/syscalls/#callback-signature","title":"Callback Signature","text":"<p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, handler: HandledSyscall) -&gt; None:\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the syscall. <code>handler</code> SyscallHandler The SyscallHandler object that triggered the callback. <p>Nuances of Syscall Handling</p> <p>The syscall handler is the only stopping event that can be triggered by the same syscall twice in a row. This is because the handler is triggered both when the syscall is entered and when it is exited. As a result the <code>hit_on()</code> method of the SyscallHandler object will return <code>True</code> in both instances.</p> <p>You can also use the <code>hit_on_enter()</code> and <code>hit_on_exit()</code> functions to check if the cause of the process stop was the syscall entering or exiting, respectively.</p> <p>As for the <code>hit_count</code> attribute, it only stores the number of times the syscall was exited.</p> <p>Example usage of asynchronous syscall handlers</p> <pre><code>def on_enter_open(t: ThreadContext, handler: SyscallHandler):\n    print(\"entering open\")\n    t.syscall_arg0 = 0x1\n\ndef on_exit_open(t: ThreadContext, handler: SyscallHandler):\n    print(\"exiting open\")\n    t.syscall_return = 0x0\n\nhandler = d.handle_syscall(syscall=\"open\", on_enter=on_enter_open, on_exit=on_exit_open)\n</code></pre> <p>Example of synchronous syscall handling</p> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.handle_syscall(syscall=\"open\")\nd.cont()\n\nif handler.hit_on_enter(d):\n    print(\"open syscall was entered\")\nelif handler.hit_on_exit(d):\n    print(\"open syscall was exited\")\n</code></pre> <p>The script above will print \"open syscall was entered\".</p>","boost":4},{"location":"stopping_events/syscalls/#resolution-of-syscall-numbers","title":"Resolution of Syscall Numbers","text":"<p>Syscall handlers can be created with the identifier number of the syscall or by the syscall's common name. In the second case, syscall names are resolved from a definition list for Linux syscalls on the target architecture. The list is fetched from mebeim's syscall table. We thank him for hosting such a precious resource. Once downloaded, the list is cached internally. </p>","boost":4},{"location":"stopping_events/syscalls/#hijacking","title":"Hijacking","text":"<p>When hijacking a syscall, the user can provide an alternative syscall to be executed in place of the original one. Internally, the hijack is implemented by registering a handler for the syscall and replacing the syscall number with the new one.</p> <p>Function Signature</p> <pre><code>d.hijack_syscall(original_syscall, new_syscall, recursive=False, **kwargs) \n</code></pre> <p>Parameters:</p> Argument Type Description <code>original_syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be hijacked. If set to <code>\"*\"</code> or <code>\"all\"</code> or <code>\"ALL\"</code>, all syscalls will be hijacked. <code>new_syscall</code> <code>int</code> | <code>str</code> The syscall number or name to be executed instead. <code>recursive</code> <code>bool</code> If set to <code>True</code>, the handler's callback will be executed even if the syscall was triggered by a hijack or caused by a callback. <code>**kwargs</code> <code>(int, optional)</code> Additional arguments to be passed to the new syscall. <p>Returns:</p> Return Type Description <code>SyscallHandler</code> SyscallHandler The handler object created. <p>Example of hijacking a syscall</p> <pre><code>#include &lt;unistd.h&gt;\n\nchar secretBuffer[32] = \"The password is 12345678\";\n\nint main(int argc, char** argv)\n{\n    [...]\n\n    read(0, secretBuffer, 31);\n\n    [...]\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nhandler = d.hijack_syscall(\"read\", \"write\")\n\nd.cont()\nd.wait()\n\nout = pipe.recvline()\nprint(out.decode())\n</code></pre> <p> In this case, the secret will be leaked to the standard output instead of being overwritten with content from the standard input.</p> <p>For your convenience, you can also easily provide the syscall parameters to be used when the hijacked syscall is executed:</p> <p>Example of hijacking a syscall with parameters</p> <pre><code>#include &lt;unistd.h&gt;\n\nchar manufacturerName[32] = \"libdebug\";\nchar secretKey[32] = \"provola\";\n\nint main(int argc, char** argv)\n{\n    [...]\n\n    read(0, manufacturerName, 31);\n\n    [...]\n    return 0;\n}\n</code></pre> <pre><code>from libdebug import debugger\n\nd = debugger(\"./test_program\")\nd.run()\n\nmanufacturerBuffer = ...\n\nhandler = d.hijack_syscall(\"read\", \"write\",\n    syscall_arg0=0x1,\n    syscall_arg1=manufacturerBuffer,\n    syscall_arg2=0x100\n)\n\nd.cont()\nd.wait()\n\nout = pipe.recvline()\nprint(out.decode())\n</code></pre> <p>Again, the secret will be leaked to the standard output.</p>","boost":4},{"location":"stopping_events/watchpoints/","title":"Watchpoints","text":"<p>Watchpoints are a special type of hardware breakpoint that triggers when a specific memory location is accessed. You can set a watchpoint to trigger on certain memory access conditions, or upon execution (equivalent to a hardware breakpoint).</p> <p>Features of watchpoints are shared with breakpoints, so you can set asynchronous watchpoints and use properties in the same way.</p>","boost":4},{"location":"stopping_events/watchpoints/#libdebug-api-for-watchpoints","title":"libdebug API for Watchpoints","text":"<p>The <code>watchpoint()</code> function in the Debugger object sets a watchpoint at a specific address. While you can also use the breakpoint API to set up a watchpoint, a specific API is provided for your convenience:</p> <p>Function Signature</p> <pre><code>d.watchpoint(position, condition='w', length=1, callback=None, file='hybrid') \n</code></pre> <p>Parameters:</p> Argument Type Description <code>position</code> <code>int</code> | <code>str</code> The address or symbol where the watchpoint will be set. <code>condition</code> <code>str</code> The type of access (see later section). <code>length</code> <code>int</code> The size of the word being watched (see later section). <code>callback</code> <code>Callable</code> | <code>bool</code> (see callback signature here) Used to create asyncronous watchpoints (read more on the debugging flow of stopping events). <code>file</code> <code>str</code> The backing file for relative addressing. Refer to the memory access section for more information on addressing modes. <p>Returns:</p> Return Type Description <code>Breakpoint</code> Breakpoint The breakpoint object created.","boost":4},{"location":"stopping_events/watchpoints/#valid-access-conditions","title":"Valid Access Conditions","text":"<p>The <code>condition</code> parameter specifies the type of access that triggers the watchpoint. Default is write access.</p> Condition Description Supported Architectures <code>\"r\"</code> Read access AArch64 <code>\"w\"</code> Write access AMD64, AArch64 <code>\"rw\"</code> Read/write access AMD64, AArch64 <code>\"x\"</code> Execute access AMD64","boost":4},{"location":"stopping_events/watchpoints/#valid-word-lengths","title":"Valid Word Lengths","text":"<p>The <code>length</code> parameter specifies the size of the word being watched. By default, the watchpoint is set to watch a single byte.</p> Architecture Supported Lengths AMD64 1, 2, 4, 8 AArch64 Any length from 1 to 8 bytes <p>Watchpoint alignment in AArch64</p> <p>The address of the watchpoint on AArch64-based CPUs needs to be aligned to 8 bytes. Instead, basic hardware breakpoints have to be aligned to 4 bytes (which is the size of an ARM instruction).</p>","boost":4},{"location":"stopping_events/watchpoints/#callback-signature","title":"Callback Signature","text":"<p>If you wish to create an asynchronous watchpoint, you will have to provide a callback function. Since internally watchpoints are implemented as hardware breakpoints, the callback signature is the same as for breakpoints. As for breakpoints, if you want to leave the callback empty, you can set callback to <code>True</code>.</p> <p>Callback Signature</p> <pre><code>def callback(t: ThreadContext, bp: Breakpoint):\n</code></pre> <p>Parameters:</p> Argument Type Description <code>t</code> ThreadContext The thread that hit the breakpoint. <code>bp</code> Breakpoint The breakpoint object that triggered the callback. <p>Example usage of asynchronous watchpoints</p> <pre><code>def on_watchpoint_hit(t, bp):\n    print(f\"RAX: {t.regs.rax}\")\n\n    if bp.hit_count == 100:\n        print(\"Hit count reached 100\")\n        bp.disable()\n\nd.watchpoint(0x11f0, condition=\"rw\", length=8, callback=on_watchpoint_hit, file=\"binary\")\n</code></pre>","boost":4},{"location":"blog/archive/2024/","title":"2024","text":""}]}